[{"content":"Spring（一） Spring框架概述   概述\n  Spring是轻量级的开源JavaEE框架\n  Spring可以解决企业应用开发的复杂性\n  Spring有两个核心部分：IOC和AOP\n IOC：控制反转，把创建对象的过程交给Spring进行管理 Aop：面向切面，不修改源代码进行功能增强    Spring特点\n1、Spring是一个开源免费的框架 , 容器 .\n2、Spring是一个轻量级的框架 , 非侵入式的 .\n3、控制反转 IoC , 面向切面 Aop\n4、对事物的支持 , 对框架的支持\n 概括来说就是：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n     Spring的组成\nSpring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .\n组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：\n  核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\n  Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\n  Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。\n  Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\n  Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\n  Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\n  Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n    IOC IOC基础 下面我们通过简单的获取用户数据实例代码来演示IOC的推导过程\n  先写一个UserDao接口\npackage com.dao; public interface UserDao { public void getUser(); }   编写UserDao的实现类\npackage com.dao; public class UserDaoImpl implements UserDao{ @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } }   然后去写UserService的接口\npackage com.service; public interface UserService { public void getUser(); }   最后写Service的实现类\npackage com.service; import com.dao.UserDao; import com.dao.UserDaoImpl; public class UserServiceImpl implements UserService{ private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } }   测试一下\npackage com.test; import com.service.UserService; import com.service.UserServiceImpl; import org.junit.Test; public class TestDemo2 { @Test public void testIOC1(){ UserService service = new UserServiceImpl(); service.getUser(); } }   这是我们原来的方式，这样子可以实现Service层去访问用户的数据。如果我们现在改一下：\n把UserDao的实现类增加一个访问MySQL的用户数据\npackage com.dao; public class UserMySqlImpl implements UserDao{ @Override public void getUser() { System.out.println(\u0026#34;MySQL获取用户数据\u0026#34;); } } 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 如果我们需要在增加一个用Oracle访问的实现类\npublic class UserDaoOracleImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;Oracle获取用户数据\u0026#34;); } } 当我们要使用Oracle时，又需要去Service实现类那里修改对应的实现，假设我们的这种需求非常大，这种方式就不适用了，每次变动都需要修改大量代码，这种设计的耦合性太高了，牵一发而动全身！\n那我们要怎么样去解决呢？\n我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set方法 , 我们去UserServiceImpl 那修改下 .\npackage com.service; import com.dao.UserDao; import com.dao.UserDaoImpl; public class UserServiceImpl implements UserService{ private UserDao userDao ; public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 这时，我们去测试类测试一下\n@Test public void testIOC2(){ //使用MySQL访问  UserServiceImpl service1 = new UserServiceImpl(); service1.setUserDao(new UserMySqlImpl()); service1.getUser(); //使用Oracle访问  UserServiceImpl service2 = new UserServiceImpl(); service2.setUserDao(new UserOracleImpl()); service2.getUser(); } 我们可以发现，以前的所有东西都是由程序去进行控制创建的，而现在是由我们自行控制创建对象，把主动权交给了调用者，程序就不用去管怎么创建，怎么实现的了，它只负责提供一个接口\n这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !\nIOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nIoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。\nSpring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\nIOC的实现  IOC底层是由xml解析+工厂模式+反射实现的\n   IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\n  Spring提供IOC容器的两种实现方式（两个接口）：\n  BeanFactory：IOC容器的基本实现，是Spring内部的使用接口，不提供开发人员进行使用\n使用该接口时，加载配置文件时候不会创建对象，在获取对象（使用）的时候才会去创建对象\n  ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用\n加载配置文件时候就会把在配置文件的对象进行创建\n    IOC操作Bean管理\n  什么是Bean管理\nBean管理指的是两个操作\n Spring创建对象 Spring注入属性    Bean管理操作有两种方式\n 基于xml配置文件方式实现 基于注解方式实现      IOC操作Bean管理\n  基于xml方式创建对象\n\u0026lt;bean id = \u0026#34;user\u0026#34; class=\u0026#34;com.company.User\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 在Spring的配置文件中，使用bean标签可以实现对象的创建\nBean标签有属性，常用的有\n id：唯一标识 class：类的全路径（包类路径）  创建对象时，默认是执行无参构造方法完成构造的创建\n    创建第一个Spring程序\n  导入基本jar包\n注意：spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 。\n  创建Hello实体类\npackage com.company; /** * @Author: minster * @Date: 2021/10/13 20:52 */ public class Hello { private String name ; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;Hello \u0026#34; + name); } }   编写我们的spring文件 , 这里我们命名为bean2.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--使用Spring创建的对象，在Spring中都称为Bean 类型 变量名 = new 类型(); Hello hello = new Hello(); 上述代码与下面Bean标签的代码作用一样！ --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;com.company.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   编写测试方法\n@Test public void testSpring02(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean2.xml\u0026#34;); Hello hello = context.getBean(\u0026#34;hello\u0026#34;, Hello.class); System.out.println(hello); hello.show(); }   上述创建Hello对象的过程就叫做控制反转：\n 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 .    依赖注入（DI）：利用set方法来进行注入属性的方法叫依赖注入。它实现了IOC\n  IOC是一种编程思想，由主动的编程变成被动的接收\n  此时，我们要实现不同的操作时，只需要在xml配置文件中进行修改，所谓的IOC就是对象由Spring来创建，装配\n  IOC创建对象的方式   通过无参构造方法来创建\n创建SpringIoc01.class\npackage com.spring01.dao; /** * @Author: minster * @Date: 2021/10/14 22:56 */ public class SpringIoc01 { private String name; public SpringIoc01() { System.out.println(\u0026#34;无参构造注入\u0026#34;); } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;name = \u0026#34; + name); } } 在配置文件中加入\n\u0026lt;bean id = \u0026#34;springIoc01\u0026#34; class=\u0026#34;com.spring01.dao.SpringIoc01\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 测试方法testSpring2\n@Test public void testSpring2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans1.xml\u0026#34;); SpringIoc01 springIoc01 = context.getBean(\u0026#34;springIoc01\u0026#34;, SpringIoc01.class); springIoc01.show(); } 运行后可以发现，在调用show方法之前，User对象就已经通过无参构造函数初始化了！\n  通过有参构造方法来创建\n创建SpringIoc02.class\npackage com.spring01.dao; /** * @Author: minster * @Date: 2021/10/14 22:56 */ public class SpringIoc02 { private String name; public SpringIoc02(String name) { this.name = name; System.out.println(\u0026#34;无参构造注入\u0026#34;); } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;name = \u0026#34; + name); } } 第一种配置方式\n\u0026lt;!--第一种：根据index参数下标设置参数--\u0026gt; \u0026lt;bean id = \u0026#34;springIoc02\u0026#34; class=\u0026#34;com.spring01.dao.SpringIoc02\u0026#34;\u0026gt; \u0026lt;!--index指构造方法的index，下标从0开始--\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 第二种配置方式\n\u0026lt;!-- 第二种根据参数名字设置 --\u0026gt; \u0026lt;bean id = \u0026#34;springIoc02\u0026#34; class=\u0026#34;com.spring01.dao.SpringIoc02\u0026#34;\u0026gt; \u0026lt;!-- name指参数名 --\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;jack1\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 第三种配置方式\n\u0026lt;!-- 第三种根据参数数据类型 --\u0026gt; \u0026lt;bean id = \u0026#34;springIoc02\u0026#34; class=\u0026#34;com.spring01.dao.SpringIoc02\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;jack3\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 使用根据参数类型注入属性时，系统会按照参数类型的顺序先后注入！\n测试代码\n@Test public void testSpring3(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans1.xml\u0026#34;); SpringIoc02 springIoc02 = context.getBean(\u0026#34;springIoc02\u0026#34;, SpringIoc02.class); springIoc02.show(); }   Bean的配置：\n  bean就是java对象,由Spring创建和管理\n  id是bean的标识符，要唯一，如果没有配置id，name就是默认标识符；如果配置了id，又配置了name，那么name是别名，name可以设置多个别名，可以用逗号，分号，空格隔开；\n\u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   如果不配置bean的id和name，可以根据applicationContext.getBean(.class)获取对象；\n  class是bean的全限定名 = 包名+类名\n  设置别名：在获取Bean的时候可以使用别名获取\n\u0026lt;alias name=\u0026#34;userT\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt;   依赖注入(DI)   概念\n 依赖注入（Dependency Injection,DI）。 依赖：指Bean对象的创建依赖于容器，Bean对象的依赖资源 注入：指Bean对象所依赖的资源，由容器来设置和装配    构造器注入\n见上述IOC创建对方的方式\n  Set注入\n要求被注入的属性（资源），必须有Set方法，Set方法的方法名由setXxx组成，如果属性时Boolean类型，没有set方法，但有is方法\n测试PIJO类：\n  创建Address类\npackage com.spring01.pojo; /** * @Author: minster * @Date: 2021/10/19 10:08 */ public class Address { private String address; public void setAddress(String address) { this.address = address; } public String getAddress() { return address; } @Override public String toString() { return \u0026#34;Address{\u0026#34; + \u0026#34;address=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   创建Student类\npackage com.spring01.pojo; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; /** * @Author: minster * @Date: 2021/10/19 10:08 */ public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String, String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; public void setName(String name) { this.name = name; } public void setAddress(Address address) { this.address = address; } public void setBooks(String[] books) { this.books = books; } public void setHobbys(List\u0026lt;String\u0026gt; hobbys) { this.hobbys = hobbys; } public void setCard(Map\u0026lt;String, String\u0026gt; card) { this.card = card; } public void setGames(Set\u0026lt;String\u0026gt; games) { this.games = games; } public void setWife(String wife) { this.wife = wife; } public void setInfo(Properties info) { this.info = info; } public void show(){ System.out.println(\u0026#34;name = \u0026#34; + name+\u0026#34;,address = \u0026#34; + address + \u0026#34;,book = \u0026#34;); for (String book : books) { System.out.print(\u0026#34;\u0026lt;\u0026lt;\u0026#34;+book+\u0026#34;\u0026gt;\u0026gt;\\t\u0026#34;); } System.out.println(\u0026#34;\\n爱好:\u0026#34;+hobbys); System.out.println(\u0026#34;card = \u0026#34; + card); System.out.println(\u0026#34;games = \u0026#34; + games); System.out.println(\u0026#34;wife = \u0026#34; + wife); System.out.println(\u0026#34;info = \u0026#34; + info); } }   创建Spring的配置文件beans2.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id = \u0026#34;student\u0026#34; class=\u0026#34;com.spring01.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--1.常量注入--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--2.Bean注入,因为address是引用，所以使用了外部bean注入，ref--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;addr\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--3.数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;三国演义\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--4.List注入--\u0026gt; \u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;跑步\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--6.Map注入--\u0026gt; \u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;445323222222\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;学生证\u0026#34; value=\u0026#34;201810098046\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--7.Set注入--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;COC\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CF\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--8.null注入--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt;\u0026lt;null\u0026gt;\u0026lt;/null\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--9.Properties注入--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;学号\u0026#34;\u0026gt;2018100\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;性别\u0026#34;\u0026gt;男\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;姓名\u0026#34;\u0026gt;jack\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--外部Bean--\u0026gt; \u0026lt;bean id = \u0026#34;addr\u0026#34; class=\u0026#34;com.spring01.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;重庆\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 创建测试方法testStuent.java\n@Test public void testStudent(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans2.xml\u0026#34;); Student student = context.getBean(\u0026#34;student\u0026#34;, Student.class); student.show(); }   测试结果：\n    p命名和c命名注入\n  P(属性: properties)命名空间注入 : 需要在头文件中加入约束文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.spring01.pojo.User\u0026#34; p:name=\u0026#34;jack\u0026#34; p:age=\u0026#34;18\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 注意：如果此时User类写了构造方法系统会报错！！\n  c (构造: Constructor)命名空间注入 : 需要在头文件中加入约束文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- C(构造: Constructor)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;com.spring01.pojo.User\u0026#34; c:name=\u0026#34;lucy\u0026#34; c:age=\u0026#34;18\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 注意：如果User类没有写构造方法系统会报错！\n    Bean的作用域 在Spring中，那些组成应用程序的主体及由Spring IOC容器所管理的对象，都被称之为Bean。简单地讲，Bean就是IOC容器初始化、装配及管理的对象\n singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。 prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。  几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。\nSingleton 当一个Bean的作用域为Singleton时，那么Spring IoC容器中只会存在一个共享的Bean实例，并且所有对bean的请求，只要id与该Bean定义相匹配，则只会返回Bean的统一实例。\nSingleton是单例类型，就是在创建起容器时就会同时自动创建一个Bean对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring的缺省作用域。要在XML中将Bean定义成Singleton，可以这样配置：\n\u0026lt;bean id=\u0026#34;serviceImpl\u0026#34; class=\u0026#34;com.spring01.service.ServiceImpl\u0026#34; scope=\u0026#34;singleton\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 测试代码\n@Test public void testBean01(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans4.xml\u0026#34;); ServiceImpl serviceImpl1 = context.getBean(\u0026#34;serviceImpl\u0026#34;, ServiceImpl.class); ServiceImpl serviceImpl2 = context.getBean(\u0026#34;serviceImpl\u0026#34;, ServiceImpl.class); System.out.println(serviceImpl1==serviceImpl2); } 测试结果\nPrototype 当一个Bean的作用域为prototype时，表示一个Bean定义对应多个对象实例。Prototype作用域的Bean会导致每次对该Bean请求（将其注入到另外一个Bean中，，或者以程序的方式调用容器的getBean()方法）时都会创建一个一个新的Bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取Bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。\n根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。\n在XML中将Bean定义成Prototype，可以这样配置\n\u0026lt;bean id=\u0026#34;serviceImpl\u0026#34; class=\u0026#34;com.spring01.service.ServiceImpl\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 或 \u0026lt;bean id=\u0026#34;serviceImpl\u0026#34; class=\u0026#34;com.spring01.service.ServiceImpl\u0026#34; singleton=\u0026#34;false\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 测试类\npackage SpringTest; import com.spring01.service.ServiceImpl; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class BeanTest { @Test public void testBean01(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans4.xml\u0026#34;); ServiceImpl serviceImpl1 = context.getBean(\u0026#34;serviceImpl\u0026#34;, ServiceImpl.class); ServiceImpl serviceImpl2 = context.getBean(\u0026#34;serviceImpl\u0026#34;, ServiceImpl.class); System.out.println(serviceImpl1); System.out.println(serviceImpl2); System.out.println(serviceImpl1==serviceImpl2); } } 测试结果：\nRequest 当一个Bean的作用域为Request时，表示在一次请求HTTP中，一个Bean定义对应一个实例；即每个HTTP请求都会各自的Bean实例，它们依据某个Bean定义创建而成。该作用域仅基于web的Spring ApplicationContext情形下有效。例如下面Bean定义\n\u0026lt;bean id=\u0026#34;loginAction\u0026#34; class=\u0026#34;cn.csdn.LoginAction\u0026#34; scope=\u0026#34;request\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 针对每一次HTTP请求，Spring容器会根据loginAction Bean的定义创建一个全新的LoginAction Bean实例，且该loginAction Bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction Bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的Bean实例将会被销毁。\nSession 当一个Bean的作用域为Session时，表示一个HTTP Session中，一个Bean定义对应一个实例。该作用域仅在基于Web的Spring ApplicationContext情形下有效。例如下面Bean定义：\n\u0026lt;bean id=\u0026#34;userPreferences\u0026#34; class=\u0026#34;com.foo.UserPreferences\u0026#34; scope=\u0026#34;session\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到某些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。\n","date":"2021-10-04T16:22:25+08:00","permalink":"https://minster77.github.io/p/spring%E4%B8%80/","title":"Spring（一）"},{"content":"Spring（二） Beaen的自动装配  自动装配是Spring满足Bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给Bean装配属性    byName自动装配\nbyName：会自动在容器上下文中查找和自己对象set方法后面的值对应的bean id\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.heng.pojo.Dog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.heng.pojo.Person\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 使用byName时，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！\n  byType自动装配\nbyType：会自动在容器上下文中查找和自己对象属性类型相同的bean\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.heng.pojo.Dog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.heng.pojo.Person\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 使用byType时，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n  使用注解实现自动装配\n要使用注解，则需要做以下准备工作：\n  导入约束\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt;   配置注解的支持\n\u0026lt;context:annotation-config/\u0026gt;   @Autowired\n  该注解对类的成员变量、方法及构造方法进行标注，完成自动装配工作。**其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。**当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。\n  该注解是按类型自动装配的，不支持id匹配\n  代码测试：\n将User类中的set方法去掉，使用@Autowired注解\npackage com.heng.pojo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; /** * @Author: minster * @Date: 2021/10/25 8:56 */ public class Person { @Autowired private Cat cat; @Autowired private Dog dog; private String name; public String getName() { return name; } public Cat getCat() { return cat; } public Dog getDog() { return dog; } } 此时配置文件的内容为\n\u0026lt;context:annotation-config\u0026gt;\u0026lt;/context:annotation-config\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dog1\u0026#34; class=\u0026#34;com.heng.pojo.Dog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.heng.pojo.Person\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 编写测试代码，成功输出结果！\n  扩展：当@Autowired(required=false)的时候，说明对象可以为null；@Autowired注解中该属性默认为true，即对象不能为null\n@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * \u0026lt;p\u0026gt;Defaults to {@code true}. */ boolean required() default true; } 如果允许对象为null，设置required = false,默认为true\n@Autowired(required = false) private Cat cat;   @Qualifier\n @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用  代码测试：\n  修改配置文件内容，保证类型存在对象。且名字不为类的默认名字！\n\u0026lt;context:annotation-config\u0026gt;\u0026lt;/context:annotation-config\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dog1\u0026#34; class=\u0026#34;com.heng.pojo.Dog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dog2\u0026#34; class=\u0026#34;com.heng.pojo.Dog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.heng.pojo.Person\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 此时我们使用@Autowired注解来标记对象，测试，程序报错\n  在属性上添加@Qualifier注解\n@Autowired @Qualifier(value = \u0026#34;cat1\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; 再进行测试，成功输出！\n  @Resource\n @Resource如果指定的name属性，则先按该属性进行byName方式进行查找装配 其次再进行默认的byName方式进行装配 如果以上都不成功，则按byType的方式进行自动装配  代码测试\n  修改Person中的代码\n//指定name的属性 @Resource(name = \u0026#34;cat1\u0026#34;) private Cat cat; @Resource private Dog dog;   配置文件代码\n\u0026lt;context:annotation-config\u0026gt;\u0026lt;/context:annotation-config\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.heng.pojo.Cat\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dog1\u0026#34; class=\u0026#34;com.heng.pojo.Dog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 测试，成功输出结果\n    小结：\n@Autowired与@Resource异同：\n @Autowired与@Resource都可以用来装配bean。都可以写在字段或setter方法上。 @Autowired默认按照类型装配（属于Spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如@Autowired(required = false)，如果我们想使用byName完成自动装配，则可以结合@Quaalifier注解进行使用 @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。  它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n  使用注解开发 常用的注解有：\n @Component 是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。 @Controller 通过@Controller注解说明该类非普通类，而是一个控制器类。 @Repository 用于注解dao层，在daoImpl类上面注解。 @Service 用于注解Service层，在ServiceImpl类上面注解。 @RequestMapping 通过RequestMapping注解映射请求URL @Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。 @Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）  Singleton （单例,一个Spring容器中只有一个bean实例，默认模式） Protetype （每次调用新建一个bean） Request （web项目中，给每个http request新建一个bean） Session （web项目中，给每个http session新建一个bean） GlobalSession（给每一个 global http session新建一个Bean实例）    在Spring4之后，要使用注解开发，需要导入AOP的包\n在配置文件中，还需要引入一个context约束\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--指定注解扫描包--\u0026gt; \u0026lt;context:annotation-config\u0026gt;\u0026lt;/context:annotation-config\u0026gt; \u0026lt;/beans\u0026gt; 代码测试：\n  编写User类，添加注解\npackage com.heng.pojo; import org.springframework.stereotype.Component; /** * @Author: minster * @Date: 2021/10/25 15:08 */ //相当于配置文件中的 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.heng.pojo.User\u0026gt; @Component(\u0026#34;user\u0026#34;) public class User { public String name = \u0026#34;jack\u0026#34;; }   在xml配置文件中加入指定注解扫描包\n\u0026lt;!--指定注解扫描包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.heng.pojo\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!--支持注解--\u0026gt; \u0026lt;context:annotation-config\u0026gt;\u0026lt;/context:annotation-config\u0026gt;   编写测试类\n@Test public void test01(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application.xml\u0026#34;); User user = context.getBean(\u0026#34;user\u0026#34;, User.class); System.out.println(user.name); } 成功输出\n  使用注解注入属性：\n  可以不用提供set方法，直接在属性上面添加@Value(\u0026ldquo;值\u0026rdquo;)注解\n/** 相当于配置文件中的 * \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.heng.pojo.User\u0026gt; * \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; * \u0026lt;/bean\u0026gt; * */ @Component(\u0026#34;user\u0026#34;) public class User { @Value(\u0026#34;jack\u0026#34;) public String name ; }   如果提供了set方法，可以在set方法上添加Value(\u0026ldquo;值\u0026rdquo;)；\npublic int age; @Value(\u0026#34;10\u0026#34;) public void setAge(int age) { this.age = age; }   测试结果：\n  小结：\n XML与注解比较  XML可以适用任何场景，结构清晰，维护方便 注解不是自己提供的类适用不了，开发简单方便   xml与注解整合开发：推荐最佳实践！  xml管理bean 注解完成属性注入 适用过程中，可以不用扫描，扫描是为了类上的注解   \u0026lt;context:annotation-config/\u0026gt; 作用  进行注解驱动注册，从而使注解生效 用于激活那些已经在Spring容器里注册过的Bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加载注解驱动，则注入的值为Null    基于Java类进行配置\n  JavaConfig原本是Spring的一个子项目，它通过Java类的方式提供了Bean的定义信息，在Spring4的版本，JavaConfig已正式成为Spring4的核心功能！\n  代码测试\n  编写一个实体类Dog\n@Component public class Dog { public String name = \u0026#34;dog\u0026#34;; }   新建一个Config包，编写配置类MyConfig\n//Configuration代表这是一个配置类 @Configuration public class MyConfig { //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！  @Bean public Dog dog(){ return new Dog(); } }   编写测试方法\n@Test public void test02(){ ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) context.getBean(\u0026#34;dog\u0026#34;); System.out.println(dog.name); }   测试结果：\n  注意：如果需要对实体类的属性进行注入，使用@Value(\u0026ldquo;值\u0026rdquo;)注解即可\npackage com.heng.pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; /** * @Author: minster * @Date: 2021/10/25 15:38 */ @Component public class Dog { public String name = \u0026#34;dog\u0026#34;; @Value(\u0026#34;10\u0026#34;) public int age; }     如果此时需要导入其他类，我们可以使用@Import\n  其他配置类MyConfig2\n@Configuration public class MyConfig2 { }   修改MyConfig\npackage com.heng.config; import com.heng.pojo.Dog; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; /** * @Author: minster * @Date: 2021/10/25 15:39 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) //Configurationd代表这是一个配置类 @Configuration @Import(MyConfig2.class) public class MyConfig { //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！  @Bean public Dog dog(){ return new Dog(); } } 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可~\n  AOP   什么是AOP\nAOP（Aspect Oriented Programming）：面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可拓展性和可维护性。\nSpring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP就会使用JDK Proxy，去创建代理对象，而对没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP就会使用Cglib生成一个被代理对象的子类来作为代理，如下图所示：\n当然你也可以使用 AspectJ ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。\n  AOP的相关名词\n 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。    现在我们举一个例子来理解什么是AOP\nAOP：Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。\n例如：现有三个类：Horse、Pig、Dog，这三个类中都有eat和run两个方法\n通过OOP思想中的继承，我们可以提取出一个Animal的父类，然后将eat和run方法放入父类中，Horse、Pig、Dog通过继承Animal类即可自动获得eat()和run()方法。这样将会少写很多代码。\nOOP 编程思想可以解决大部分的代码重复问题。但是有一些问题是处理不了的。比如在父类 Animal 中的多个方法的相同位置出现了重复的代码，OOP 就解决不了。\n/** * 动物父类 */ public class Animal { /** 身高 */ private String height; /** 体重 */ private double weight; public void eat() { // 性能监控代码  long start = System.currentTimeMillis(); // 业务逻辑代码  System.out.println(\u0026#34;I can eat...\u0026#34;); // 性能监控代码  System.out.println(\u0026#34;执行时长：\u0026#34; + (System.currentTimeMillis() - start)/1000f + \u0026#34;s\u0026#34;); } public void run() { // 性能监控代码  long start = System.currentTimeMillis(); // 业务逻辑代码  System.out.println(\u0026#34;I can run...\u0026#34;); // 性能监控代码  System.out.println(\u0026#34;执行时长：\u0026#34; + (System.currentTimeMillis() - start)/1000f + \u0026#34;s\u0026#34;); } } 这部分重复的代码，一般统称为 横切逻辑代码。\n横切逻辑代码存在的问题：\n 代码重复问题 横切逻辑代码和业务代码混杂在一起，代码臃肿，不变维护  AOP就是用来解决这些问题的！\nAOP 另辟蹊径，提出横向抽取机制，将横切逻辑代码和业务逻辑代码分离\n代码拆分比较容易，难的是如何在不改变原有业务逻辑的情况下，悄无声息的将横向逻辑代码应用到原有的业务逻辑中，达到和原来一样的效果。\n  AOP 解决了什么问题\n通过上面的分析可以发现，AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。\n  AOP 为什么叫面向切面编程\n切 ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑\n面 ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念\n  在AOP中，通过Advice定义横切逻辑，Spring中支持5中类型的Advice：\n即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .\n  使用Spring来实现AOP\n  导入新的相关依赖包\n\u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   第一种实现方式：通过Spring API实现\n  编写业务接口和实现类\nUserService业务接口：\npackage com.heng.service; /** * @Author: minster * @Date: 2021/10/25 19:45 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) public interface UserService { public void add(); public void delete(); public void update(); public void select(); } UserServiceImpl接口实现类\npackage com.heng.service; /** * @Author: minster * @Date: 2021/10/25 19:45 */ public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新了一个用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } 编写横切逻辑代码（就是增强类 , 我们编写两个 , 一个前置增强 一个后置增强）\n前置增强类BeforeLog\npackage com.heng.log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; //method : 要执行的目标对象的方法  //args : 被调用的方法的参数  //target : 目标对象 public class BeforeLog implements MethodBeforeAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;方法被执行了\u0026#34;); } } 后置增强类AfterLog\npackage com.heng.log; import org.springframework.aop.AfterReturningAdvice; import java.lang.reflect.Method; //returnValue 返回值  //method被调用的方法  //args 被调用的方法的对象的参数  //target 被调用的目标对象 public class AfterLog implements AfterReturningAdvice { @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34; + target.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;方法,\u0026#34;+\u0026#34;返回值:\u0026#34;+returnValue); } } 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册Bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.heng.service.UserServiceImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.heng.log.AfterLog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;beforeLog\u0026#34; class=\u0026#34;com.heng.log.BeforeLog\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--AOP配置--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点 expression：表达式匹配要执行的方法,execution(要执行的位置 * * * * *) execution(修饰符(一般省略) 返回值 包.类.方法名(参数) throws异常(一般省略))--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.heng.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕:advice-ref 执行方法，pointcut-ref 切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:advisor\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;beforeLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;\u0026gt;\u0026lt;/aop:advisor\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 测试方法\n@Test public void testAop(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); userService.add(); } 运行结果：\n Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .\n   第二种方式：自定义类来实现AOP\n目标业务类不变依旧是userServiceImpl\n  写我们自己的一个切入类\npublic class DiyPointcut { public void before(){ System.out.println(\u0026#34;---------方法执行前---------\u0026#34;); } public void after(){ System.out.println(\u0026#34;---------方法执行后---------\u0026#34;); } }   去applicationContext中配置\n\u0026lt;!--第二种方式自定义实现--\u0026gt; \u0026lt;!--注册bean--\u0026gt; \u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;com.kuang.config.DiyPointcut\u0026#34;/\u0026gt; \u0026lt;!--aop的配置--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--第二种方式：使用AOP的标签实现--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;diyPonitcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:before pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;before\u0026#34;/\u0026gt; \u0026lt;aop:after pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;after\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;   测试，成功输出！\n  第三种方式：使用注解完成\n  编写一个注解实现的增强类\npackage com.heng.config; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; /** * @Author: minster * @Date: 2021/10/26 8:08 */ @Aspect public class AnnotationPointcut { @Before(\u0026#34;execution(* com.heng.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;方法执行前\u0026#34;); } @After(\u0026#34;execution(* com.heng.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;方法执行后\u0026#34;); } @Around(\u0026#34;execution(* com.heng.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); } }   在配置文件中，注册Bean，并增加支持注解的配置\n\u0026lt;bean id=\u0026#34;annotationPointcut\u0026#34; class=\u0026#34;com.heng.config.AnnotationPointcut\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; aop:aspectj-autoproxy：说明\n 通过aop命名空间的\u0026lt;aop:aspectj-autoproxy /\u0026gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被\u0026lt;aop:aspectj-autoproxy /\u0026gt;隐藏起来了\n\u0026lt;aop:aspectj-autoproxy /\u0026gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强\n当配为\u0026lt;aop:aspectj-autoproxy poxy-target-class=\u0026quot;true\u0026quot;/\u0026gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。\n   测试，成功输出\n  **注意：**使用注解增强类完成切入时，切入顺序为环绕前-\u0026gt;方法执行前-\u0026gt;方法-\u0026gt;方法执行后-\u0026gt;环绕后\n  整合MyBatis 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。\n在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：\n\u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/heng/dao/UserMapper.xml\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。\n 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。\n   在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。\n  SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。\n  一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 \u0026lt; settings\u0026gt; 或 \u0026lt; typeAliases\u0026gt;元素。\n 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（\u0026lt;environments\u0026gt;），数据源（\u0026lt;DataSource\u0026gt;）和 MyBatis 的事务管理器（\u0026lt;transactionManager\u0026gt;）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。\n   SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。\npublic SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) { this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType()); } 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。\n可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。\n\u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：\npublic class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.getMapper(UserMapper.class).getUser(); } } 按下面这样，注入 SqlSessionTemplate：\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;org.mybatis.spring.sample.dao.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 图示：\n整合实现示例\n  引入Spring配置文件spring-dao.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt;   配置数据源替换MyBatis数据源\n\u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;777777\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 如果在配置文件中写了数据库的配置的话，用以下方法配置数据源\ndb.properties\ndriver=com.mysql.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;userUnicode=true\u0026amp;characterEncoding=utf8\rusername=root\rpassword=777777\rspring-dao.xml\n\u0026lt;context:property-placeholder location=\u0026#34;db.properties\u0026#34;\u0026gt;\u0026lt;/context:property-placeholder\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${driver}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   配置SqlSessionFactory，关联MyBatis\n\u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;、 \u0026lt;!--关联MyBatis--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/heng/dao/UserMapper.xml\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   注册sqlSessionTemplate，关联sqlSessionFactory；\n\u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--利用构造器注入--\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;   增加Dao接口的实现类；私有化sqlSessionTemplate\npackage com.heng.dao; import com.heng.pojo.User; import org.mybatis.spring.SqlSessionTemplate; import java.util.List; public class UserMapperImpl implements UserMapper{ private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; getUser(){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); } }   注册Bean实现\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.heng.dao.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserMapper mapper = (UserMapper) context.getBean(\u0026#34;userDao\u0026#34;); List\u0026lt;User\u0026gt; user = mapper.selectUser(); System.out.println(user); } 此时我们查看MyBAtis配置文件，可以发现大部分功能被整合！\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.heng.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt;   当然，我们还有一种整合MyBatis的方式，这种方式更加简洁，不需要管理SqlSessionTemplate，而且对事物支持更加友好\n示例代码：\n  将上述UserDaoImpl修改一下，继承SqlSessionDaoSupport类\npackage com.heng.dao; import com.heng.pojo.User; import org.mybatis.spring.SqlSessionTemplate; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper{ @Override public List\u0026lt;User\u0026gt; getUser(){ UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.getUser(); } }   修改Bean的配置\n\u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;com.heng.dao.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   测试，输出结果与上面一样\n  Spring事物管理   回顾事物\n 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。  事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用\n  事务的四个特性\n  原子性（atomicity）\n  事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用\n  一致性（consistency）\n  一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中\n  隔离性（isolation）\n  可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏\n  持久性（durability）\n  事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中\n    Spring中的事物管理\n 编程式事务  将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码   声明式事务  一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。      使用声明式事务代码演示\n  头文件导入约束\nxmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd   配置事务管理器\n 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。  \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource \u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   配置事务通知\n\u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--配置哪些方法可以使用什么样的事物，配置事务的传播特性默认为REQUIRED--\u0026gt; \u0026lt;tx:method name=\u0026#34;add\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;delete\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;update\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;!--为所有方法配置事务的方式--\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;\u0026gt;\u0026lt;/tx:method\u0026gt; \u0026lt;!--查询方法，配置事务为只可读，保护数据--\u0026gt; \u0026lt;tx:method name=\u0026#34;query\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt;  事务的传播特性：\n事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：\n propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作  Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。\n   在Spring中使用AOP的方式配置事务\n\u0026lt;aop:config\u0026gt; \u0026lt;!--配置切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPointcut\u0026#34; expression=\u0026#34;execution(* com.heng.dao.*.*(..) )\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPointcut\u0026#34;\u0026gt;\u0026lt;/aop:advisor\u0026gt; \u0026lt;/aop:config\u0026gt;   测试\n@Test public void testTransaction(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;spring-dao.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); User jack = new User(7, \u0026#34;jack\u0026#34;, \u0026#34;111111\u0026#34;); Map map = new HashMap(); map.put(\u0026#34;id\u0026#34;,3); map.put(\u0026#34;name\u0026#34;,\u0026#34;陈立业\u0026#34;); map.put(\u0026#34;pwd\u0026#34;,\u0026#34;111111\u0026#34;); int addUser = userMapper.addUser(jack); int deleteUser = userMapper.deleteUser(5); int updateUser = userMapper.updateUser(map); List\u0026lt;User\u0026gt; users = userMapper.getUser(); for (User user : users) { System.out.println(user); } }   ","date":"2021-10-04T16:22:25+08:00","permalink":"https://minster77.github.io/p/spring%E4%BA%8C/","title":"Spring（二）"},{"content":"MyBatis(二) MyBatis resultMap元素 resultMap是MyBatis中最复杂的元素，主要用于解决实体类属性名与数据库表中字段名不一致的情况，可以将查询结果映射成实体对象。下面我们先从最简单的功能开始介绍\n 现有的MyBatis版本只支持resultMap查询，不支持更新或者保存，更不必说级联的更新、删除和修改。\n   resultMap元素的构成\nresultMap元素可以包含以下子元素，代码如下\n\u0026lt;resultMap id = \u0026#34;\u0026#34; type = \u0026#34;\u0026#34; \u0026gt; \u0026lt;!--类在实例化时用来注入结果的构造方法--\u0026gt; \u0026lt;constructor\u0026gt; \u0026lt;!--ID是参数，结果为ID--\u0026gt; \u0026lt;idArg\u0026gt;\u0026lt;/idArg\u0026gt; \u0026lt;!--注入到构造方法的一个普通结果--\u0026gt; \u0026lt;arg\u0026gt;\u0026lt;/arg\u0026gt; \u0026lt;/constructor\u0026gt; \u0026lt;!-- 用于表示哪个列是主键 --\u0026gt; \u0026lt;id\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;!--注入到字段或JavaBean属性的普通结果--\u0026gt; \u0026lt;result\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;!--用于一对一关联--\u0026gt; \u0026lt;association property = \u0026#34;\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;!--用于一对多、多对多关联--\u0026gt; \u0026lt;collection property = \u0026#34;\u0026#34;\u0026gt;\u0026lt;/collection\u0026gt; \u0026lt;!--使用结果值来决定使用哪个结果映射--\u0026gt; \u0026lt;discriminator javaType = \u0026#34;\u0026#34;\u0026gt; \u0026lt;!--基于某些值的结果映射--\u0026gt; \u0026lt;case value = \u0026#34;\u0026#34;\u0026gt;\u0026lt;/case\u0026gt; \u0026lt;/discriminator\u0026gt; \u0026lt;/resultMap\u0026gt; 其中：\n \u0026lt;resultMap\u0026gt; 元素的 type 属性表示需要的 POJO，id 属性是 resultMap 的唯一标识。 子元素 \u0026lt;constructor\u0026gt; 用于配置构造方法。当一个 POJO 没有无参数构造方法时使用。 子元素 \u0026lt;id\u0026gt; 用于表示哪个列是主键。允许多个主键，多个主键称为联合主键。 子元素\u0026lt;result\u0026gt;用于表示 POJO 和 SQL 列名的映射关系。 子元素 \u0026lt;association\u0026gt;、\u0026lt;collection\u0026gt; 和 \u0026lt;discriminator\u0026gt; 在级联的情况下使用  \u0026lt;id\u0026gt;和\u0026lt;result\u0026gt;元素都有以下属性\n property： 映射到列结果的字段或属性。如果 POJO 的属性和 SQL 列名（column元素）是相同的，那么 MyBatis 就会映射到 POJO 上 column：对应SQL列 javaType：配置Java类型。可以是特定的类完全限定名或MyBatis上下文的别名 jdbcType：配置数据库类型。这是JDBC类型，MyBatis已经为我们做了限定，基本支持所有常用的数据库类型 typeHandler：类型处理器。允许你用特定的处理器来覆盖MyBatis默认的处理器。需要指定jdbcType和javaType相互转化的规则    一条 SQL 查询语句执行后会返回结果集，结果集有两种存储方式，即使用 Map 存储和使用 POJO 存储。\n  使用Map存储结果集\n任何select语句都可以使用Map存储，代码如下\nUserMapper.java\nList\u0026lt;Map\u0026lt;String,Object\u0026gt;\u0026gt; selectUserById(int id); UserMapper.xml\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt; Map的key是select语句查询的字段名（必须完全一样），而Map的value是查询返回结果中字段对应的值，一条记录映射到一个Map对象中。\n使用Map存储结果集很方便，但可读性稍差，所以一般推荐使用POJO的方式存储\n  使用POJO存储结果集\n因为MyBatis提供了自动映射，所以使用POJO存储结果集是最常用的方式。但有时候需要更加复杂的映射或级联，这时就需要使用select元素的resultMap属性配置映射集合。\nUserMapper.XML代码如下\n\u0026lt;resultMap id=\u0026#34;myResult\u0026#34; type=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; resultMap 元素的属性 id 代表这个 resultMap 的标识，type 标识需要映射的 POJO。我们可以使用 MyBatis 定义好的类的别名或自定义类的全限定名。\n这里使用 property 元素指定 Website 的属性名称 uname，column 表示数据库中 website 表的 SQL 列名 name，将 POJO 和 SQL 的查询结果一 一对应。\n\u0026lt;select id=\u0026#34;selectAllByResultMap\u0026#34; resultMap=\u0026#34;myResult\u0026#34;\u0026gt; select id,name from user \u0026lt;/select\u0026gt; 可以发现 SQL 语句的列名和 myResult 中的 column 一一对应。\n  resultType和resultMap的区别\nMyBatis 的每一个查询映射的返回类型都是 resultMap，只是当我们提供的返回类型是 resultType 时，MyBatis 会自动把对应的值赋给 resultType 所指定对象的属性，而当我们提供的返回类型是 resultMap 时，MyBatis 会将数据库中的列数据复制到对象的相应属性上，可用于复制查询。\n需要注意的是，resultMap 和 resultType 不能同时使用。\n  日志工厂  思考：当我们在测试SQL的时候，要是能够在控制台输出SQL的话，是不是就能够有更快的排错效率？\n 如果一个数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。\n对于以往的开发过程，我们会经常使用debug模式来调节，跟踪我们的代码执行过程。但是现在使用MyBatis开发是基于接口的，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具\nMyBatis内置的日志工厂提供日志功能，具体的实现有以下几种工具：\n  STDOUT_LOGGING（标准日志实现）\n  SLF4J\n  Apache Commons Logging\n  Log4j 2\n  Log4j（最常用的日志工具）\n  JDK logging\n  标准日志实现\n指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug\nLog4J\n简介：\n Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件\u0026hellip;. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。  使用步骤：\n  导log4j的包\n\u0026lt;!-- https://mvnrepository.com/artifact/log4j/log4j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置文件编写\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\rlog4j.rootLogger=DEBUG,console,file\r#控制台输出的相关设置\rlog4j.appender.console = org.apache.log4j.ConsoleAppender\rlog4j.appender.console.Target = System.out\rlog4j.appender.console.Threshold=DEBUG\rlog4j.appender.console.layout = org.apache.log4j.PatternLayout\rlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\r#文件输出的相关设置\rlog4j.appender.file = org.apache.log4j.RollingFileAppender\rlog4j.appender.file.File=./log/heng.log\rlog4j.appender.file.MaxFileSize=10mb\rlog4j.appender.file.Threshold=DEBUG\rlog4j.appender.file.layout=org.apache.log4j.PatternLayout\rlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\r#日志输出级别\rlog4j.logger.org.mybatis=DEBUG\rlog4j.logger.java.sql=DEBUG\rlog4j.logger.java.sql.Statement=DEBUG\rlog4j.logger.java.sql.ResultSet=DEBUG\rlog4j.logger.java.sql.PreparedStatement=DEBUG\r  setting设置日志实现\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   在程序中使用Log4j进行输出\nimport org.apache.log4j.Logger; class Log4JTest{ static Logger logger = Logger.getLogger(MyTest.class); @Test public void testLog4j(){ logger.info(\u0026#34;info:进入了testLog4j方法\u0026#34;); logger.debug(\u0026#34;debug:进入了testLog4j方法\u0026#34;); logger.error(\u0026#34;error:进入了testLog4j方法\u0026#34;); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } session.close(); } }   测试，看控制台输出！\n 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改file的日志级别】    MyBatis实现分页  为什么需要分页？\n​\t在学习MyBatis等持久层框架的时候，会经常对数据进行增、删、改、查操作，使用最多的是对数据库进行查询操作，在查询大量数据的时候，我们往往会使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围。\n   使用Limit实现分页\n#语法 #startIndex:分页开始的页码；pageSize:分页的大小（分多少页） select*fromuserlimitstartIndex,pageSize#查询第6到10行记录（检索行6-10） select*fromuserlimit5,5#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1 #检索第91行到最后一行的数据（91-last） select*fromuserlimit90,-1#如果给定一个参数，它表示返回最大的记录行数目 #检索前5行记录（0-5） select*fromuserlimit5#换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤：\n  修改UserMapper接口，或使用注解\nList\u0026lt;User\u0026gt; selectUserByLimit(Map\u0026lt;String, Integer\u0026gt; map); 使用注解\n@Select(\u0026#34;select * from user limit #{startIndex},#{pageSize}\u0026#34;) @ResultMap(value = \u0026#34;userMapper\u0026#34;) public List\u0026lt;User\u0026gt; seletUserByLimit(Map\u0026lt;String, Integer\u0026gt; map);   修改Mapper文件（使用注解不需要）\n\u0026lt;select id=\u0026#34;selectUserByLimit\u0026#34; resultMap=\u0026#34;myResult\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; select * from user limit #{startIndex},#{pageSize} \u0026lt;/select\u0026gt;   在测试类进行传参测试\n@Test public void selectUserByLimit(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); HashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;startIndex\u0026#34;,2); map.put(\u0026#34;pageSize\u0026#34;,2); List\u0026lt;User\u0026gt; users = mapper.selectUserByLimit(map); for (User user : users) { System.out.println(user); } session.close(); }   测试程序，输出结果\n    RowBounds分页\n我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！\n步骤：\n  Mapper接口\n//选择全部用户RowBounds实现分页 List\u0026lt;User\u0026gt; getUserByRowBounds();   mapper文件\n\u0026lt;select id=\u0026#34;getUserByRowBounds\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt;   测试类\n在这里，我们需要使用RowBounds类\n@Test public void testUserByRowBounds() { SqlSession session = MybatisUtils.getSession(); int currentPage = 2; //第几页  int pageSize = 2; //每页显示几个  RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize); //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]  List\u0026lt;User\u0026gt; users = session.selectList(\u0026#34;com.heng.mapper.UserMapper.getUserByRowBounds\u0026#34;, null, rowBounds); for (User user: users){ System.out.println(user); } session.close(); }     PageHelper实现分页\n官方文档：https://pagehelper.github.io/\n  MyBatis注解  MyBatis注解本质是反射实现！底层为动态代理模式\n 为了简化XML的配置，MyBatis提供了注解。我们可以通过MyBatis的jar包查看注解，如下图所示\n以上注解主要分为三大类，即SQL语句映射、结果集映射和关系映射。下面将分别进行讲解\n  SQL语句映射\n  @Insert：实现新增功能\n@Insert(\u0026#34;insert into user(id,name) values(#{id},#{name})\u0026#34;) public int insert(User user);   @Select：实现查询功能\n@Select(\u0026#34;Select * from user\u0026#34;) @Results({ @Result(id = true,column = \u0026#34;id\u0026#34; , property = \u0026#34;id\u0026#34;), @Result(id = true,column = \u0026#34;name\u0026#34; , property = \u0026#34;name\u0026#34;), @Result(id = true,column = \u0026#34;pwd\u0026#34; , property = \u0026#34;pwd\u0026#34;) }) List\u0026lt;User\u0026gt; queryAllUser();   @SelectKey：插入后，获取id的值\n以MySQL为例，MySQL在插入一条数据后，使用select last_insert_id()可以获取到自增id的值\n@Insert(\u0026#34;insert into user(id,name) values(#{id},#{name})\u0026#34;) @SelectKey(statement = \u0026#34;select last_insert_id\u0026#34;,keyProperty = \u0026#34;id\u0026#34;,KeyColumn = \u0026#34;id\u0026#34;,resultType = int,before = false) public int insert(User user); @SelectKey各个属性含义如下\n statement：表示要运行的SQL语句 keyProperty：可选项，表示将查询结果赋值给数据表中的哪一列； keyColumn：可选项，表示将查询结果赋值给数据表中的哪一列； resultType：指定SQL语句的返回值； before：默认值为true，在执行插入语句之前，执行select last_insert_id()。值为false，则在执行插入语句之后，执行select last_insert_id()。    @Update：实现更新功能\n@Update(\u0026#34;Update user set name = #{name},pwd = #{pwd} where id = #{id}\u0026#34;) public void updateUserById(User user);   @delete：实现删除功能\n@ddelete(\u0026#34;delete from user where id = #{id}\u0026#34;) public void deleteUserById(Integer id);   @Param：映射多个参数\n@Param用于在Mapper接口中映射多个参数\nint saveUser(@Param(value=\u0026#34;user\u0026#34;) User user,@Param(\u0026#34;name\u0026#34;) String name,@Param(\u0026#34;pwd\u0026#34;) String pwd); @Param 中的 value 属性可省略，用于指定参数的别名 。\n关于@Param注解：\n 基本类型的参数或者String类型的参数都需要加上这个注解 引用类型不需要加      结果集映射\n@Result、@Results、@ResultMap 是结果集映射的三大注解。\n声明结果集映射关系代码：\n@Select({\u0026#34;select id, name, class_id from student\u0026#34;}) @Results(id=\u0026#34;studentMap\u0026#34;, value={ @Result(column=\u0026#34;id\u0026#34;, property=\u0026#34;id\u0026#34;, jdbcType=JdbcType.INTEGER, id=true), @Result(column=\u0026#34;name\u0026#34;, property=\u0026#34;name\u0026#34;, jdbcType=JdbcType.VARCHAR), @Result(column=\u0026#34;class_id \u0026#34;, property=\u0026#34;classId\u0026#34;, jdbcType=JdbcType.INTEGER) }) List\u0026lt;Student\u0026gt; selectAll(); 下面为 @Results 各个属性的含义。\n id：表示当前结果集声明的唯一标识； value：表示结果集映射关系； @Result：代表一个字段的映射关系。其中，column 指定数据库字段的名称，property 指定实体类属性的名称，jdbcType 数据库字段类型，id 为 true 表示主键，默认 false。  可使用 @ResultMap 来引用映射结果集，其中 value 可省略。\n@Select({\u0026#34;select id, name, class_id from student where id = #{id}\u0026#34;}) @ResultMap(value=\u0026#34;studentMap\u0026#34;) Student selectById(Integer id); 这样不需要每次声明结果集映射时都复制冗余代码，简化开发，提高了代码的复用性。\n  关系映射\n  @one：用于一对一关系映射\n@Select(\u0026#34;select * from student\u0026#34;) @Results({ @Result(id=true,property=\u0026#34;id\u0026#34;,column=\u0026#34;id\u0026#34;), @Result(property=\u0026#34;name\u0026#34;,column=\u0026#34;name\u0026#34;), @Result(property=\u0026#34;age\u0026#34;,column=\u0026#34;age\u0026#34;), @Result(property=\u0026#34;address\u0026#34;,column=\u0026#34;address_id\u0026#34;,one=@One(select=\u0026#34;net.biancheng.mapper.AddressMapper.getAddress\u0026#34;)) }) public List\u0026lt;Student\u0026gt; getAllStudents();   @many：用于一对多关系映射\n@Select(\u0026#34;select * from t_class where id=#{id}\u0026#34;) @Results({ @Result(id=true,column=\u0026#34;id\u0026#34;,property=\u0026#34;id\u0026#34;), @Result(column=\u0026#34;class_name\u0026#34;,property=\u0026#34;className\u0026#34;), @Result(property=\u0026#34;students\u0026#34;, column=\u0026#34;id\u0026#34;, many=@Many(select=\u0026#34;net.biancheng.mapper.StudentMapper.getStudentsByClassId\u0026#34;)) }) public Class getClass(int id);     MyBatis关联（级联）查询 级联关系是一个数据库实体的概念，有3种级联关系，分别是一对一级联、一对多级联以及多对多级联。例如，一个角色可以分配给多个用户，也可以只分配给一个用户。大部分场景下，我们都需要获取角色信息和用户信息，所以会经常遇见一下SQL：\nSELECTr.*,u.*FROMt_rolerINNERJOINt_user_roleurONr.id=ur.idINNERJOINt_useruONur.user_id=u.idWHEREr.id=#{id} 在级联中存在三种对应的关系。\n 一对多的关系，如角色和用户的关系。通俗的理解就是，一家软件公司会存在许多软件工程师，公司和软件工程师就是一对多的关系。 一对一的关系。每个软件工程师都有一个编号（ID），这是他在公司的标识，它与工程师是一对一的关系。 多对多的关系，有一些公司一个角色可以对应多个用户，但是一个用户可以兼任多个角色。通俗的说，一个人既可以是总经理，同时也是技术总监，而技术总监这个职位可以对应多个人，这就是多对多的关系。   实际应用中，由于多对多的关系比较复杂，会增加理解和关联的复杂度，所以应用较少。推荐的方法是，用一对多的关系把它分解为双向关系，以降低关系的复杂度，简化程序。\n 级联的优点是获取关联数据十分便捷。但是级联过多会增加系统的复杂度，同时降低系统的性能，此增彼减。所以记录超过 3 层时，就不要考虑使用级联了，因为这样会造成多个对象的关联，导致系统的耦合、负载和难以维护。\nMyBatis一对一关联查询 一对一级联关系在现实生活中是非常常见的，例如一个大学生只有一个学号，一个学号只属 于一个学生。同样，人与身份证也是一对一的级联关系。\n在MyBatis中，通过\u0026lt;resultMap\u0026gt;元素的子元素\u0026lt;association\u0026gt;处理一对一级联关系。实例代码如下：\n\u0026lt;association property=\u0026#34;studentCard\u0026#34; column=\u0026#34;cardId\u0026#34; javaType=\u0026#34;net.biancheng.po.StudentCard\u0026#34; select=\u0026#34;net.biancheng.mapper.StudentCardMapper.selectStuCardById\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; 在\u0026lt;association\u0026gt;元素中通常使用以下属性：\n property：指定映射到实体类的对象属性 column：指定表中对应的字段（即查询返回的列名）。 javaType：指定映射到实体对象属性的类型。 select：指定引入嵌套查询的子SQL语句，该属性用于关联映射中的嵌套查询  一对一关联查询可采用以下两种方式：\n 单步查询，通过关联查询实现 分步查询，通过两次或多次查询，为一对一关系的实体Bean赋值  MyBatis多对一关联查询 多对一关联查询其实就是一对一关联查询的衍生；\n例如：\n  多个学生对应一个老师\n  如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！\n  在数据库中关系图如下\n  示例\n查询学生的所有信息，包括对应老师的姓名\n基于查询嵌套处理关联\n  设计MySQL\nCREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOteacher(`id`,`name`)VALUES(1,\u0026#39;秦老师\u0026#39;);CREATETABLE`student`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;1\u0026#39;,\u0026#39;小明\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;2\u0026#39;,\u0026#39;小红\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;3\u0026#39;,\u0026#39;小张\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;4\u0026#39;,\u0026#39;小李\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;5\u0026#39;,\u0026#39;小王\u0026#39;,\u0026#39;1\u0026#39;);  创建实体类Student以及Teacher\nSrudent类\npackage com.heng.pojo; import lombok.Data; /** * @Author: minster * @Date: 2021/10/29 15:27 */ //使用lombok的Data注解可以帮我们自动配置构造器、getter和setter方法 @Data public class Student { private int id; private String name; private Teacher teacher; } Teacher类\npackage com.heng.pojo; import lombok.Data; /** * @Author: minster * @Date: 2021/10/29 15:26 */ @Data public class Teacher { private int id; private String name; }   创建StudentMapper接口，在此接口增加方法\npackage com.heng.dao; import com.heng.pojo.Student; import org.apache.ibatis.annotations.Param; import java.util.List; /** * @Author: minster * @Date: 2021/10/29 15:28 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) public interface StudentMapper { //查询所有的学生信息，以及对应的老师信息  List\u0026lt;Student\u0026gt; selectStudentAll(); }   编写对应的Mapper.xml配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.StudentMapper\u0026#34;\u0026gt; \u0026lt;!-- 需求：获取所有学生及对应老师的信息 思路： 1.获取所有学生的信息 2.根据获取到的学生信息的tid-\u0026gt;获取该老师的信息 3.查询出来的学生结果集中包含了老师，我们需要使用关联查询来处理结果集 3.1 做一个结果集映射TeacherResult 3.2 TeacherResult结果集的类型为Student 3.3 在学生表中，有一个Teacher类的属性teacher，让其对应数据库中的tid 3.4 利用association标签来处理一个复杂类型的关联；使用它来处理关联查询 --\u0026gt; \u0026lt;select id=\u0026#34;selectStudentAll\u0026#34; resultMap=\u0026#34;TeacherResult\u0026#34; \u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherResult\u0026#34; type=\u0026#34;com.heng.pojo.Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;tid\u0026#34; javaType=\u0026#34;com.heng.pojo.Teacher\u0026#34; select=\u0026#34;selectTeacher\u0026#34;\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectTeacher\u0026#34; resultType=\u0026#34;com.heng.pojo.Teacher\u0026#34;\u0026gt; select * from teacher where id = #{tid} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; association关联的属性：、\n  property属性名\n  javaType属性类型\n  column在多的一方的表中的列名\n column多参数配置：\ncolumn=\u0026quot;{key=value,key=value}\u0026quot; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。\n     测试\n@Test public void testSelectAllStudent(){ SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; studentList = mapper.selectStudentAll(); for (Student student : studentList) { System.out.println(student); } session.close(); }   运行结果\n  按结果嵌套处理\n思路：直接查询出结果，进行结果集映射；查出来的数据需要起别名，不然两个实体类都会被同一个表数据映射\n  修改StudentMapper接口\npackage com.heng.dao; import com.heng.pojo.Student; import org.apache.ibatis.annotations.Param; import java.util.List; /** * @Author: minster * @Date: 2021/10/29 15:28 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) public interface StudentMapper { //查询所有的学生信息，以及对应的老师信息  List\u0026lt;Student\u0026gt; selectStudentAll2(); }   修改Mapper配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.StudentMapper\u0026#34;\u0026gt; \u0026lt;!--基于查询结果嵌套处理--\u0026gt; \u0026lt;select id=\u0026#34;selectStudentAll2\u0026#34; resultMap=\u0026#34;teacherResult\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id; \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;teacherResult\u0026#34; type=\u0026#34;com.heng.pojo.Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;com.heng.pojo.Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;/mapper\u0026gt;   编写测试类\n@Test public void testSelectAllStudent2(){ SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; studentList = mapper.selectStudentAll2(); for (Student student : studentList) { System.out.println(\u0026#34;Student = \u0026#34;+student.getName()+\u0026#34; Teacher = \u0026#34;+student.getTeacher().getName()); } session.close(); }   运行结果：\n  MyBatis一对多关联查询（多对多关系的拆分理解）  示例：查询一个老师的多个学生信息\n 按查询结果嵌套处理\n 思路:    从学生表和老师表中查出学生id，学生姓名，老师姓名\n  对查询出来的操作做结果集映射 1. 集合的话，使用collection！ 2. JavaType和ofType都是用来指定对象类型的 3. JavaType是用来指定pojo中属性的类型 4. ofType指定的是映射到list集合属性中pojo的类型\n  修改TeacherMapper接口\npackage com.heng.dao; import com.heng.pojo.Teacher; import org.apache.ibatis.annotations.Param; /** * @Author: minster * @Date: 2021/10/29 15:28 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) public interface TeacherMapper { public Teacher getTeacher(@Param(\u0026#34;tid\u0026#34;) int id); }   修改TeacherMapper配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.TeacherMapper\u0026#34;\u0026gt; \u0026lt;!--先把查询结果查询出来，再根据结果映射--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid,s.name sname,t.id tid,t.name tname from student s,teacher t where s.tid=t.id and tid = #{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;com.heng.pojo.Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;tid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;com.heng.pojo.Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;tid\u0026#34; column=\u0026#34;tid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;/mapper\u0026gt;   测试\n@Test public void getCourse(){ SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; studentList = mapper.getStudentCourse(2); for (Student student : studentList) { System.out.println(student); System.out.println(student.getCourse().getName()); } session.close(); }   输出结果\n  按查询嵌套处理\n  编写接口方法\npackage com.heng.dao; import com.heng.pojo.Teacher; import org.apache.ibatis.annotations.Param; /** * @Author: minster * @Date: 2021/10/29 15:28 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) public interface TeacherMapper { public Teacher getTeacher2(@Param(\u0026#34;tid\u0026#34;) int id); }   修改配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.TeacherMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id = #{tid} \u0026lt;/select\u0026gt; \u0026lt;!--column是一对多的外键 , 写的是一的主键的列名--\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;com.heng.pojo.Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;com.heng.pojo.Student\u0026#34; select=\u0026#34;getStudent\u0026#34; column=\u0026#34;id\u0026#34;\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudent\u0026#34; resultType=\u0026#34;com.heng.pojo.Student\u0026#34;\u0026gt; select * from student where tid = #{tid} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   测试\n@Test public void getTeacher2(){ SqlSession session = MybatisUtils.getSession(); TeacherMapper mapper = session.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacher2(1); System.out.println(teacher.getName()); System.out.println(teacher.getStudents()); session.close(); }   小结\n  关联-association\n  集合-collection\n  所以association是用于一对一和多对一，而collection是用于一对多的关系\n JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。    注意说明：\n  保证SQL的可读性，尽量通俗易懂\n  根据实际要求，尽量编写性能更高的SQL语句\n  注意属性名和字段不一致的问题\n  注意一对多和多对一 中：字段和属性对应的问题\n  尽量使用Log4j，通过日志来查看自己的错误\n  动态SQL 什么是动态SQL：动态SQL指的是根据不同的查询条件，生成不同的Sql语句。\n ​\tMyBatis的强大特性之一便是它的动态SQL。如果你有使用JDBC或其它类似框架的经验，你就能体会到根据不同条件拼接SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。\n​\t利用SQL并非一件易事，但正是MyBatis提供了可以被用在任意SQL映射语句中的强大的动态SQL语言得以改进这种情形。\n​\t动态SQL元素和JSTL或基于类似XML的文本处理器相似。在MyBatis之前的版本中，有很多元素需要花时间了解。MyBatis3替换了之前的大部分元素，大大精简了元素种类，现在学习的元素种类比原来的一半还要少。\n if choose (when, otherwise) trim (where, set) foreach  ——《MyBatis官方文档》\n 我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。\n那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。\n  搭建环境：新建表Blog，并插入数据\nCREATETABLE`blog`(`id`varchar(50)NOTNULLCOMMENT\u0026#39;博客id\u0026#39;,`title`varchar(100)NOTNULLCOMMENT\u0026#39;博客标题\u0026#39;,`author`varchar(30)NOTNULLCOMMENT\u0026#39;博客作者\u0026#39;,`create_time`datetimeNOTNULLCOMMENT\u0026#39;创建时间\u0026#39;,`views`int(30)NOTNULLCOMMENT\u0026#39;浏览量\u0026#39;)ENGINE=InnoDBDEFAULTCHARSET=utf8@Test public void addInitBlog(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;Mybatis如此简单\u0026#34;); blog.setAuthor(\u0026#34;狂神说\u0026#34;); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;Java如此简单\u0026#34;); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;Spring如此简单\u0026#34;); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;微服务如此简单\u0026#34;); mapper.addBlog(blog); session.close(); }     IF语句\n需求：根据作者名字和博客名字来查询博客！如果作者名字为空，name只根据博客名字查询，反之，则根据作者名来查询\n\u0026lt;!--需求1： 根据作者名字和博客名字来查询博客！ 如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询 select * from blog where title = #{title} and author = #{author} --\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog where \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; 这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！\n  Where\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。\n  Set\n同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？\n\u0026lt;!--注意set是用的逗号隔开--\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt;   choose语句\n有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句\n\u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{views} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：这里的When会由上到下按顺序执行，只要有一个成功执行，后面的都不会执行了！\n@Test public void selectByChoose(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); Map map = new HashMap(); map.put(\u0026#34;author\u0026#34;,\u0026#34;jack\u0026#34;); map.put(\u0026#34;title\u0026#34;,\u0026#34;如何让富婆爱上我\u0026#34;); map.put(\u0026#34;views\u0026#34;,\u0026#34;1000\u0026#34;); List\u0026lt;Blog\u0026gt; blogs = mapper.selectByChoose(map); for (Blog blog : blogs) { System.out.println(blog); } session.close(); }    所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面，去执行逻辑代码\n   Foreach\nforeach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！\n collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串  示例代码\n\u0026lt;select id=\u0026#34;queryBlogByForEach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;com.heng.pojo.Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;and (\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 测试\n@Test public void queryBlogByForEach(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); Map map = new HashMap(); List list = new ArrayList(); list.add(1); list.add(2); list.add(3); map.put(\u0026#34;ids\u0026#34;,list); List\u0026lt;Blog\u0026gt; blogs = mapper.queryBlogByForEach(map); for (Blog blog : blogs) { System.out.println(blog); } session.close(); }   SQL片段\n有时候可能某个SQL语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段\n\u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n 最好基于单表来定义SQL片段，提高片段的可重用性 在SQL片段中不要包括where  小结：\n其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。\n缓存   概括\n什么是缓存[Cache]\n 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从硬盘上（关系型数据库/数据文件）查询，从缓存中查询，从而提高了查询效率，解决了高并发系统的性能问题。  为什么使用缓存\n 减少和数据库交互次数，减少系统开销  什么样的数据能使用缓存\n 经常查询并且不经常改变的数据    MyBatis缓存\n MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存  默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存      一级缓存\n一级缓存也叫本地缓存\n 与数据库同一次会话期间查询到的数据会妨碍本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库  代码示例\n  在MyBatis中开启日志，方便测试结果\n  编写接口方法\n//根据id查询用户 User queryUserById(@Param(\u0026#34;id\u0026#34;) int id);   接口对应的Mapper文件\n\u0026lt;select id=\u0026#34;queryUserById\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt;   测试\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); }   结果分析\n  一级缓存失效的四种情况\n一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；\n一级缓存失效情况：程序没有使用到当前的一级缓存，还需要再向数据库发起一次查询请求！\n  SqlSession不同\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close(); } 观察结果：发现请求了两条SQL语句！\n结论：每个SqlSession中的缓存相互独立\n  SqlSession相同，查询条件不同\n@Test public void queryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\u0026#34;user1:\u0026#34;+user1); User user2 = mapper.queryUserById(2); System.out.println(\u0026#34;user2:\u0026#34;+user2); System.out.println(user1==user2); session.close(); } 观察结果：发现发送了两条SQL语句！很正常的理解\n结论：当前缓存中，不存在这个数据\n  SqlSession相同，两次查询之间执行了增、删、改操作\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(\u0026#34;name\u0026#34;,\u0026#34;kuangshen\u0026#34;); map.put(\u0026#34;id\u0026#34;,4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); } 观察结果：查询在中间执行了增删改操作后，从新执行了（增删改回刷新缓存！）\n结论：因为增删改操作可能会对当前数据产生影响\n  SqlSession相同，手动清除了一级缓存\n@Test public void queryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user1 = mapper.queryUserById(1); System.out.println(\u0026#34;user1:\u0026#34;+user1); session.clearCache(); User user2 = mapper.queryUserById(1); System.out.println(\u0026#34;user2:\u0026#34;+user2); System.out.println(user1==user2); session.close(); } 一级缓存就是一个map\n    二级缓存\n  二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n  基于namespace级别的缓存；一个名称空间，对应一个二级缓存\n  工作机制\n 一个会话查询了一条数据，这个会话就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据就会被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会仿真自己对应的缓存（map）中    使用步骤\n  开启全局缓存\n\u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;   去每个mapper.xml中配置使用二级缓存，这个配置非常简单；\n\u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;!--等价于--\u0026gt; \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。--\u0026gt;   测试\n 所有的实体类需要先实现序列化接口！  @Test public void queryUserById(){ SqlSession session1 = MybatisUtils.getSession(); UserMapper mapper1 = session1.getMapper(UserMapper.class); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user1 = mapper1.queryUserById(1); System.out.println(\u0026#34;user1:\u0026#34;+user1); System.out.println(\u0026#34;从一级缓存读取数据\u0026#34;); User user2 = mapper1.queryUserById(1); System.out.println(\u0026#34;user2:\u0026#34;+user2); session1.close(); System.out.println(\u0026#34;====Session1关闭！====\u0026#34;); System.out.println(\u0026#34;从二级缓存读取数据\u0026#34;); User user3= mapper2.queryUserById(1); System.out.println(\u0026#34;user3:\u0026#34;+user3); System.out.println(user1==user2\u0026amp;\u0026amp;user2==user3); session2.close(); } 输出结果\n  结论：\n 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中    缓存原理图\n  ","date":"2021-10-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/mybatis%E4%BA%8C/","title":"MyBatis（二）"},{"content":"MyBatis(一) MyBatis概括   什么是MyBatis\n MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3    什么是持久化\n持久化就是将程序数据在持久状态和瞬时状态间转化的机制。\n 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。    为什么需要持久化服务呢？\n那是由于内存本身的缺陷引起的\n 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。    什么是持久层？\n持久层：完成持久化工作的代码块 . \u0026mdash;-\u0026gt; dao层 【DAO (Data Access Object) 数据访问对象】\n 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过**这里有一个字需要特别强调，也就是所谓的“层”。**对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】    为什么需要Mybatis\n  Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .\n  传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等\u0026hellip; , 通过框架可以减少重复代码,提高开发效率 .\n  MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) \u0026ndash;\u0026gt;对象关系映射\n  所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别\n  MyBatis的优点\n   简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。      第一个MyBatis程序   示例代码\n  搭建实验数据库\nCREATEDATABASE`mybatis`;USE`mybatis`;DROPTABLEIFEXISTS`user`;CREATETABLE`user`(`id`int(20)NOTNULL,`name`varchar(30)DEFAULTNULL,`pwd`varchar(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=utf8;insertinto`user`(`id`,`name`,`pwd`)values(1,\u0026#39;狂神\u0026#39;,\u0026#39;123456\u0026#39;),(2,\u0026#39;张三\u0026#39;,\u0026#39;abcdef\u0026#39;),(3,\u0026#39;李四\u0026#39;,\u0026#39;987654\u0026#39;);  导入MyBatis相关jar包\n\u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写MyBatis核心配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;777777\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/heng/dao/Mapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 注意\u0026lt;mapper resource=\u0026quot;com/heng/dao/Mapper.xml\u0026quot;/\u0026gt;的路径\n  编写MyBatis的工具类\npackage com.heng.utils; import org.apache.ibatis.session.Configuration; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; /** * @Author: minster * @Date: 2021/10/26 10:24 */ //SqlSessionFactory 工厂--生产-\u0026gt;产品 SqlSession，即该方法可以用来生成sqlSession public class MybatisUtils { public static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取sqlSessionFactory对象（建议使用类路径下的资源文件配置）  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了sqlSessionFactory,顾名思义，我们就可以从中获得sqlSession的实例了  //SqlSession完全包含了面向数据库执行SQL命令所需的所有方法  public static SqlSession getSession(){ return sqlSessionFactory.openSession(); } } 什么是SqlSession？\n  简单理解SqlSession，就是一次操作数据库的会话过程，通过它可以与数据库进行交\n  使用Mybatis执行数据库操作，首先要获取SqlSession，通过它进一步获取Mapper接口代理对象，最后通过代理对象发起数据库操作\n  通过构建DataSource、TransactionFactory、Environment、Configuration并将它们组装在一起获得SqlSessionFactory，此后就可以通过它获取SqlSession\n  从try-with-resource里的openSession方法，在这里可以看到获取SqlSession时Mybatis会创建事务工厂TransactionFactory、执行器Executor结合在启动Mybatis时创建的Configuration返回一个DefaultSqlSession\n  其中Mybatis利用执行器Executor执行数据库操作。\n  Mybatis获取SqlSession的过程结束，通过它为当前的数据库操作创建一个专属的执行器Executor和事务工厂TransactionFactory，令当前线程的数据库操作处于一个会话状态\n https://www.jianshu.com/p/48dfeb0b79b6\n     创建实体类\npublic class User { private int id; //id  private String name; //姓名  private String pwd; //密码  //构造,有参,无参  //set/get  //toString()  }   编写Mapper接口类\npackage com.heng.dao; import com.heng.pojo.User; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:33 */ public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); }   编写Mapper.xml配置文件\n namespace非常重要！！不能写错\n \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace绑定一个对应的Dao/Mapper接口 --\u0026gt; \u0026lt;!-- 配置文件和UserMapper接口绑定起来了 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   编写测试类\nimport com.heng.dao.UserMapper; import com.heng.pojo.User; import com.heng.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:34 */ public class MyTest { 方法1 @Test public void selectUser1(){ SqlSession session = MybatisUtils.getSession(); List\u0026lt;User\u0026gt; users = session.selectList(\u0026#34;com.heng.dao.UserMapper.selectUser\u0026#34;); for (User user : users) { System.out.println(user); } session.close(); } //方法2  @Test public void selectUser2(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } } }   编译，测试，出现Maven静态资源过滤问题，在pom.xml文件上添加下面配置\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;     MyBatis核心对象 MyBatis 有三个基本要素：\n 核心接口和类 MyBatis核心配置文件（mybatis-config.xml） SQL映射文件（mapper.xml）  下面首先介绍 MyBatis 的核心接口和类，如下所示。\n每个 MyBatis 应用程序都以一个 SqlSessionFactory 对象的实例为核心。\n首先获取SqlSessionBuilder对象，可以根据XML配置文件或者Configuration类的实例构建该对象\n然后获取SqlSessionFactory对象，该对象实例可以通过SqlSessionBuilder对象来获取\n有了SqlSessionFactory对象后，就可以进而获取SqlSession实例。SqlSession对象中完全包含数据库为背景的所有执行SQL操作的方法，用该实例可以直接执行已映射的SQL语句。\n  SqlSessionFactoryBuidler\nSqlSessionFactoryBuidler会根据配置信息或者代码生成SqlSessionFactory，并且提供了多个build()方法重载，如图\n通过源码分析，可以发现以上方法都是在调用同一签名方法，即\npublic SqlSessionFactory build(Reader reader, String environment, Properties properties) { //... } 由于参数environment和properties都可以为null，所以我们可以去除重复的方法，真正的重载其实只有以下三种：\n build(InputStream inputStream, String environment, Properties properties) build(Reader reader, String environment, Properties properties) build(Configuration config)  通过以上分析，我们可以发现配置信息可以以三种形式给SqlSessionFactoryBuilder的build()方法，分别是InputStream(字节流)、Reader(字符流)、Configuration(类)。\n由于字节流和字符流都属于读取配置文件的方式，所以就很容易想到构建一个SqlSessionFactory有两种方式：即读取XML配置文件和编写代码。常用的是采取XML配置文件的方式来构造SqlSessionFactory，这样一方面可以避免硬编码，另一方面方便日后配置人员修改，避免重复编译代码\n  SqlSessionFactoryBuilder的生命周期和作用域\nSqlSessionFactoryBuilder的最大特点是用过即丢。创建SqlSessionFactory对象之后，这个类就不存在了，因此SqlSessionFactoryBuilder的最佳作用范围就是存在于方法体内，也就是局部变量\n观察下面代码便可理解\nstatic { try { //使用Mybatis第一步：获取sqlSessionFactory对象（建议使用类路径下的资源文件配置）  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } }   SqlSessionFactory SqlSessionFactory 是工厂接口而不是现实类，他的任务就是创建 SqlSession。\n所有的MyBatis应用都以SqlSessionFactory实例为中心，SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder对象来获取。有了它之后，顾名思义，就可以通过SqlSession提供的openSession()方法来获取SqlSession实例，源码如下：\npackage org.apache.ibatis.session; import java.sql.Connection; public interface SqlSessionFactory { SqlSession openSession(); SqlSession openSession(boolean var1); SqlSession openSession(Connection var1); SqlSession openSession(TransactionIsolationLevel var1); SqlSession openSession(ExecutorType var1); SqlSession openSession(ExecutorType var1, boolean var2); SqlSession openSession(ExecutorType var1, TransactionIsolationLevel var2); SqlSession openSession(ExecutorType var1, Connection var2); Configuration getConfiguration(); }   SqlSessionFactory的生命周期和作用域\nSqlSessionFactory对象一旦创建，就会在整个应用程序过程中始终存在。没有理由去销毁或再创建它，并且在应用程序运行中也不建议多次创建SqlSessionFactory。因此SqlSessionFactory的最佳作用域是Application，即随着应用程序的生命周期一直存在。这种“存在于整个应用运行期间，并且只有一个对象实例”的模式就是所谓的单例模式（指在运行期间有且仅有一个实例）\n  SqlSession\nSqlSession是用于执行持久化操作的对象，类似于JDBC中的Connection。它提供了面向数据库执行SQL命令所需要的的所有方法，可以通过SqlSession实例直接运行已映射的SQL语句。\nSqlSession的用途主要有两种：\n 获取映射器。让映射器通过命名空间和方法名称找到对应的SQL，并发送给数据库，执行返回结果。 直接通过“命名空间(namespace)+SQL id”的方式执行SQL，不需要获取映射器。这是iBatis版本留下的方式。例如《第一个MyBatis程序》一节的实例就是用这种方法执行的SQL语句。    SqlSession的生命周期和作用域\nSqlSession对应一次数据库会话。由于数据库会话不是永久的，因此SqlSession的生命周期也不是永久的，每次访问数据库时都需要创建SqlSession对象。\n需要注意的是：每个线程都有自己的SqlSession实例，SqlSession实例是不能被共享的，也不是线程安全的。因此SqlSession的作用域范围是request作用域或方法体作用域内。\n  MyBatis详细的执行流程\nMyBatis Mapper(映射器) 映射器是MyBatis中最重要的文件，文件包含一组SQL语句（例如查询、添加、删除、修改），这些语句称为映射语句或映射SQL语句。\n映射器由Java接口和XML文件（或注解）共同组成，它的作用如下：\n 定义参数类型 配置缓存 提供SQL语句和动态SQL 定义查询结果和POJO的映射关系1  映射器有一下两种实现方式：\n 通过XML文件方式实现，比如我们在mybatis-config.xml文件中描述的XML文件，可以用来生成mapper。 通过注解的方式实现，使用Configuration对象注册mapper接口  如果SQL语句存在动态SQL或者比较复杂，使用注解写在Java文件里可读性差，且增加了维护成本。所以一般建议使用XML文件配置的方式，可以避免重复编写SQL语句。\n  XML实现映射器\nXML定义映射器分为两个部分：接口和XML。下面定义接口UserMapper\npackage com.heng.dao; import com.heng.pojo.User; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:33 */ public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); } UserMapper.xml代码如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace绑定一个对应的Dao/Mapper接口 --\u0026gt; \u0026lt;!-- 配置文件和UserMapper接口绑定起来了 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 下面对上述 XML 文件进行讲解。\n namespace 用来定义命名空间，该命名空间和定义接口的全限定名一致。 \u0026lt;select\u0026gt; 元素表明这是一条查询语句，属性 id 用来标识这条 SQL。resultType 表示返回的是一个 User类型的值。  在MyBatis配置文件中添加以下代码：\n\u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/heng/dao/userMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 该语句用来引入XML文件，MyBatis会读取userMapper.xml文件，生成映射器。\n  注解实现映射器\n使用注解的方式实现映射器，只需要在接口中使用Java注解，注入SQL即可。如下所示：\npackage com.heng.dao; import com.heng.pojo.User; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:33 */ public interface UserMapper { @Select(value = \u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; selectUser(); } 这里我们使用了@Select注解，并且注入了和XML中相同的SQL语句。\n 如果同时使用了注解和XML文件两种方式实现映射器，那么XML方式将覆盖掉注解方式。\n 虽然XML看起来比注解复杂很多，但是现实中我们遇到的SQL会比上述例子的SQL语句复杂很多。如果SQL语句中有多个表的关联、多个查询条件、级联、条件分支等，显然这条SQL就会复杂很多，所以并不建议使用注解的这种方式实现。\n此外，XML 可以相互引入，而注解是不可以的，所以在一些比较复杂的场景下，使用 XML 方式会更加灵活和方便。因此大部分的企业都以 XML 为主，本教程也会保持一致，以 XML 方式来创建映射器。当然在一些简单的表和应用中使用注解方式也会比较简单。\n  MyBatis映射器的主要元素\n  mapper：映射文件的根节点，只有namescape一个属性。\nnamescape作用如下：\n 用于区分不同的 mapper，全局唯一 绑定DAO接口，即面向接口编程。当 namescape 绑定某一接口后，可以不用写该接口的实现类，MyBatis 会通过接口的完整限定名查找到对应的 mapper 配置来执行 SQL 语句。因此 namescape 的命名必须要跟接口同名。    select：查询语句，最常用、最复杂的元素之一。可以自定义参数，返回结果集等\n  insert：插入语句。执行后返回一个整数，代表插入的条数\n  update：更新语句。执行后返回一个整数，代表更新的条数\n  delete：删除语句。执行后返回一个整数，代表删除的条数\n  parameterMap：定义参数映射关系，即被删除的元素，不建议使用\n  sql：允许定义一部分的 SQL，然后在各个地方引用它\n  resultMap：用来描述数据库结果集与对象的对应关系，它是最复杂、最强大的元素\n  cache：配置给定命名空间的缓存\n  cache-ref：其他命名空间缓存配置的引用\n    MyBatis实现CURD   查询语句\n  elect标签是mybatis中最常用的标签之一\n  select语句有很多属性可以详细配置每一条SQL语句\n   SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id：对应的namespace的方法名 resultType：Sql语句执行的返回值 parameterType：参数类型！    需求：根据id查询用户\n  在userMapper中添加对应方法\npublic interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); User selectUserById(int id); }   在UserMapper.xml中添加Select语句\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt;   测试类测试\n@Test public void selectUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } }   需求：根据密码和名字查询用户\n方法一：直接在方法中传递参数\n  在接口方法的参数前加@Param属性\n  Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\nUserMapper接口增加方法\nUser selectUserByNP1(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); 在Mapper.xml配置文件增加查询语句\n\u0026lt;select id=\u0026#34;selectUserByNP1\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; 编写测试类\npublic void selectUserByNP01(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User jack = mapper.selectUserByNP1(\u0026#34;jack\u0026#34;, \u0026#34;123456\u0026#34;); System.out.println(jack); session.close(); } 测试，程序成功输出\n  方法二：使用万能的Map集合\n  实体类或数据库中的表字段或参数过多，应当考虑Map！（企业常用）\n  不需要知道用户表里有什么也能增删改查\n  Map传递参数，直接在SQL中取出key即可！\n在UserMapper接口中增加方法\nUser selectUserByNP2(Map\u0026lt;String, Object\u0026gt; map); 在Mapper.xml编写SQL语句时，需要传递参数类型，类型为map\n\u0026lt;select id=\u0026#34;selectUserByNP2\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; 编写测试代码时，只需要填写key为sql中取的值即可（即key对应sql语句的字段）\n@Test public void selectUserByNP02(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); map.put(\u0026#34;username\u0026#34;,\u0026#34;张三\u0026#34;); map.put(\u0026#34;pwd\u0026#34;,\u0026#34;abcdef\u0026#34;); User user = mapper.selectUserByNP2(map); System.out.println(user); session.close(); } 查询结果\n    增、删、改语句\n insert标签：进行插入操作 delete标签：进行删除操作 update标签：进行更新操作  代码实现增、删、改\n  编写接口方法\npublic interface UserMapper { int addUser(User user); int updateUser(User user); int deleteUser(int Id); }   在Mapper.xml编写SQL语句\n\u0026lt;!--增加一个用户--\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) value (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--修改用户信息--\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; update user set name = #{name},pwd = #{pwd} where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;!--删除一个用户--\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; delete from user where id = #{id} \u0026lt;/delete\u0026gt;   编写测试类\n增加一个用户\n@Test public void addUser(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User tom = new User(4, \u0026#34;tom\u0026#34;, \u0026#34;777777\u0026#34;); int i = mapper.addUser(tom); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } session.commit(); session.close(); } 修改一个用户的信息\n@Test public void updateUser(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User mary = new User(4, \u0026#34;mary\u0026#34;, \u0026#34;777776\u0026#34;); int i = mapper.updateUser(mary); User user = mapper.selectUserById(4); System.out.println(user); session.commit(); session.close(); } 删除一个用户\n@Test public void deleteUser(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(4); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } session.commit(); session.close(); }   切记：进行增删改操作时，一定要提交事务session.commit();\n如果把工具类MybatisUtils的openSession()的参数设置为true，程序会自动提交事务！\npublic static SqlSession getSession(){ return sqlSessionFactory.openSession(true); }   小结：\n 所有增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map集合传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType参数都写上！    模糊查询like语句该怎么写？\n  第一种：在Java代码中添加SQL通配符。\n//UserMapper接口增加方法 List\u0026lt;User\u0026gt; selectLikeByName(@Param(\u0026#34;username\u0026#34;) String username); //测试方法 @Test public void selectLikeByName(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); //增加SQL通配符  List\u0026lt;User\u0026gt; user = mapper.selectLikeByName(\u0026#34;%a%\u0026#34;); System.out.println(user); session.close(); } xml文件\n\u0026lt;select id=\u0026#34;selectLikeByName\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name like #{username} \u0026lt;/select\u0026gt;   第二种：在sql语句中拼接通配符（不建议使用，会引起SQL注入问题！）\n\u0026lt;select id=\u0026#34;selectLikeByName\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name like \u0026#34;%\u0026#34;#{username}\u0026#34;%\u0026#34; \u0026lt;/select\u0026gt;     MyBatis核心配置文件解析   mybatis-config.xml 系统核心配置文件\n  MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n  能配置的内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt;\u0026lt;!-- 配置 --\u0026gt; \u0026lt;properties /\u0026gt;\u0026lt;!-- 属性 --\u0026gt; \u0026lt;settings /\u0026gt;\u0026lt;!-- 设置 --\u0026gt; \u0026lt;typeAliases /\u0026gt;\u0026lt;!-- 类型命名 --\u0026gt; \u0026lt;typeHandlers /\u0026gt;\u0026lt;!-- 类型处理器 --\u0026gt; \u0026lt;objectFactory /\u0026gt;\u0026lt;!-- 对象工厂 --\u0026gt; \u0026lt;plugins /\u0026gt;\u0026lt;!-- 插件 --\u0026gt; \u0026lt;environments\u0026gt;\u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment\u0026gt;\u0026lt;!-- 环境变量 --\u0026gt; \u0026lt;transactionManager /\u0026gt;\u0026lt;!-- 事务管理器 --\u0026gt; \u0026lt;dataSource /\u0026gt;\u0026lt;!-- 数据源 --\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;databaseIdProvider /\u0026gt;\u0026lt;!-- 数据库厂商标识 --\u0026gt; \u0026lt;mappers /\u0026gt;\u0026lt;!-- 映射器 --\u0026gt; \u0026lt;/configuration\u0026gt; ​\t我们可以阅读 mybatis-config.xml 上面的dtd的头文件！\n  environments标签\n\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;...\u0026#34; value=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; 在 environments 标签中，可以配置 MyBatis 的多套运行环境，将 SQL 映射到多个不同的数据库上。\nenvironment 是 environments 的子标签，用来配置 MyBatis 的一套运行环境，需指定运行环境 ID、事务管理、数据源配置等相关信息。\n我们可以通过配置多个 environment 标签来连接多个数据库，需要注意的是必须指定其中一个为默认运行环境（通过default指定）。\nenvironment 标签提供了两个子标签，即 transactionManager 和 dataSource。\n  transactionManager标签\nMyBatis 支持两个事务管理器，即 JDBC 和 MANAGED。\n如果使用 JDBC 类型的事务管理器，则应用程序服务器负责事务管理操作，例如提交、回滚等。如果使用 MANAGED 类型的事务管理器，则应用程序服务器负责管理连接生命周期。\n  dataSource标签\n用于配置数据库的连接属性，例如要连接的数据库的驱动程序名称、URL、用户名和密码等。\ndataSource 中的 type 属性用于指定数据源类型，有以下 3 种类型。\n\u0026lt;dataSource type = \u0026#34;[UNPOOLED|POOLED|JNDI]\u0026#34;\u0026gt;\u0026lt;/dataSource\u0026gt;   UNPOOLED\nUNPOOLED 没有数据库连接池，效率低下。MyBatis 需要打开和关闭每个数据库操作的连接，它有点慢，通常应用于简单的应用程序。\n  POOLED\n对于 POOLED 数据源类型，MyBatis 将维护一个数据库连接池。并且对于每个数据库的操作，MyBatis 都会使用连接池中的连接，并在操作完成后将它们返回到池中。减少了创建新连接所需的初始连接和身份验证时间。\n  JNDI\n对于 JNDI 的数据源类型，MyBatis 将从 JNDI 数据源中获取连接。\n  dataSource的示例代码如下：\n\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!-- MySQL数据库驱动 --\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34; /\u0026gt; \u0026lt;!-- 连接数据库的URL --\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test?characterEncoding=utf8\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;/dataSource\u0026gt;     Mappers标签\nmappers 标签用于指定 MyBatis SQL 映射文件的路径。\nmapper 是 mappers 的子标签，mapper 中的 resource 属性用于指定 SQL 映射文件的路径（类资源路径）\n例如，SQL 映射文件的名称是 Student.xml，它位于名为 net.biancheng.mapper 的包中，那么您可以这样配置：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource = \u0026#34;net/biancheng/mapper/Student.xml\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用完全限定资源定位符（URL） --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper url=\u0026#34;file:///net/biancheng/mapper/Student.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;net.biancheng.mapper.Student\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;net.biancheng.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   Properties标签\nroperties 标签可以通过 resource 属性指定外部 properties 文件（database.properties），也可以通过 properties 子元素配置。\n现在，我们优化一下我们的配置文件\n  在资源目录下新建一个db.properties文件\ndriver=com.mysql.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;userUnicode=true\u0026amp;characterEncoding=utf8\rusername=root\rpassword=777777\r  将文件导入到properties标签下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/heng/dao/Mapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;     typeAliases标签\n为了不在任何地方都指定类的全限定名，我们可以使用 typeAliases 标签定义一个别名。\n例如，在 com.heng.pojo包中有一个 User类，则该类的全限定名称为 com.heng.pojo.User。使用 typeAliases 标签定义别名，这样就不用每次都书写类的全限定名称了，代码如下。\n\u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias type=\u0026#34;com.heng.pojo.User\u0026#34; alias=\u0026#34;user\u0026#34;\u0026gt;\u0026lt;/typeAlias\u0026gt; \u0026lt;/typeAliases 当这样配置时，User可以用在任何使用com.heng.pojo.User的地方。\n也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如\n\u0026lt;typeAliases\u0026gt; \u0026lt;package name =\u0026#34;com.heng.pojo\u0026#34;\u0026gt; \u0026lt;/typeAliases\u0026gt; 每一个在包 com.heng.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。\\例如 Student 别名为 student，User 别名为 user。\n若有注解，则别名为其注解值。见下面的例子：\n//别名为user @Alias(\u0026#34;user\u0026#34;) public class User { ... }   settings标签\nsettings 标签用于配置 MyBatis 的运行时行为，它能深刻的影响 MyBatis 的底层运行，一般不需要大量配置，大部分情况下使用其默认值即可。\nsettings 的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了。settings 配置项说明如下表所示（表中红色字体的配置项为常用配置项）。\n   配置项 作用 配置选项 默认值     cacheEnabled 该配置影响所有映射器中配置缓存的全局开关 true|false true   lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态 true|false false   aggressiveLazyLoading 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载 true|false 版本3.4.1 （不包含） 之前默认值为 true，之后为 false   multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要兼容驱动） true|false true   useColumnLabel 使用列标签代替列名。不同的驱动会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果 true|false true   useGeneratedKeys 允许JDBC 支持自动生成主键，需要驱动兼容。如果设置为 true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby） true|false false   autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射。 PARTIAL 表示只会自动映射，没有定义嵌套结果集和映射结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套） NONE、PARTIAL、FULL PARTIAL   autoMappingUnkno wnColumnBehavior 指定自动映射当中未知列（或未知属性类型）时的行为。 默认是不处理，只有当日志级别达到 WARN 级别或者以下，才会显示相关日志，如果处理失败会抛出 SqlSessionException 异常 NONE、WARNING、FAILING NONE   defaultExecutorType 配置默认的执行器。SIMPLE 是普通的执行器；REUSE 会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新 SIMPLE、REUSE、BATCH SIMPLE   defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 任何正整数 Not Set (null)   defaultFetchSize 设置数据库驱动程序默认返回的条数限制，此参数可以重新设置 任何正整数 Not Set (null)   safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许，设置 false true|false false   safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许，设置false true|false true   mapUnderscoreToCamelCase 是否开启自动驼峰命名规则映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 true|false false   localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速联复嵌套査询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlScssion 的不同调用将不会共享数据 SESSION|STATEMENT SESSION   jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER NULL、VARCHAR、OTHER OTHER   lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载 — equals、clone、hashCode、toString   defaultScriptingLanguage 指定动态 SQL 生成的默认语言 — org.apache.ibatis .script.ing.xmltags .XMLDynamicLanguageDriver   callSettersOnNulls 指定当结果集中值为 null 时，是否调用映射对象的 setter（map 对象时为 put）方法，这对于 Map.kcySet() 依赖或 null 值初始化时是有用的。注意，基本类型（int、boolean 等）不能设置成 null true|false false   logPrefix 指定 MyBatis 增加到日志名称的前缀 任何字符串 Not set   loglmpl 指定 MyBatis 所用日志的具体实现，未指定时将自动査找 SLF4J|LOG4J|LOG4J2|JDK_LOGGING |COMMONS_LOGGING |ST DOUT_LOGGING|NO_LOGGING Not set   proxyFactory 指定 MyBatis 创建具有延迟加栽能力的对象所用到的代理工具 CGLIB|JAVASSIST JAVASSIST （MyBatis 版本为 3.3 及以上的）   vfsImpl 指定 VFS 的实现类 提供 VFS 类的全限定名，如果存在多个，可以使用逗号分隔 Not set   useActualParamName 允许用方法参数中声明的实际名称引用参数。要使用此功能，项目必须被编译为 Java 8 参数的选择。（从版本 3.4.1 开始可以使用） true|false true    下面给出一个全量的配置样例，如下所示。\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;multipleResultSetsEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;useColumnLabel\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;useGeneratedKeys\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;autoMappingBehavior\u0026#34; value=\u0026#34;PARTIAL\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;autoMappingUnknownColumnBehavior\u0026#34; value=\u0026#34;WARNING\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultExecutorType\u0026#34; value=\u0026#34;SIMPLE\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultStatementTimeout\u0026#34; value=\u0026#34;25\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultFetchSize\u0026#34; value=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;safeRowBoundsEnabled\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;localCacheScope\u0026#34; value=\u0026#34;SESSION\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;jdbcTypeForNull\u0026#34; value=\u0026#34;OTHER\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadTriggerMethods\u0026#34; value=\u0026#34;equals,clone,hashCode,toString\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   类型处理器\n 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】    对象工厂\n MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】    ","date":"2021-10-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/mybatis%E4%B8%80/","title":"MyBatis（一）"},{"content":"反射   反射机制 class类 类加载 反射获取类的结构信息 通过反射创建对象 练习   反射机制   引出反射\n  根据配置文件re.properties指定信息，创建Cat对象并调用方法hi\nproperties配置文件如下\nclassPath=com.reflection_.Cat\rmethod=hi\rCat类\npackage com.reflection_; public class Cat { private String name = \u0026#34;jack\u0026#34;; public void hi(){ System.out.println(\u0026#34;hi \u0026#34;+name); } } 实现类ReflectionQuestion\npackage com.reflection_.question; import com.reflection_.Cat; public class ReflectionQuestion { public static void main(String[] args) { //1.使用传统方法实现，通过new一个对象，调用方法来实现  Cat cat = new Cat(); cat.hi(); } } 我们使用传统的方式，能实现上述需求，但如果我们Cat类需要增加功能或者换一种实现时，我们就需要去修改源码了！\n所以我们可以尝试使用反射来实现上述需求\npackage com.reflection_.question; import com.reflection_.Cat; import java.io.FileInputStream; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; @SuppressWarnings({\u0026#34;all\u0026#34;}) public class ReflectionQuestion { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.使用properties类，读写配置文件  Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(\u0026#34;classfullpath = \u0026#34; + classfullpath); System.out.println(\u0026#34;methodName = \u0026#34; + methodName); //2.创建对象，发现new的是一个String 错误！！  // new classfullpath();  //3.此时就需要使用反射机制来解决了  //3.1 加载类，返回class类型的对象cls  Class cls = Class.forName(classfullpath); //3.2 通过cls得到你加载的类 com.reflection_.Cat 的对象实例  Object o = cls.newInstance(); System.out.println(\u0026#34;o的运行类型 = \u0026#34; + o.getClass());//运行类型  //3.3 通过cls得到你加载的类 com.reflection_.Cat 的 methodName 的方法对象  // 在反射中，可以把方法视为对象（万物皆对象！）  Method method1 = cls.getMethod(methodName); //3.4 通过method1 调用方法：即通过方法对象调用方法！  method1.invoke(o); } } 我们可以发现，使用传统方法时：对象.方法()，反射机制：方法.invoke(对象)\n 这样的需求在学习框架是特别多，即通过外部文件配置，在不修改源码的情况下，来控制程序，也符合设计模式的OCP原则（开闭原则：不修改源码，扩容功能）。\n     反射机制\n 反射机制允许程序在执行期借助于Reflection API取得任何类的内部消息（比如成员变量，构造器，成员方法等等），并且能操作对象的属性及方法。反射在设计模式和框架底层都会用到 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射  反射机制原理图\n  Java反射机制可以完成\n 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时得到任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 生产动态代理    反射相关的主要类：\n java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象 java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法 java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量 java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示某个类的构造器  代码演示:\npackage com.reflection_; import java.io.FileInputStream; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; /** * @author minster */ public class Reflection01 { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //1.使用properties类，读写配置文件  Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(\u0026#34;classfullpath = \u0026#34; + classfullpath); System.out.println(\u0026#34;methodName = \u0026#34; + methodName); //3.此时就需要使用反射机制来解决了  //3.1 加载类，返回class类型的对象cls  Class cls = Class.forName(classfullpath); //3.2 通过cls得到你加载的类 com.reflection_.Cat 的对象实例  Object o = cls.newInstance(); //运行类型  System.out.println(\u0026#34;o的运行类型 = \u0026#34; + o.getClass()); //3.3 通过cls得到你加载的类 com.reflection_.Cat 的 methodName 的方法对象  // 在反射中，可以把方法视为对象（万物皆对象！）  Method method1 = cls.getMethod(methodName); //3.4 通过method1 调用方法：即通过方法对象调用方法！  method1.invoke(o); //获取Cat类中的某个字段（成员变量），getField不能获取私有属性  Field age = cls.getField(\u0026#34;age\u0026#34;); System.out.println(age); //()中能指定构造器参数类型，下面返回无参构造器  Constructor constructor01 = cls.getConstructor(); System.out.println(constructor01); //这里传入的String.class 就是String类的Class对象  Constructor constructor02 = cls.getConstructor(String.class); System.out.println(constructor02); } }     反射的优点和缺点\n 优点：可以动态的创建和使用对象（也是框架的底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑 缺点：使用反射基本是解释执行，对执行速度有影响  package com.reflection_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author minster */ public class Reflection02 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { m1(); } public static void m1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.reflection_.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); for (int i = 0; i \u0026lt; 900000000; i++) { hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;耗时：\u0026#34; + (end-start)); } }   反射调用优化-关闭访问检查\n Method和Field、Constructor对象都有setAccessible()方法 setAccessible作用是启动和禁用访问安全检查的开关 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查。  优化代码\npackage com.reflection_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author minster */ public class Reflection02 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { m1(); } public static void m1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.reflection_.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); //关闭反射的访问检测  hi.setAccessible(true); for (int i = 0; i \u0026lt; 900000000; i++) { hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;耗时：\u0026#34; + (end-start)); } }   Class类   基本介绍：\n  Class类也是类，因此也继承Object类\n  Class类对象不是new出来的，而是系统创建的。\n//追源码可以发现是通过ClassLoader类来加载Cat类的Class对象 public Class\u0026lt;?\u0026gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); }   对于某个类的Class类对象，在内存中只有一份，因此类只加载一次\n  每个类的实例都会记得自己是由哪个Class实例所生成\n  通过Class可以完整地得到一个类的完整结构，通过一系列API\npackage com.reflection_.class_; import com.reflection_.Car; import java.lang.reflect.Field; /** * @Author: minster * @Date: 2021/9/22 8:41 */ public class Class02 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { String classPath = \u0026#34;com.reflection_.Car\u0026#34;; Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); //显示cls对象，是哪个类的Class对象 com.reflection_.cat  System.out.println(cls); //输出cls的运行类型 java.lang.Class  System.out.println(cls.getClass()); //创建Class对象的实例,即通过反射获取对象  Car car = (Car)cls.newInstance(); System.out.println(car); //通过反射获取对象的属性  Field brand = cls.getField(\u0026#34;brand\u0026#34;); System.out.println(brand.get(car)); //通过反射获取的字段进行赋值  brand.set(car,\u0026#34;奔驰\u0026#34;); System.out.println(brand.get(car)); //获取所有属性  Field[] fields = cls.getFields(); for (Field f : fields) { System.out.println(f.get(car)); } } }   Class对象时存放在堆的\n  类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）\n    获取类对象的6种方式\n  已知一个类的全类名，且在该类的路径下，可以通过Class类的对象的静态方法forName()获取，可能抛出ClassNotFoundException。多用于读取配置文件，读取类全路径，加载类阶段\n  若已知具体的类，通过类的class来获取，该方式最为安全可靠，程序性能最高。多用于参数传递，比如通过反射得到对应构造器对象。\n  若已知某个类的实例，调用该实例的getClass()方法获取Class对象。用于通过创建好的对象，获取Class对象。\n  使用类的加载器来获取类的对象\n  基本数据类型可以通过class cls = int.class获取Class对象\n  基本数据类型对应的包装类，可以通过type获取Class对象\n  代码演示：\npackage com.reflection_.class_; import com.reflection_.Car; /** * @Author: minster * @Date: 2021/9/22 9:30 */ public class GetClass { public static void main(String[] args) throws ClassNotFoundException { String classPath = \u0026#34;com.reflection_.Car\u0026#34;; //1. 通过Class类的对象的静态方法forName()获取  Class\u0026lt;?\u0026gt; cls1 = Class.forName(classPath); System.out.println(cls1.getName()); //2. 通过类的class来获取  Class cls2 = Car.class; System.out.println(cls2.getName()); //3. 调用该实例的getClass()方法获取Class对象  Car car = new Car(); Class\u0026lt;? extends Car\u0026gt; cls3 = car.getClass(); System.out.println(cls3.getName()); //4. 使用类的加载器来获取类的对象  //先得到类的加载器  ClassLoader classLoader = car.getClass().getClassLoader(); //再通过类的加载器得到Class对象  Class\u0026lt;?\u0026gt; cls4 = classLoader.loadClass(classPath); System.out.println(cls4); //通过hashCode可以看出来他们都是同一个类的对象  System.out.println(\u0026#34;cls1HashCode = \u0026#34;+cls1.hashCode()); System.out.println(\u0026#34;cls2HashCode = \u0026#34;+cls2.hashCode()); System.out.println(\u0026#34;cls3HashCode = \u0026#34;+cls3.hashCode()); System.out.println(\u0026#34;cls4HashCode = \u0026#34;+cls4.hashCode()); //5. 通过`class cls = int.class`获取Class对象  Class\u0026lt;Integer\u0026gt; integerClass = int.class; System.out.println(integerClass); //6. 通过type获取Class对象  Class\u0026lt;Integer\u0026gt; type = Integer.TYPE; System.out.println(type); System.out.println(\u0026#34;intHashCode = \u0026#34;+integerClass.hashCode()); System.out.println(\u0026#34;IntegerHashCode = \u0026#34;+type.hashCode()); } } 运行结果：\n  在Java中出了基本数据类型有Class对象之外，下面的类型也有Class对象\n  类加载   基本说明\n反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。\n 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性  代码演示\npackage com.reflection_.class_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Scanner; /** * @Author: minster * @Date: 2021/9/22 10:04 */ public class Class03 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;input key\u0026#34;); String key = scanner.nextLine(); switch (key){ case\u0026#34;1\u0026#34;: Dog dog = new Dog(); dog.cry(); System.out.println(\u0026#34;1\u0026#34;); break; case \u0026#34;2\u0026#34; : System.out.println(\u0026#34;ok\u0026#34;); break; case \u0026#34;3\u0026#34; : System.out.println(\u0026#34;ok\u0026#34;); default: System.out.println(\u0026#34;not do\u0026#34;); } scanner.close(); } } 使用cmd进行编译，可以发现即使我们还没传key进去，程序也会报错，因为Dog类是静态加载，因此必须编写Dog类才可以！\n此时我们把case 1处的代码注释，使用反射加载类Person\npackage com.reflection_.class_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Scanner; /** * @Author: minster * @Date: 2021/9/22 10:04 */ public class Class03 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;input key\u0026#34;); String key = scanner.nextLine(); switch (key){ case\u0026#34;1\u0026#34;: /* Dog dog = new Dog; dog.cry();*/ System.out.println(\u0026#34;1\u0026#34;); break; case \u0026#34;2\u0026#34; : Class\u0026lt;?\u0026gt; person = Class.forName(\u0026#34;Person\u0026#34;); Object o = person.newInstance(); Method m = person.getMethod(\u0026#34;hi\u0026#34;); m.invoke(o); break; case \u0026#34;3\u0026#34; : System.out.println(\u0026#34;ok\u0026#34;); default: System.out.println(\u0026#34;not do\u0026#34;); } scanner.close(); } } 输出1，可以发现程序能正常执行\n输入2，程序抛出异常！这就是所谓的动态加载，当运行时执行到该类的代码时才会使程序异常！\n  类加载时机\n 当创建对象时（new）——静态加载 当子类被加载时——静态加载 调用类中的静态成员时——静态加载 通过反射——动态加载    类加载过程图\n在类加载的三个阶段中，各个阶段会分别完成以下任务\n  加载（Loading）阶段：JVM在该阶段主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）转换为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象。\n  连接（Linking）阶段：该阶段包含验证、准备、解析三个阶段\n  验证阶段：\n 确保被加载的类的正确性，确保你加载的字节码文件没有被恶意地修改过，而且一切都是符合JVM对于字节码格式的要求 在字节码语言层面，Java代码无法做到的事情都是可以实现的，至少语义上可以表达出来的，虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作 包括：文件格式验证、元数据验证、字节码验证和符号引用验证    准备阶段：为类变量赋初值，不给实例变量赋值，这儿的初值指的是零值。例如public static int value = 123;\nvalue在准备阶段过后的初始值为0而不是123；\n//在准备阶段，属性会如何处理？ //1. n1是实例属性，不是静态变量，因此在准备阶段，是不会分配内存的！ //2. n2是静态变量，分配内存；n2是默认初始化0，而不是20 //3. n3是static final常量，它和静态变量不一样，因为一旦赋值就不会改变，所以n3 = 30； public int n1 = 10; public static int n2 = 20; public static final int n3 = 30;   解析阶段：将常量池的符号引用转化为直接引用，主要针对接口或类，字段。接口方法，类方法的符号引用。\n    初始化（initialization）阶段：为类的静态变量赋予正确的初始值，即程序员显式地赋予的初始值\n  到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行\u0026lt;clinit\u0026gt;()方法的过程。\n  \u0026lt;clinit\u0026gt;()方法由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。\n  JVM会保证一个类的\u0026lt;clinit\u0026gt;()方法在多线程环境中被正确加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\u0026lt;clinit\u0026gt;()方法，其他线程都需要阻塞等待，知道活动现场执行\u0026lt;clinit\u0026gt;()方法完毕！\nprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //省略  } } 我们在创建一个对象时，追源码进去，可以看到在加载类时会有一个方法使用了synchronized锁。正因如此，才能保证某个类在内存中只有一份Class对象。\n  如果直接使用类的静态属性，也会导致类的加载\n 类加载阶段的深入理解见JVM类加载的深入理解\n     通过反射获取类的结构信息   基于java.lang.Class的API\n getName()：获取全类名。 getSimpleName()：获取简单类名 getFields()：获取所有public修饰的属性，包含本类以及父类（包含Object）的 getDeclaredField()：获取本类中所有属性 getMethods()：获取所有public修饰的方法，包含本类以及父类的 getDeclaredMethods()：获取本类中所有方法 getConstructors()：获取本类所有public修饰的构造器。 getDeclaredConstructors()：获取本类中所有构造器 getPackage()：以Package形式返回包信息 getSuperClass()：以Class形式返回父类信息 getInterfaces()：以Class[]形式返回接口信息 getAnnotations()：以Annotation[]形式返回注解信息    基于java.lang.reflect.Field类的API\n  getModifiers()：以int形式返回修饰符**[说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16]**\n//如果有一个字段是有多个修饰符，则两个int相加 public static String name = \u0026#34;minster\u0026#34;; System.out.println(name,getModifiers()); 上面语句会输出9\n  getType()：以Class形式返回类型\n  getName()：返回属性名\n    基于java.lang.reflect.Method类的API\n getModifiers()：以int形式返回修饰符**[说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16]** getReturnType()：以Class形式获取返回类型 getName()：返回方法名 getParameterTypes()：以Class[]返回参数类型数组    通过反射创建对象   调用类中的public修饰的无参构造器\n  调用类中的指定构造器\n  Class相关方法\n  newInstance()：调用类中的无参构造器，获取对应类的对象\n  getConstructor(Class\u0026hellip;clazz)：根据参数列表，获取对应的public构造器对象\n  getDecalaredConstructor(Class\u0026hellip;clazz)：根据参数列表，获取对应的所有构造器\n    Constructor类相关方法\n setAccessible()：暴破 newInstance(Object\u0026hellip;obj)：调用构造器      案例演示\n 通过反射创建某类的对象，要求该类中必须有public的无参构造 通过调用某个特定构造器的方式，实现创建某个类的对象  创建User类\npackage com.reflection_; /** * @Author: minster * @Date: 2021/9/22 19:36 */ public class User { public String name = \u0026#34;minster\u0026#34;; public int age = 21; public User(){ } private User(String name){ this.name = name; } public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 创建实现类ReflectionInstance01\npackage com.reflection_; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /** * @Author: minster * @Date: 2021/9/22 19:36 */ public class ReflectionInstance01 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { String classPath = \u0026#34;com.reflection_.User\u0026#34;; Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); //1. 通过public的无参构造器创建实例  Object user1 = cls.newInstance(); System.out.println(user1); //2. 通过public的有参构造器创建实例  Constructor\u0026lt;?\u0026gt; constructor = cls.getConstructor(String.class, int.class); Object ming = constructor.newInstance(\u0026#34;ming\u0026#34;, 22); System.out.println(ming); //3. 通过非公有的有参构造器创建实例  Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); Object minster = declaredConstructor.newInstance(\u0026#34;minster\u0026#34;); System.out.println(minster); } } 运行上述代码，我们发现方法1,2都能正常运行，但是方法3却报异常。\n因为我们通过getDeclaredConstructor(String.class);获取到的构造器是private的，所以我们在24行访问时会报出IllegalAccessException异常！\n此时我们可以使用暴破法来解决这个问题\n//3. 通过非公有的有参构造器创建实例 //因为要获取的构造方法为私有的，所以获取到的declaredConstructor也是私有的！ Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); //暴破（暴力破解，可以使用反射访问private构造器/方法/属性）！ declaredConstructor.setAccessible(true); Object minster = declaredConstructor.newInstance(\u0026#34;minster\u0026#34;); System.out.println(minster); 使用java.lang.reflection.Constructor的setAccessible方法可以解决这个问题！\n 任何封装的属性在反射面前都是纸老虎！使用暴破可以使反射访问到private构造器/方法/属性\n   注意：当使用反射访问静态成员或静态方法时，访问的参数可以写成null。（因为静态成员或静态方法属于整个类的属性！）\nStudent类\nclass Student{ private static String name; public static String m1(String name){ System.out.println(\u0026#34;hi\u0026#34;); } } Reflection04类\npackage com.reflection_; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @Author: minster * @Date: 2021/9/23 9:44 */ public class Reflection04 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException { String classPath = \u0026#34;com.reflection_.Student\u0026#34;; Class\u0026lt;?\u0026gt; studentClass = Class.forName(classPath); Object o = studentClass.newInstance(); Field name = studentClass.getDeclaredField(\u0026#34;name\u0026#34;); //name为私有字段，需要暴破！  name.setAccessible(true); //给name字段赋值，指定对象为null，因为name字段为static字段  name.set(null,\u0026#34;minster\u0026#34;); //获取name字段的值  System.out.println(name.get(null)); Method declaredMethod = studentClass.getDeclaredMethod(\u0026#34;m1\u0026#34;); //因为m1方法属于静态方法，所以可以使用null对象来调用它  Object o1 = declaredMethod.invoke(null); System.out.println(o1); } } 在反射中，如果方法有返回值，统一返回Object！\n  练习   利用反射创建文件\npackage com.reflection_.homework; import java.io.File; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @Author: minster * @Date: 2021/9/23 10:33 */ public class HomeWork02 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u0026lt;?\u0026gt; fileClass = Class.forName(\u0026#34;java.io.File\u0026#34;); Constructor\u0026lt;?\u0026gt;[] declaredConstructor = fileClass.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructor) { System.out.println(\u0026#34;File的构造器有：\u0026#34;+constructor); } Constructor\u0026lt;?\u0026gt; declaredConstructor1 = fileClass.getDeclaredConstructor(String.class); Method createNewFile = fileClass.getMethod(\u0026#34;createNewFile\u0026#34;); String allPath = \u0026#34;e:\\\\mynew.txt\u0026#34;; Object file = declaredConstructor1.newInstance(allPath); createNewFile.invoke(file); } }   ","date":"2021-09-05T16:22:25+08:00","permalink":"https://minster77.github.io/p/reflection/","title":"Reflection"},{"content":"JDBC核心技术\n讲师：宋红康\n微博：尚硅谷-宋红康\n 第1章：JDBC概述 1.1 数据的持久化   持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n  持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n  1.2 Java中的数据存储技术   在Java中，数据库存取技术可分为如下几类：\n  JDBC直接访问数据库\n  JDO (Java Data Object )技术\n  第三方O/R工具，如Hibernate, Mybatis 等\n    JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。\n  1.3 JDBC介绍  JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的：    有了JDBC，Java程序访问数据库时是这样的：    总结如下：  1.4 JDBC体系结构  JDBC接口（API）包括两个层次：  面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。     JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。\n不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。\t————面向接口编程\n 1.5 JDBC程序编写步骤  补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。\n 第2章：获取数据库连接 2.1 要素一：Driver接口实现类 2.1.1 Driver接口介绍   java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。\n  在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。\n Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver      在Maven项目中的pom.xml文件上添加mysql包的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.26\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     右击项目-\u0026gt;选中Maven-\u0026gt;Download Sources 然后再点击Reload project即可\n  2.1.2 加载与注册JDBC驱动   加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名\n Class.forName(“com.mysql.jdbc.Driver”);    注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序\n  使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动\n  通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：\n    2.2 要素二：URL   JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。\n  JDBC URL的标准由三部分组成，各部分间用冒号分隔。\n jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名    举例：\n  几种常用数据库的 JDBC URL\n  MySQL的连接URL编写方式：\n jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值\u0026amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true\u0026amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root\u0026amp;password=123456    Oracle 9i的连接URL编写方式：\n jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu    SQLServer的连接URL编写方式：\n  jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称\n  jdbc:sqlserver://localhost:1433:DatabaseName=atguigu\n      2.3 要素三：用户名和密码  user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接  2.4 数据库连接方式举例 2.4.1 连接方式一 @Test public void testConnection1() { try { //1.提供java.sql.Driver接口实现类的对象  Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据  String url = \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;; //3.提供Properties的对象，指明用户名和密码  Properties info = new Properties(); info.setProperty(\u0026#34;user\u0026#34;, \u0026#34;root\u0026#34;); info.setProperty(\u0026#34;password\u0026#34;, \u0026#34;abc123\u0026#34;); //4.调用driver的connect()，获取连接  Connection conn = driver.connect(url, info); System.out.println(conn); } catch (SQLException e) { e.printStackTrace(); } }  说明：上述代码中显式出现了第三方数据库的API\n 2.4.2 连接方式二 @Test public void testConnection2() { try { //1.实例化Driver  String className = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; Class clazz = Class.forName(className); Driver driver = (Driver) clazz.newInstance(); //2.提供url，指明具体操作的数据  String url = \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;; //3.提供Properties的对象，指明用户名和密码  Properties info = new Properties(); info.setProperty(\u0026#34;user\u0026#34;, \u0026#34;root\u0026#34;); info.setProperty(\u0026#34;password\u0026#34;, \u0026#34;abc123\u0026#34;); //4.调用driver的connect()，获取连接  Connection conn = driver.connect(url, info); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } }  说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。\n 2.4.3 连接方式三 @Test public void testConnection3() { try { //1.数据库连接的4个基本要素：  String url = \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;abc123\u0026#34;; String driverName = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; //2.实例化Driver  Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动  DriverManager.registerDriver(driver); //4.获取连接  Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } }  说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。\n 2.4.4 连接方式四 @Test public void testConnection4() { try { //1.数据库连接的4个基本要素：  String url = \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;abc123\u0026#34;; String driverName = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; //2.加载驱动 （①实例化Driver ②注册驱动）  Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance();  //3.注册驱动  //DriverManager.registerDriver(driver);  /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\u0026#34;Can\u0026#39;t register driver!\u0026#34;); } } */ //3.获取连接  Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } }  说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。\n 2.4.5 连接方式五(最终版) @Test public void testConnection5() throws Exception { //1.加载配置文件  InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\u0026#34;jdbc.properties\u0026#34;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息  String user = pros.getProperty(\u0026#34;user\u0026#34;); String password = pros.getProperty(\u0026#34;password\u0026#34;); String url = pros.getProperty(\u0026#34;url\u0026#34;); String driverClass = pros.getProperty(\u0026#34;driverClass\u0026#34;); //3.加载驱动  Class.forName(driverClass); //4.获取连接  Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); } 其中，配置文件声明在工程的src目录下：【jdbc.properties】\nuser=root\rpassword=abc123\rurl=jdbc:mysql://localhost:3306/test\rdriverClass=com.mysql.jdbc.Driver\r 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件\n使用配置文件的好处：\n①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 ②如果修改了配置信息，省去重新编译的过程。\n 第3章：使用PreparedStatement实现CRUD操作 3.1 操作和访问数据库   数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。\n  在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：\n Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程    3.2 使用Statement操作数据表的弊端   通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。\n  Statement 接口中定义了下列方法用于执行 SQL 语句：\nintexcuteUpdate(Stringsql)：执行更新操作INSERT、UPDATE、DELETEResultSetexecuteQuery(Stringsql)：执行查询操作SELECT  但是使用Statement操作数据表存在弊端：\n 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题    SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=\u0026lsquo;a\u0026rsquo; OR 1 = ' AND password = ' OR \u0026lsquo;1\u0026rsquo; = \u0026lsquo;1\u0026rsquo;) ，从而利用系统的 SQL 引擎完成恶意行为的做法。\n  对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。\n  代码演示：\n  public class StatementTest { // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 \t@Test public void testLogin() { Scanner scan = new Scanner(System.in); System.out.print(\u0026#34;用户名：\u0026#34;); String userName = scan.nextLine(); System.out.print(\u0026#34;密 码：\u0026#34;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = \u0026#39;1\u0026#39; or \u0026#39; AND PASSWORD = \u0026#39;=\u0026#39;1\u0026#39; or \u0026#39;1\u0026#39; = \u0026#39;1\u0026#39;; \tString sql = \u0026#34;SELECT user,password FROM user_table WHERE USER = \u0026#39;\u0026#34; + userName + \u0026#34;\u0026#39; AND PASSWORD = \u0026#39;\u0026#34; + password + \u0026#34;\u0026#39;\u0026#34;; User user = get(sql, User.class); if (user != null) { System.out.println(\u0026#34;登陆成功!\u0026#34;); } else { System.out.println(\u0026#34;用户名或密码错误！\u0026#34;); } } // 使用Statement实现对数据表的查询操作 \tpublic \u0026lt;T\u0026gt; T get(String sql, Class\u0026lt;T\u0026gt; clazz) { T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try { // 1.加载配置文件 \tInputStream is = StatementTest.class.getClassLoader().getResourceAsStream(\u0026#34;jdbc.properties\u0026#34;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 \tString user = pros.getProperty(\u0026#34;user\u0026#34;); String password = pros.getProperty(\u0026#34;password\u0026#34;); String url = pros.getProperty(\u0026#34;url\u0026#34;); String driverClass = pros.getProperty(\u0026#34;driverClass\u0026#34;); // 3.加载驱动 \tClass.forName(driverClass); // 4.获取连接 \tconn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 \tResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 \tint columnCount = rsmd.getColumnCount(); if (rs.next()) { t = clazz.newInstance(); for (int i = 0; i \u0026lt; columnCount; i++) { // //1. 获取列的名称 \t// String columnName = rsmd.getColumnName(i+1);  // 1. 获取列的别名 \tString columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 \tObject columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 \tField field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭资源 \tif (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null) { try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } return null; } } 综上：\n3.3 PreparedStatement的使用 3.3.1 PreparedStatement介绍   可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象\n  PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句\n  PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值\n  3.3.2 PreparedStatement vs Statement   代码的可读性和可维护性。\n  PreparedStatement 能最大可能提高性能：\n DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存)    PreparedStatement 可以防止 SQL 注入\n  3.3.3 Java与SQL对应数据类型转换表    Java类型 SQL类型     boolean BIT   byte TINYINT   short SMALLINT   int INTEGER   long BIGINT   String CHAR,VARCHAR,LONGVARCHAR   byte array BINARY , VAR BINARY   java.sql.Date DATE   java.sql.Time TIME   java.sql.Timestamp TIMESTAMP    3.3.4 使用PreparedStatement实现增、删、改操作 //通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表） \tpublic void update(String sql,Object ... args){ Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 \tconn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) \tps = conn.prepareStatement(sql); //3.填充占位符 \tfor(int i = 0;i \u0026lt; args.length;i++){ ps.setObject(i + 1, args[i]); } //4.执行sql语句 \tps.execute(); } catch (Exception e) { e.printStackTrace(); }finally{ //5.关闭资源 \tJDBCUtils.closeResource(conn, ps); } }  使用execute()方法时，如果第一个结果是ResultSet对象，则为true；如果第一个结果是更新计数或没有结果，则为false。（即执行查询操作时返回true，执行增、删、改操作时返回false）\n 3.3.5 使用PreparedStatement实现查询操作   创建User类，封装User的属性\npackage jdbc; /** * @Author: minster * @Date: 2021/10/7 16:36 */ public class User { private int id; private String name; private String password; private String address; private String phone; public User(){ } public User(int id, String name, String password, String address, String phone) { this.id = id; this.name = name; this.password = password; this.address = address; this.phone = phone; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, address=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   DbProperties类，用于连接访问数据库\npackage jdbc; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Collection; import java.util.Properties; /** * @Author: minster * @Date: 2021/10/7 15:02 */ public class DbProperties { public static Connection getConnectionTest(){ InputStream is = DbProperties.class.getClassLoader().getResourceAsStream(\u0026#34;jdbc.properties\u0026#34;); Properties pros = new Properties(); Connection conn = null; try { pros.load(is); String user = pros.getProperty(\u0026#34;user\u0026#34;); String password = pros.getProperty(\u0026#34;password\u0026#34;); String url = pros.getProperty(\u0026#34;url\u0026#34;); String driverClass = pros.getProperty(\u0026#34;driverClass\u0026#34;); Class.forName(driverClass); conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (IOException | ClassNotFoundException | SQLException e) { e.printStackTrace(); }finally { } return conn; } /** * 封装三个关闭方法 * @param pstmt */ public static void close(PreparedStatement pstmt){ //避免出现空指针异常  if(pstmt != null){ try{ pstmt.close(); }catch(SQLException e){ e.printStackTrace(); } } } public static void close(Connection conn){ if(conn != null){ try { conn.close(); } catch (SQLException e) { // TODO: handle exception  e.printStackTrace(); } } } public static void close(ResultSet rs){ if (rs != null) { try { rs.close(); } catch (SQLException e) { // TODO: handle exception  e.printStackTrace(); } } } }   FindUserTable类，用于实现查询User表中的数据\npackage jdbc; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; /** * @Author: minster * @Date: 2021/10/7 16:34 */ public class FindUserTable { public List\u0026lt;User\u0026gt; findUserList() throws SQLException { String sql = \u0026#34;select * from user order by id\u0026#34;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; //创建一个集合，用于存放查询到的数据  List\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;\u0026gt;(); try { //1. 获取数据库连接  conn = (Connection) DbProperties.getConnectionTest(); //2. 预编译sql语句，得到PreparedStatement对象  pstmt = (PreparedStatement) conn.prepareStatement(sql); //3. 执行executeQuery(),得到结果集：ResultSet  rs = (ResultSet) pstmt.executeQuery(); while (rs.next()){ //4. 通过集合获取每一个对象的每条信息  int userId = rs.getInt(\u0026#34;id\u0026#34;); String userName = rs.getString(\u0026#34;name\u0026#34;); String userPassword = rs.getString(\u0026#34;password\u0026#34;); String userAddress = rs.getString(\u0026#34;address\u0026#34;); String userPhone = rs.getString(\u0026#34;phone\u0026#34;); //5. 每个记录对应一个对象  User user = new User(); user.setId(userId); user.setName(userName); user.setPassword(userPassword); user.setAddress(userAddress); user.setPhone(userPhone); //6. 将对象放到集合中  userList.add(user); } } catch (SQLException throwables) { throwables.printStackTrace(); }finally { //7. 关闭资源  DbProperties.close(pstmt); DbProperties.close(conn); DbProperties.close(rs); } return userList; } }   Tset类，用于测试\npackage jdbc; import java.sql.PreparedStatement; import java.sql.SQLException; import java.util.Iterator; import java.util.List; /** * @Author: minster * @Date: 2021/10/1 10:48 */ public class Test { public static void main(String[] args) throws SQLException { FindUserTable findUserTable = new FindUserTable(); List\u0026lt;User\u0026gt; userList = findUserTable.findUserList(); Iterator\u0026lt;User\u0026gt; iterator = userList.iterator(); //使用迭代器遍历输出  while (iterator.hasNext()) { User next = iterator.next(); System.out.println(next); } } }   输出结果\n  通用的针对于不同表的查询\n// 通用的针对于不同表的查询:返回一个对象 (version 1.0) public \u0026lt;T\u0026gt; T getInstance(Class\u0026lt;T\u0026gt; clazz, String sql, Object... args) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { // 1.获取数据库连接  conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象  ps = conn.prepareStatement(sql); // 3.填充占位符  for (int i = 0; i \u0026lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 4.执行executeQuery(),得到结果集：ResultSet  rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData  ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值  int columnCount = rsmd.getColumnCount(); if (rs.next()) { T t = clazz.newInstance(); for (int i = 0; i \u0026lt; columnCount; i++) {// 遍历每一个列  // 获取列值  Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当  String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值  Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 7.关闭资源  JDBCUtils.closeResource(conn, ps, rs); } return null; }    说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。\n占位符：即SQL语句中使用了?来替换字段的个数。我们使用了多少个就需要填充多少个！\n在通用操作中，可以使用Object ...args 可变参数来传递占位符数据！（因为不知道SQL语句有多少个占位符）\n 3.4 ResultSet与ResultSetMetaData 3.4.1 ResultSet   查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象\n  ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现\n  ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。\n  ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。\n  当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。\n 例如: getInt(1), getString(\u0026ldquo;name\u0026rdquo;) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。    ResultSet 接口的常用方法：\n  boolean next()\n  getString()\n  …\n    3.4.2 ResultSetMetaData   可用于获取关于 ResultSet 对象中列的类型和属性信息的对象\n  ResultSetMetaData meta = rs.getMetaData();\n  getColumnName(int column)：获取指定列的名称\n  getColumnLabel(int column)：获取指定列的别名\n  getColumnCount()：返回当前 ResultSet 对象中的列数。\n  getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。\n  getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。\n  isNullable(int column)：指示指定列中的值是否可以为 null。\n  isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。\n    问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？\n​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData\n问题2：关于ResultSetMetaData\n 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法  3.5 资源的释放   释放ResultSet, Statement,Connection。\n  数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。\n  可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。\n  代码演示\npublic static void close(PreparedStatement pstmt){ //避免出现空指针异常  if(pstmt != null){ try{ pstmt.close(); }catch(SQLException e){ e.printStackTrace(); } } } public static void close(Connection conn){ if(conn != null){ try { conn.close(); } catch (SQLException e) { // TODO: handle exception  e.printStackTrace(); } } } public static void close(ResultSet rs){ if (rs != null) { try { rs.close(); } catch (SQLException e) { // TODO: handle exception  e.printStackTrace(); } } }   3.6 JDBC API小结   两种思想\n  面向接口编程的思想\n  ORM思想(object relational mapping)\n 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性     sql是需要结合列名和表的属性名来写。注意起别名。\n   两种技术\n JDBC结果集的元数据：ResultSetMetaData  获取列数：getColumnCount() 获取列的别名：getColumnLabel()   通过反射，创建指定类的对象，获取指定的属性并赋值     章节练习 练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：\n练习题2：创立数据库表 examstudent，表结构如下：\n向数据表中添加如下数据：\n代码实现1：插入一个新的student 信息\n请输入考生的详细信息\nType: IDCard: ExamCard: StudentName: Location: Grade:\n信息录入成功!\n代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：\n代码实现3：完成学生信息的删除功能\n 第4章 操作BLOB类型字段 4.1 MySQL BLOB类型   MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。\n  插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。\n  MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)\n  实际使用中根据需要存入的数据大小定义不同的BLOB类型。\n  需要注意的是：如果存储的文件过大，数据库的性能会下降。\n  如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。\n  4.2 向数据表中插入大数据类型 //获取连接 Connection conn = JDBCUtils.getConnection(); String sql = \u0026#34;insert into customers(name,email,birth,photo)values(?,?,?,?)\u0026#34;; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 ps.setString(1, \u0026#34;徐海强\u0026#34;); ps.setString(2, \u0026#34;xhq@126.com\u0026#34;); ps.setDate(3, new Date(new java.util.Date().getTime())); // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(\u0026#34;xhq.png\u0026#34;); ps.setBlob(4, fis); //执行 ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段 Connection conn = JDBCUtils.getConnection(); String sql = \u0026#34;update customers set photo = ? where id = ?\u0026#34;; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(\u0026#34;coffee.png\u0026#34;); ps.setBlob(1, fis); ps.setInt(2, 25); ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型 String sql = \u0026#34;SELECT id, name, email, birth, photo FROM customer WHERE id = ?\u0026#34;; conn = getConnection(); ps = conn.prepareStatement(sql); ps.setInt(1, 8); rs = ps.executeQuery(); if(rs.next()){ Integer id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); Date birth = rs.getDate(4); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //读取Blob类型的字段 \tBlob photo = rs.getBlob(5); InputStream is = photo.getBinaryStream(); OutputStream os = new FileOutputStream(\u0026#34;c.jpg\u0026#34;); byte [] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); } JDBCUtils.closeResource(conn, ps, rs); if(is != null){ is.close(); } if(os != null){ os.close(); } } 第5章 批量插入 5.1 批量执行SQL语句 当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率\nJDBC的批量处理语句包括下面三个方法：\n addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据  通常我们会遇到两种批量执行SQL语句的情况：\n 多条SQL语句的批量处理； 一个SQL语句的批量传参；  5.2 高效的批量插入 举例：向数据表中插入20000条数据\n 数据库中提供一个goods表。创建如下：  CREATETABLEgoods(idINTPRIMARYKEYAUTO_INCREMENT,NAMEVARCHAR(20));5.2.1 实现层次一：使用Statement Connection conn = JDBCUtils.getConnection(); Statement st = conn.createStatement(); for(int i = 1;i \u0026lt;= 20000;i++){ String sql = \u0026#34;insert into goods(name) values(\u0026#39;name_\u0026#39; + \u0026#34;+ i +\u0026#34;)\u0026#34;; st.executeUpdate(sql); } 5.2.2 实现层次二：使用PreparedStatement long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = \u0026#34;insert into goods(name)values(?)\u0026#34;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i \u0026lt;= 20000;i++){ ps.setString(1, \u0026#34;name_\u0026#34; + i); ps.executeUpdate(); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;花费的时间为：\u0026#34; + (end - start));//82340 \tJDBCUtils.closeResource(conn, ps); 5.2.3 实现层次三 /* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */ @Test public void testInsert1() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = \u0026#34;insert into goods(name)values(?)\u0026#34;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i \u0026lt;= 1000000;i++){ ps.setString(1, \u0026#34;name_\u0026#34; + i); //1.“攒”sql \tps.addBatch(); if(i % 500 == 0){ //2.执行 \tps.executeBatch(); //3.清空 \tps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(\u0026#34;花费的时间为：\u0026#34; + (end - start));//20000条：625 //1000000条:14733 \tJDBCUtils.closeResource(conn, ps); } 5.2.4 实现层次四 /* * 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */ @Test public void testInsert2() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 \tconn.setAutoCommit(false); String sql = \u0026#34;insert into goods(name)values(?)\u0026#34;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i \u0026lt;= 1000000;i++){ ps.setString(1, \u0026#34;name_\u0026#34; + i); //1.“攒”sql \tps.addBatch(); if(i % 500 == 0){ //2.执行 \tps.executeBatch(); //3.清空 \tps.clearBatch(); } } //2.提交数据 \tconn.commit(); long end = System.currentTimeMillis(); System.out.println(\u0026#34;花费的时间为：\u0026#34; + (end - start));//1000000条:4978 \tJDBCUtils.closeResource(conn, ps); } 第6章： 数据库事务 6.1 数据库事务介绍   事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。\n  事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。\n  为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。\n  6.2 JDBC事务处理   数据一旦提交，就不可回滚。\n  数据什么时候意味着提交？\n 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 **关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。    JDBC程序中为了让多个 SQL 语句作为一个事务执行：\n 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务   若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。\n   【案例：用户AA向用户BB转账100】\npublic void testJDBCTransaction() { Connection conn = null; try { // 1.获取数据库连接 \tconn = JDBCUtils.getConnection(); // 2.开启事务 \tconn.setAutoCommit(false); // 3.进行数据库操作 \tString sql1 = \u0026#34;update user_table set balance = balance - 100 where user = ?\u0026#34;; update(conn, sql1, \u0026#34;AA\u0026#34;); // 模拟网络异常 \t//System.out.println(10 / 0);  String sql2 = \u0026#34;update user_table set balance = balance + 100 where user = ?\u0026#34;; update(conn, sql2, \u0026#34;BB\u0026#34;); // 4.若没有异常，则提交事务 \tconn.commit(); } catch (Exception e) { e.printStackTrace(); // 5.若有异常，则回滚事务 \ttry { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { //6.恢复每次DML操作的自动提交功能 \tconn.setAutoCommit(true); } catch (SQLException e) { e.printStackTrace(); } //7.关闭连接 \tJDBCUtils.closeResource(conn, null, null); } } 其中，对数据库操作的方法为：\n//使用事务以后的通用的增删改操作（version 2.0） public void update(Connection conn ,String sql, Object... args) { PreparedStatement ps = null; try { // 1.获取PreparedStatement的实例 (或：预编译sql语句) \tps = conn.prepareStatement(sql); // 2.填充占位符 \tfor (int i = 0; i \u0026lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3.执行sql语句 \tps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 4.关闭资源 \tJDBCUtils.closeResource(null, ps); } } 6.3 事务的ACID属性   原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n  一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。\n  隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n  持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n  6.3.1 数据库的并发问题   对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。    数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n  一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n  6.3.2 四种隔离级别   数据库提供的4种事务隔离级别：\n  Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。\n  Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n  6.3.3 在MySql中设置隔离级别   每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。\n  查看当前的隔离级别:\nSELECT@@tx_isolation;  设置当前 mySQL 连接的隔离级别:\nsettransactionisolationlevelreadcommitted;  设置数据库系统的全局的隔离级别:\nsetglobaltransactionisolationlevelreadcommitted;  补充操作：\n  创建mysql数据库用户：\ncreateusertomidentifiedby\u0026#39;abc123\u0026#39;;  授予权限\n#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123. grantallprivilegeson*.*totom@\u0026#39;%\u0026#39;identifiedby\u0026#39;abc123\u0026#39;;#给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 grantselect,insert,delete,updateonatguigudb.*totom@localhostidentifiedby\u0026#39;abc123\u0026#39;;    第7章：DAO及相关实现类   DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO\n  作用：为了实现功能的模块化，更有利于代码的维护和升级。\n  下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：\n  层次结构：\n  【BaseDAO.java】 package com.atguigu.bookstore.dao; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.sql.Connection; import java.sql.SQLException; import java.util.List; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; import org.apache.commons.dbutils.handlers.ScalarHandler; /** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param \u0026lt;T\u0026gt; */ public abstract class BaseDao\u0026lt;T\u0026gt; { private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 \tprivate Class\u0026lt;T\u0026gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 \tpublic BaseDao() { // 获取子类的类型 \tClass clazz = this.getClass(); // 获取父类的类型 \t// getGenericSuperclass()用来获取当前类的父类的类型 \t// ParameterizedType表示的是带泛型的类型 \tParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 \t// 这个方法会返回一个Type的数组 \tType[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· \tthis.type = (Class\u0026lt;T\u0026gt;) types[0]; } /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) { int count = 0; try { count = queryRunner.update(conn, sql, params); } catch (SQLException e) { e.printStackTrace(); } return count; } /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) { T t = null; try { t = queryRunner.query(conn, sql, new BeanHandler\u0026lt;T\u0026gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return t; } /** * 获取所有对象 * * @param sql * @param params * @return */ public List\u0026lt;T\u0026gt; getBeanList(Connection conn,String sql, Object... params) { List\u0026lt;T\u0026gt; list = null; try { list = queryRunner.query(conn, sql, new BeanListHandler\u0026lt;T\u0026gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return list; } /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) { Object count = null; try { // 调用queryRunner的query方法获取一个单一的值 \tcount = queryRunner.query(conn, sql, new ScalarHandler\u0026lt;\u0026gt;(), params); } catch (SQLException e) { e.printStackTrace(); } return count; } } 【BookDAO.java】 package com.atguigu.bookstore.dao; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; public interface BookDao { /** * 从数据库中查询出所有的记录 * * @return */ List\u0026lt;Book\u0026gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page\u0026lt;Book\u0026gt; getPageBooks(Connection conn,Page\u0026lt;Book\u0026gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page\u0026lt;Book\u0026gt; getPageBooksByPrice(Connection conn,Page\u0026lt;Book\u0026gt; page, double minPrice, double maxPrice); } 【UserDAO.java】 package com.atguigu.bookstore.dao; import java.sql.Connection; import com.atguigu.bookstore.beans.User; public interface UserDao { /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user); } 【BookDaoImpl.java】 package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.BookDao; public class BookDaoImpl extends BaseDao\u0026lt;Book\u0026gt; implements BookDao { @Override public List\u0026lt;Book\u0026gt; getBooks(Connection conn) { // 调用BaseDao中得到一个List的方法 \tList\u0026lt;Book\u0026gt; beanList = null; // 写sql语句 \tString sql = \u0026#34;select id,title,author,price,sales,stock,img_path imgPath from books\u0026#34;; beanList = getBeanList(conn,sql); return beanList; } @Override public void saveBook(Connection conn,Book book) { // 写sql语句 \tString sql = \u0026#34;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\u0026#34;; // 调用BaseDao中通用的增删改的方法 \tupdate(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); } @Override public void deleteBookById(Connection conn,String bookId) { // 写sql语句 \tString sql = \u0026#34;DELETE FROM books WHERE id = ?\u0026#34;; // 调用BaseDao中通用增删改的方法 \tupdate(conn,sql, bookId); } @Override public Book getBookById(Connection conn,String bookId) { // 调用BaseDao中获取一个对象的方法 \tBook book = null; // 写sql语句 \tString sql = \u0026#34;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\u0026#34;; book = getBean(conn,sql, bookId); return book; } @Override public void updateBook(Connection conn,Book book) { // 写sql语句 \tString sql = \u0026#34;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\u0026#34;; // 调用BaseDao中通用的增删改的方法 \tupdate(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); } @Override public Page\u0026lt;Book\u0026gt; getPageBooks(Connection conn,Page\u0026lt;Book\u0026gt; page) { // 获取数据库中图书的总记录数 \tString sql = \u0026#34;select count(*) from books\u0026#34;; // 调用BaseDao中获取一个单一值的方法 \tlong totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 \tpage.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List \tString sql2 = \u0026#34;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\u0026#34;; // 调用BaseDao中获取一个集合的方法 \tList\u0026lt;Book\u0026gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 \tpage.setList(beanList); return page; } @Override public Page\u0026lt;Book\u0026gt; getPageBooksByPrice(Connection conn,Page\u0026lt;Book\u0026gt; page, double minPrice, double maxPrice) { // 获取数据库中图书的总记录数 \tString sql = \u0026#34;select count(*) from books where price between ? and ?\u0026#34;; // 调用BaseDao中获取一个单一值的方法 \tlong totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 \tpage.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List \tString sql2 = \u0026#34;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\u0026#34;; // 调用BaseDao中获取一个集合的方法 \tList\u0026lt;Book\u0026gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 \tpage.setList(beanList); return page; } } 【UserDaoImpl.java】 package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import com.atguigu.bookstore.beans.User; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.UserDao; public class UserDaoImpl extends BaseDao\u0026lt;User\u0026gt; implements UserDao { @Override public User getUser(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 \tUser bean = null; // 写sql语句 \tString sql = \u0026#34;select id,username,password,email from users where username = ? and password = ?\u0026#34;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; } @Override public boolean checkUsername(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 \tUser bean = null; // 写sql语句 \tString sql = \u0026#34;select id,username,password,email from users where username = ?\u0026#34;; bean = getBean(conn,sql, user.getUsername()); return bean != null; } @Override public void saveUser(Connection conn,User user) { //写sql语句 \tString sql = \u0026#34;insert into users(username,password,email) values(?,?,?)\u0026#34;; //调用BaseDao中通用的增删改的方法 \tupdate(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); } } 【Book.java】 package com.atguigu.bookstore.beans; /** * 图书类 * @author songhongkang * */ public class Book { private Integer id; private String title; // 书名 \tprivate String author; // 作者 \tprivate double price; // 价格 \tprivate Integer sales; // 销量 \tprivate Integer stock; // 库存 \tprivate String imgPath = \u0026#34;static/img/default.jpg\u0026#34;; // 封面图片的路径 \t//构造器，get()，set()，toString()方法略 } 【Page.java】 package com.atguigu.bookstore.beans; import java.util.List; /** * 页码类 * @author songhongkang * */ public class Page\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; list; // 每页查到的记录存放的集合 \tpublic static final int PAGE_SIZE = 4; // 每页显示的记录数 \tprivate int pageNo; // 当前页 //\tprivate int totalPageNo; // 总页数，通过计算得到 \tprivate int totalRecord; // 总记录数，通过查询数据库得到  【User.java】 package com.atguigu.bookstore.beans; /** * 用户类 * @author songhongkang * */ public class User { private Integer id; private String username; private String password; private String email; 第8章：数据库连接池 8.1 JDBC数据库连接池的必要性   在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接    这种模式开发，存在的问题:\n 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 **对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。    8.2 数据库连接池技术   为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。\n  数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\n  数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。\n  数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。\n  工作原理：\n  数据库连接池技术的优点\n1. 资源重用\n由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。\n2. 更快的系统反应速度\n数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间\n3. 新的资源分配手段\n对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源\n4. 统一的连接管理，避免数据库连接泄漏\n在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露\n  8.3 多种开源的数据库连接池  JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：  DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快   DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意：  数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。    8.3.1 C3P0数据库连接池  获取连接方式一  //使用C3P0数据库连接池的方式，获取数据库的连接：不推荐 public static Connection getConnection1() throws Exception{ ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); cpds.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;); cpds.setUser(\u0026#34;root\u0026#34;); cpds.setPassword(\u0026#34;abc123\u0026#34;); //\tcpds.setMaxPoolSize(100); \tConnection conn = cpds.getConnection(); return conn; }  获取连接方式二  //使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource cpds = new ComboPooledDataSource(\u0026#34;helloc3p0\u0026#34;); public static Connection getConnection2() throws SQLException{ Connection conn = cpds.getConnection(); return conn; } 其中，src下的配置文件为：【c3p0-config.xml】\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;c3p0-config\u0026gt; \u0026lt;named-config name=\u0026#34;helloc3p0\u0026#34;\u0026gt; \u0026lt;!-- 获取连接的4个基本信息 --\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34;\u0026gt;root\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;abc123\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34;\u0026gt;jdbc:mysql:///test\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34;\u0026gt;com.mysql.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --\u0026gt; \u0026lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --\u0026gt; \u0026lt;property name=\u0026#34;acquireIncrement\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;!-- 初始化数据库连接池时连接的数量 --\u0026gt; \u0026lt;property name=\u0026#34;initialPoolSize\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;!-- 数据库连接池中的最小的数据库连接数 --\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;!-- 数据库连接池中的最大的数据库连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34;\u0026gt;10\u0026lt;/property\u0026gt; \u0026lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --\u0026gt; \u0026lt;property name=\u0026#34;maxStatements\u0026#34;\u0026gt;20\u0026lt;/property\u0026gt; \u0026lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --\u0026gt; \u0026lt;property name=\u0026#34;maxStatementsPerConnection\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;/named-config\u0026gt; \u0026lt;/c3p0-config\u0026gt; 8.3.2 DBCP数据库连接池  DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：  Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库   **Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明     属性 默认值 说明     initialSize 0 连接池启动时创建的初始化连接数量   maxActive 8 连接池中可同时连接的最大的连接数   maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制   minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。   maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待   poolPreparedStatements false 开启池的Statement是否prepared   maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数   minEvictableIdleTimeMillis  连接池中连接，在时间段内一直空闲， 被逐出连接池的时间   removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接   removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收     获取连接方式一：  public static Connection getConnection3() throws Exception { BasicDataSource source = new BasicDataSource(); source.setDriverClassName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); source.setUrl(\u0026#34;jdbc:mysql:///test\u0026#34;); source.setUsername(\u0026#34;root\u0026#34;); source.setPassword(\u0026#34;abc123\u0026#34;); // \tsource.setInitialSize(10); Connection conn = source.getConnection(); return conn; }  获取连接方式二：  //使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource source = null; static{ try { Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(\u0026#34;dbcp.properties\u0026#34;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 \tsource = BasicDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection4() throws Exception { Connection conn = source.getConnection(); return conn; } 其中，src下的配置文件为：【dbcp.properties】\ndriverClassName=com.mysql.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\u0026amp;useServerPrepStmts=false\rusername=root\rpassword=abc123\rinitialSize=10\r#...\r8.3.3 Druid（德鲁伊）数据库连接池 Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。\npackage com.atguigu.druid; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; public class TestDruid { public static void main(String[] args) throws Exception { Properties pro = new Properties();\tpro.load(TestDruid.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;)); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); } } 其中，src下的配置文件为：【druid.properties】\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true username=root password=123456 driverClassName=com.mysql.jdbc.Driver initialSize=10 maxActive=20 maxWait=1000 filters=wall  详细配置参数：     配置 缺省 说明     name  配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this)   url  连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto   username  连接数据库的用户名   password  连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter   driverClassName  根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)   initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时   maxActive 8 最大连接池数量   maxIdle 8 已经不再使用，配置了也没效果   minIdle  最小连接池数量   maxWait  获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。   poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。   maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100   validationQuery  用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。   testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。   testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能   testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。   timeBetweenEvictionRunsMillis  有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明   numTestsPerEvictionRun  不再使用，一个DruidDataSource只支持一个EvictionRun   minEvictableIdleTimeMillis     connectionInitSqls  物理连接初始化的时候执行的sql   exceptionSorter  根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接   filters  属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall   proxyFilters  类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系    第9章：Apache-DBUtils实现CRUD操作 9.1 Apache-DBUtils简介   commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。\n  API介绍：\n org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils    API包说明：\n  9.2 主要API的使用 9.2.1 DbUtils  DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：  public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。    9.2.2 QueryRunner类   该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。\n  QueryRunner类提供了两个构造器：\n 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器    QueryRunner类的主要方法：\n 更新  public int update(Connection conn, String sql, Object\u0026hellip; params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 \u0026hellip;\u0026hellip;   插入  public T insert(Connection conn,String sql,ResultSetHandlerrsh, Object\u0026hellip; params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 \u0026hellip;.   批处理  public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandlerrsh,Object[][] params)throws SQLException：只支持INSERT语句 \u0026hellip;..   查询  public Object query(Connection conn, String sql, ResultSetHandler rsh,Object\u0026hellip; params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 \u0026hellip;\u0026hellip;      测试\n  // 测试添加 @Test public void testInsert() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \u0026#34;insert into customers(name,email,birth)values(?,?,?)\u0026#34;; int count = runner.update(conn, sql, \u0026#34;何成飞\u0026#34;, \u0026#34;he@qq.com\u0026#34;, \u0026#34;1992-09-08\u0026#34;); System.out.println(\u0026#34;添加了\u0026#34; + count + \u0026#34;条记录\u0026#34;); JDBCUtils.closeResource(conn, null); } // 测试删除 @Test public void testDelete() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \u0026#34;delete from customers where id \u0026lt; ?\u0026#34;; int count = runner.update(conn, sql,3); System.out.println(\u0026#34;删除了\u0026#34; + count + \u0026#34;条记录\u0026#34;); JDBCUtils.closeResource(conn, null); } 9.2.3 ResultSetHandler接口及实现类   该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。\n  ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。\n  接口的主要实现类：\n ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。 **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List **ScalarHandler：**查询单个值对象    测试\n  /* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */ @Test public void testQueryInstance() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \u0026#34;select id,name,email,birth from customers where id = ?\u0026#34;; // \tBeanHandler\u0026lt;Customer\u0026gt; handler = new BeanHandler\u0026lt;\u0026gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer);\tJDBCUtils.closeResource(conn, null); } /* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */ @Test public void testQueryList() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \u0026#34;select id,name,email,birth from customers where id \u0026lt; ?\u0026#34;; // \tBeanListHandler\u0026lt;Customer\u0026gt; handler = new BeanListHandler\u0026lt;\u0026gt;(Customer.class); List\u0026lt;Customer\u0026gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null); } /* * 自定义ResultSetHandler的实现类 */ @Test public void testQueryInstance1() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \u0026#34;select id,name,email,birth from customers where id = ?\u0026#34;; ResultSetHandler\u0026lt;Customer\u0026gt; handler = new ResultSetHandler\u0026lt;Customer\u0026gt;() { @Override public Customer handle(ResultSet rs) throws SQLException { System.out.println(\u0026#34;handle\u0026#34;); //\treturn new Customer(1,\u0026#34;Tom\u0026#34;,\u0026#34;tom@126.com\u0026#34;,new Date(123323432L)); \tif(rs.next()){ int id = rs.getInt(\u0026#34;id\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); String email = rs.getString(\u0026#34;email\u0026#34;); Date birth = rs.getDate(\u0026#34;birth\u0026#34;); return new Customer(id, name, email, birth); } return null; } }; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */ @Test public void testQueryValue() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); //测试一： //\tString sql = \u0026#34;select count(*) from customers where id \u0026lt; ?\u0026#34;; //\tScalarHandler handler = new ScalarHandler(); //\tlong count = (long) runner.query(conn, sql, handler, 20); //\tSystem.out.println(count); \t//测试二： \tString sql = \u0026#34;select max(birth) from customers\u0026#34;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null); } JDBC总结 总结 @Test public void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作（ \t//① 手写的连接：JDBCUtils.getConnection(); \t//② 使用数据库连接池：C3P0;DBCP;Druid \t//2.对数据表进行一系列CRUD操作 \t//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0) //version2.0的增删改public void update(Connection conn,String sql,Object ... args){} //version2.0的查询 public \u0026lt;T\u0026gt; T getInstance(Connection conn,Class\u0026lt;T\u0026gt; clazz,String sql,Object ... args){} \t//② 使用dbutils提供的jar包中提供的QueryRunner类 \t//提交数据 \tconn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 \tconn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 \t//① JDBCUtils.closeResource(); \t//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 \t} } ","date":"2021-09-05T16:22:25+08:00","permalink":"https://minster77.github.io/p/%E5%AE%8B%E7%BA%A2%E5%BA%B7%E8%80%81%E5%B8%88%E7%9A%84jdbc%E7%AC%94%E8%AE%B0/","title":"宋红康老师的JDBC笔记"},{"content":"代理模式   代理模式基本介绍\n  代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的**好处是：**可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能\n  被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象\n  代理模式有不同的形式，主要有三种静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴的）。\n  代理模式示意图\n    静态代理模式  间接的“美” 中国人是一个含蓄的民族，讲究微妙和间接的交流方式。对象间的间接通信也同样是面向对象设计中一条重要的审美观。间接性的通信可以给出较低的耦合关系，较强的合作关系，以及微妙的结构和易于复用的设计架构。 \u0026mdash;-\u0026laquo;Java与模式\u0026raquo;\n   代理模式的定义\n​\t代理模式的英文叫Proxy或Surrogate。所谓代理就是指一个人或者一个机构代表另一个人或者另一个机构行动。有一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。\n  意图\n​\t为其他对象提供一种代理以控制对这个对象的访问。\n  代理模式的结构\n 抽象主题角色（接口）：声明了正是主题和代理主题的共同接口。这样一来任何使用真是主题的地方都可以使用代理主题。 代理主题（Peoxy）角色（代理类）：代理主题角色内部含有一个对真实主题角色的引用。从而可以在任何时候操作真实主体对象；代理主题角色提供一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题；控制对真实主题的引用，负责在需要的时候创建真实主题对象（或删除真实主题对象）；代理主题通常在客户端调用真实主题之前或之后都要执行某个操作，而不是单纯将调用传给真实主题。 真实主题角色（被代理类）：定义了代理角色所代表的真实对象。    静态代理\n​\t由程序员创建或特定工具自动生成源码，也就是说在编译时就已经将接口，被代理类，代理类等确定了下来。在程序运行之前，代理类的.class文件就已经生成。\n  静态代理简单实现\n​\t假设现在jack要结婚，jack把他的婚礼包办给了婚礼公司，在这个案例中，我们可以知道抽象主题角色便是婚礼（结婚），然后代理主题角色是婚礼公司，真实主题角色是jack。\n​\t首先，我们创建一个Marry接口。这个接口就是jack（被代理类）和婚礼公司（代理类）的公共接口，他们都有举办婚礼的行为。这样，jack的婚礼就可以让婚礼公司来代理执行。\n创建接口Marry\ninterface Marry{ void HoldWedding(); } 创建被代理类Customer\nclass Customer implements Marry{ @Override public void HoldWedding() { System.out.println(\u0026#34;我是jack，我结婚了！\u0026#34;); } } 创建代理类WeddingCompany\nclass WeddingCompany implements Marry{ private Customer customer; public WeddingCompany(Customer customer){ this.customer = customer; } @Override public void HoldWedding() { before(); this.customer.HoldWedding(); after(); } private void before() { System.out.println(\u0026#34;结婚之前，布置场地\u0026#34;); } private void after(){ System.out.println(\u0026#34;结婚之后，收尾款\u0026#34;); } } 创建测试类StaticProxy\npackage com.polymorphic; public class StaticProxy { public static void main(String[] args) { Marry marry = new WeddingCompany(new Customer()); marry.HoldWedding(); } } 运行结果\n  总结\n 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 代理对象可以做很多真实对象做不了的事情 真实对象可以专注自己的事情    而在通过Runnable接口创建线程时，启动线程需要借助Thread类，这里就涉及到了静态代理模式。\nMarry marry = new WeddingCompany(new Customer()); marry.HoldWedding(); //如果我们把上述代码简写一下 new WeddingCompany(new Customer()).HoldWedding(); //对照Runnable接口创建线程时，启动线程的方法 new Thread(new TestThread()).start(); 可以发现上面代码块的第四行与第六行有异曲同声的美妙！\n  代理对象的优点与缺点\n 优点：在不修改目标对象的功能的前提下，能通过代理对象对目标功能扩展 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。一旦接口增加方法，目标对象和代理对象都需要维护    动态代理模式 动态代理的作用非常大，在很多底层框架中都会用得到，比如struts，Spring等都用到了动态代理，它的作用很简单，就是将你要使用的类，重新生成一个子类或本类，这样框架就可以利用这个新生成的类做一些事情，比如在该类的方法前后加一些代码。。 这样的话，你想像一下，你是不是不用修改任何已经编写好的代码，只要使用代理就可以灵活的加入任何东西，将来不喜欢了，不用也不会影响原来的代码。\n  动态代理模式的基本介绍\n 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 代理对象的生产，是利用JDK的API，动态的在内存中构建代理对象 动态代理也叫做：JDK代理、接口代理    动态代理模式原理图\n getProxyInstance():\n 根据传入的对象（TeacherDao）即目标对象； 利用反射机制，返回一个代理对象； 然后通过代理对象，调用目标对象的方法     JDK中生成动态代理对象的API\n  代理类所在包：java.lang.refelect.Proxy\n  JDK 实现代理只需要使用 newProxyInstance 方法,但是该方法需要接收三个参数,完整的写法是:\npublic static Object newProxyInstance(ClassLoader loader,Class\u0026lt;?\u0026gt;[] interfaces,InvocationHandler h) 上述方法中\n ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法是固定的 Class\u0026lt;?\u0026gt;[] interfaces：目标对象实现的接口类型，使用泛型方式确认类型 InvocationHandler h：事件处理，执行目标对象方法时，会触发事件处理器的方法，会把当前执行的目标对象方法作为参数传入      动态代理模式应用实例\n代码演示：\n创建接口ITeacherDao\npackage com.proxy.dynamic; /** * @Author: minster * @Date: 2021/9/23 16:43 */ public interface ITeacherDao { void teach(); void say(String name); } 创建接口实现类TeacherDao\npackage com.proxy.dynamic; /** * @Author: minster * @Date: 2021/9/23 16:45 */ public class TeacherDao implements ITeacherDao{ @Override public void teach() { System.out.println(\u0026#34;teacher 上课了！\u0026#34;); } @Override public void say(String name) { System.out.println(\u0026#34;hello \u0026#34; + name); } } 创建代理工厂类ProxyFactory\npackage com.proxy.dynamic; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * @Author: minster * @Date: 2021/9/23 16:45 */ public class ProxyFactory { //维护一个目标对象target  private Object target; //构造器：对target进行初始化  ProxyFactory(Object target){ this.target = target; } //给目标对象生成一个代理对象  public Object getProxyInstance(){ return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;JDK代理开始了\u0026#34;); //反射机制调用目标对象的方法  Object invoke = method.invoke(target,args); System.out.println(\u0026#34;JDK代理提交了\u0026#34;); return invoke; } }); } } 被代理类Cilent\npackage com.proxy.dynamic; /** * @Author: minster * @Date: 2021/9/23 16:52 */ public class Client { public static void main(String[] args) { //创建目标对象  ITeacherDao target = new TeacherDao(); //把目标对象传到代理对象里面，创建代理对象，并且把类型转为ITercherDao  ProxyFactory proxyFactory = new ProxyFactory(target); ITeacherDao proxyInstance =(ITeacherDao) proxyFactory.getProxyInstance(); //通过代理对象，调用目标对象的方法  proxyInstance.teach(); proxyInstance.say(\u0026#34;minster\u0026#34;); } } 运行结果：\n  Cglib代理   基本介绍\n 静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 Cglib 代理 Cglib 代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib 代理归属到动态代理。 Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的框架使用,例如 Spring AOP，实现方法拦截 在 AOP 编程中如何选择代理模式：  目标对象需要实现接口，用 JDK 代理 目标对象不需要实现接口，用 Cglib 代理   Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类    Cglib代理实现步骤\n  导入Cglib的jar包\n  在内存中动态构建子类，注意代理的类不能为 final，否则报错java.lang.IllegalArgumentException:\n  目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.\n    Cglib实现类图\n ProxyFactory类主要完成了\n getInstance()给目标对象target创建一个代理对象 重写intecept方法，实现对被代理对象（目标对象）方法的调用     代码实现\n创建被代理对象的类TeacherDao02\npackage com.proxy.cglib; /** * @Author: minster * @Date: 2021/9/24 8:54 */ public class TeacherDao02 { public String name = \u0026#34;jack\u0026#34;; public void teach(){ System.out.println(\u0026#34;cglib代理 老师上课了！\u0026#34;); } public void say(String name){ System.out.println(\u0026#34;hello \u0026#34; + name); } } 创建代理类ProxyFactory02\npackage com.proxy.cglib; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; /** * @Author: minster * @Date: 2021/9/24 8:55 */ public class ProxyFactory02 implements MethodInterceptor { //维护一个目标对象  private Object target; //构造器，传入一个被代理对象  public ProxyFactory02(Object target) { this.target = target; } //使用cglib的工具类返回一个代理对象（target对象的代理对象）  public Object getProxyInstance(){ //1. 创建工具类  Enhancer enhancer = new Enhancer(); //2. 设置父类  enhancer.setSuperclass(target.getClass()); //3. 设置回调函数  enhancer.setCallback(this); //4. 创建子类对象，即代理对象  return enhancer.create(); } //重写intercept方法，会调用目标对象（被代理对象的方法）  @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;Cglib代理开始了\u0026#34;); Object returnVal = method.invoke(target, args); System.out.println(\u0026#34;Cglib代理提交了\u0026#34;); return null; } } 创建Client类\npackage com.proxy.cglib; /** * @Author: minster * @Date: 2021/9/24 9:12 */ public class Client02 { public static void main(String[] args) { //1. 创建目标对象  TeacherDao02 teacherDao02 = new TeacherDao02(); //2. 把目标对象传递给代理对象  TeacherDao02 proxyInstance = (TeacherDao02) new ProxyFactory02(teacherDao02).getProxyInstance(); proxyInstance.teach(); System.out.println(\u0026#34;=============\u0026#34;); proxyInstance.say(\u0026#34;minster\u0026#34;); } } 运行结果\n 使用Cglib代理时，代理对象是通过Cglib包的方法拦截器MethodInterceptor中的拦截方法intercept实现的！\n   代理模式的几种变体   防火墙代理 内网通过代理穿透防火墙，实现对公网的访问。\n  缓存代理 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。\n  远程代理 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。\n  同步代理\n主要使用在多线程编程中，完成多线程间同步工作同步代理：主要使用在多线程编程中，完成多线程间同步工作\n    正向代理\n正向代理：如科学上网，隐藏客户端信息\n其实，正向与反向是对于我们的客户端来说的，我们要上网，如果它帮我们去上网，那它就是一个正向代理；如果它帮我们的对方服务器，那它就是一个反向代理。 比如上网，我们想要访问谷歌，如果访问不上，那么我们可以搭建一台正向代理服务器，去购买网上的代理服务器，我们为客户端电脑配置上代理服务器的地址，以后电脑想要访问所有的网址，都会由代理服务器帮我们去访问，访问拿到内容以后再帮我们返回。 所以我们看到的是，我们自己搭建的服务器是帮我们进行上网，这个就是正向代理。 如果我们使用了正向代理，由于我们的请求是发给我们的代理服务器，由代理服务器转给我们的整个互联网，所以互联网上看到的所有的访问的ip地址都是来源于代理服务器的ip，这就隐藏了客户端地址信息\n  反向代理\n反向代理在我们搭建集群环境的时候非常重要。 比如有人访问我们的商城，我们的商城有我们的后台服务集群，这个集群的每一个服务器我们都可能要在内网部署，这是一个内网ip，不可能把每一个服务器的外网ip暴露给外界，这样容易引起攻击。那我们为了别人能够找到我们的内网集群，我们就可以在集群的前面前置一个服务器，这个服务器就叫反向代理。 比如我们前置一个nginx，这个nginx是拥有公网ip的，大家都可以进行访问，无论你在中国还是美国我们都可以来进行访问。但是如果我们去访问我们这个公网的服务器，它会代转给我们的服务集群。它相当于对外界屏蔽了我们整个内网服务集群的信息。\n  ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"Java静态代理模式"},{"content":"代理模式   代理模式基本介绍\n  代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的**好处是：**可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能\n  被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象\n  代理模式有不同的形式，主要有三种静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴的）。\n  代理模式示意图\n    静态代理模式  间接的“美” 中国人是一个含蓄的民族，讲究微妙和间接的交流方式。对象间的间接通信也同样是面向对象设计中一条重要的审美观。间接性的通信可以给出较低的耦合关系，较强的合作关系，以及微妙的结构和易于复用的设计架构。 \u0026mdash;-\u0026laquo;Java与模式\u0026raquo;\n   代理模式的定义\n​\t代理模式的英文叫Proxy或Surrogate。所谓代理就是指一个人或者一个机构代表另一个人或者另一个机构行动。有一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。\n  意图\n​\t为其他对象提供一种代理以控制对这个对象的访问。\n  代理模式的结构\n 抽象主题角色（接口）：声明了正是主题和代理主题的共同接口。这样一来任何使用真是主题的地方都可以使用代理主题。 代理主题（Peoxy）角色（代理类）：代理主题角色内部含有一个对真实主题角色的引用。从而可以在任何时候操作真实主体对象；代理主题角色提供一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题；控制对真实主题的引用，负责在需要的时候创建真实主题对象（或删除真实主题对象）；代理主题通常在客户端调用真实主题之前或之后都要执行某个操作，而不是单纯将调用传给真实主题。 真实主题角色（被代理类）：定义了代理角色所代表的真实对象。    静态代理\n​\t由程序员创建或特定工具自动生成源码，也就是说在编译时就已经将接口，被代理类，代理类等确定了下来。在程序运行之前，代理类的.class文件就已经生成。\n  静态代理简单实现\n​\t假设现在jack要结婚，jack把他的婚礼包办给了婚礼公司，在这个案例中，我们可以知道抽象主题角色便是婚礼（结婚），然后代理主题角色是婚礼公司，真实主题角色是jack。\n​\t首先，我们创建一个Marry接口。这个接口就是jack（被代理类）和婚礼公司（代理类）的公共接口，他们都有举办婚礼的行为。这样，jack的婚礼就可以让婚礼公司来代理执行。\n创建接口Marry\ninterface Marry{ void HoldWedding(); } 创建被代理类Customer\nclass Customer implements Marry{ @Override public void HoldWedding() { System.out.println(\u0026#34;我是jack，我结婚了！\u0026#34;); } } 创建代理类WeddingCompany\nclass WeddingCompany implements Marry{ private Customer customer; public WeddingCompany(Customer customer){ this.customer = customer; } @Override public void HoldWedding() { before(); this.customer.HoldWedding(); after(); } private void before() { System.out.println(\u0026#34;结婚之前，布置场地\u0026#34;); } private void after(){ System.out.println(\u0026#34;结婚之后，收尾款\u0026#34;); } } 创建测试类StaticProxy\npackage com.polymorphic; public class StaticProxy { public static void main(String[] args) { Marry marry = new WeddingCompany(new Customer()); marry.HoldWedding(); } } 运行结果\n  总结\n 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 代理对象可以做很多真实对象做不了的事情 真实对象可以专注自己的事情    而在通过Runnable接口创建线程时，启动线程需要借助Thread类，这里就涉及到了静态代理模式。\nMarry marry = new WeddingCompany(new Customer()); marry.HoldWedding(); //如果我们把上述代码简写一下 new WeddingCompany(new Customer()).HoldWedding(); //对照Runnable接口创建线程时，启动线程的方法 new Thread(new TestThread()).start(); 可以发现上面代码块的第四行与第六行有异曲同声的美妙！\n  代理对象的优点与缺点\n 优点：在不修改目标对象的功能的前提下，能通过代理对象对目标功能扩展 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。一旦接口增加方法，目标对象和代理对象都需要维护    动态代理模式 动态代理的作用非常大，在很多底层框架中都会用得到，比如struts，Spring等都用到了动态代理，它的作用很简单，就是将你要使用的类，重新生成一个子类或本类，这样框架就可以利用这个新生成的类做一些事情，比如在该类的方法前后加一些代码。。 这样的话，你想像一下，你是不是不用修改任何已经编写好的代码，只要使用代理就可以灵活的加入任何东西，将来不喜欢了，不用也不会影响原来的代码。\n  动态代理模式的基本介绍\n 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 代理对象的生产，是利用JDK的API，动态的在内存中构建代理对象 动态代理也叫做：JDK代理、接口代理    动态代理模式原理图\n getProxyInstance():\n 根据传入的对象（TeacherDao）即目标对象； 利用反射机制，返回一个代理对象； 然后通过代理对象，调用目标对象的方法     JDK中生成动态代理对象的API\n  代理类所在包：java.lang.refelect.Proxy\n  JDK 实现代理只需要使用 newProxyInstance 方法,但是该方法需要接收三个参数,完整的写法是:\npublic static Object newProxyInstance(ClassLoader loader,Class\u0026lt;?\u0026gt;[] interfaces,InvocationHandler h) 上述方法中\n ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法是固定的 Class\u0026lt;?\u0026gt;[] interfaces：目标对象实现的接口类型，使用泛型方式确认类型 InvocationHandler h：事件处理，执行目标对象方法时，会触发事件处理器的方法，会把当前执行的目标对象方法作为参数传入      动态代理模式应用实例\n代码演示：\n创建接口ITeacherDao\npackage com.proxy.dynamic; /** * @Author: minster * @Date: 2021/9/23 16:43 */ public interface ITeacherDao { void teach(); void say(String name); } 创建接口实现类TeacherDao\npackage com.proxy.dynamic; /** * @Author: minster * @Date: 2021/9/23 16:45 */ public class TeacherDao implements ITeacherDao{ @Override public void teach() { System.out.println(\u0026#34;teacher 上课了！\u0026#34;); } @Override public void say(String name) { System.out.println(\u0026#34;hello \u0026#34; + name); } } 创建代理工厂类ProxyFactory\npackage com.proxy.dynamic; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * @Author: minster * @Date: 2021/9/23 16:45 */ public class ProxyFactory { //维护一个目标对象target  private Object target; //构造器：对target进行初始化  ProxyFactory(Object target){ this.target = target; } //给目标对象生成一个代理对象  public Object getProxyInstance(){ return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;JDK代理开始了\u0026#34;); //反射机制调用目标对象的方法  Object invoke = method.invoke(target,args); System.out.println(\u0026#34;JDK代理提交了\u0026#34;); return invoke; } }); } } 被代理类Cilent\npackage com.proxy.dynamic; /** * @Author: minster * @Date: 2021/9/23 16:52 */ public class Client { public static void main(String[] args) { //创建目标对象  ITeacherDao target = new TeacherDao(); //把目标对象传到代理对象里面，创建代理对象，并且把类型转为ITercherDao  ProxyFactory proxyFactory = new ProxyFactory(target); ITeacherDao proxyInstance =(ITeacherDao) proxyFactory.getProxyInstance(); //通过代理对象，调用目标对象的方法  proxyInstance.teach(); proxyInstance.say(\u0026#34;minster\u0026#34;); } } 运行结果：\n  Cglib代理   基本介绍\n 静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 Cglib 代理 Cglib 代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib 代理归属到动态代理。 Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的框架使用,例如 Spring AOP，实现方法拦截 在 AOP 编程中如何选择代理模式：  目标对象需要实现接口，用 JDK 代理 目标对象不需要实现接口，用 Cglib 代理   Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类    Cglib代理实现步骤\n  导入Cglib的jar包\n  在内存中动态构建子类，注意代理的类不能为 final，否则报错java.lang.IllegalArgumentException:\n  目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.\n    Cglib实现类图\n ProxyFactory类主要完成了\n getInstance()给目标对象target创建一个代理对象 重写intecept方法，实现对被代理对象（目标对象）方法的调用     代码实现\n创建被代理对象的类TeacherDao02\npackage com.proxy.cglib; /** * @Author: minster * @Date: 2021/9/24 8:54 */ public class TeacherDao02 { public String name = \u0026#34;jack\u0026#34;; public void teach(){ System.out.println(\u0026#34;cglib代理 老师上课了！\u0026#34;); } public void say(String name){ System.out.println(\u0026#34;hello \u0026#34; + name); } } 创建代理类ProxyFactory02\npackage com.proxy.cglib; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; /** * @Author: minster * @Date: 2021/9/24 8:55 */ public class ProxyFactory02 implements MethodInterceptor { //维护一个目标对象  private Object target; //构造器，传入一个被代理对象  public ProxyFactory02(Object target) { this.target = target; } //使用cglib的工具类返回一个代理对象（target对象的代理对象）  public Object getProxyInstance(){ //1. 创建工具类  Enhancer enhancer = new Enhancer(); //2. 设置父类  enhancer.setSuperclass(target.getClass()); //3. 设置回调函数  enhancer.setCallback(this); //4. 创建子类对象，即代理对象  return enhancer.create(); } //重写intercept方法，会调用目标对象（被代理对象的方法）  @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;Cglib代理开始了\u0026#34;); Object returnVal = method.invoke(target, args); System.out.println(\u0026#34;Cglib代理提交了\u0026#34;); return null; } } 创建Client类\npackage com.proxy.cglib; /** * @Author: minster * @Date: 2021/9/24 9:12 */ public class Client02 { public static void main(String[] args) { //1. 创建目标对象  TeacherDao02 teacherDao02 = new TeacherDao02(); //2. 把目标对象传递给代理对象  TeacherDao02 proxyInstance = (TeacherDao02) new ProxyFactory02(teacherDao02).getProxyInstance(); proxyInstance.teach(); System.out.println(\u0026#34;=============\u0026#34;); proxyInstance.say(\u0026#34;minster\u0026#34;); } } 运行结果\n 使用Cglib代理时，代理对象是通过Cglib包的方法拦截器MethodInterceptor中的拦截方法intercept实现的！\n   代理模式的几种变体   防火墙代理 内网通过代理穿透防火墙，实现对公网的访问。\n  缓存代理 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。\n  远程代理 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。\n  同步代理\n主要使用在多线程编程中，完成多线程间同步工作同步代理：主要使用在多线程编程中，完成多线程间同步工作\n    正向代理\n正向代理：如科学上网，隐藏客户端信息\n其实，正向与反向是对于我们的客户端来说的，我们要上网，如果它帮我们去上网，那它就是一个正向代理；如果它帮我们的对方服务器，那它就是一个反向代理。 比如上网，我们想要访问谷歌，如果访问不上，那么我们可以搭建一台正向代理服务器，去购买网上的代理服务器，我们为客户端电脑配置上代理服务器的地址，以后电脑想要访问所有的网址，都会由代理服务器帮我们去访问，访问拿到内容以后再帮我们返回。 所以我们看到的是，我们自己搭建的服务器是帮我们进行上网，这个就是正向代理。 如果我们使用了正向代理，由于我们的请求是发给我们的代理服务器，由代理服务器转给我们的整个互联网，所以互联网上看到的所有的访问的ip地址都是来源于代理服务器的ip，这就隐藏了客户端地址信息\n  反向代理\n反向代理在我们搭建集群环境的时候非常重要。 比如有人访问我们的商城，我们的商城有我们的后台服务集群，这个集群的每一个服务器我们都可能要在内网部署，这是一个内网ip，不可能把每一个服务器的外网ip暴露给外界，这样容易引起攻击。那我们为了别人能够找到我们的内网集群，我们就可以在集群的前面前置一个服务器，这个服务器就叫反向代理。 比如我们前置一个nginx，这个nginx是拥有公网ip的，大家都可以进行访问，无论你在中国还是美国我们都可以来进行访问。但是如果我们去访问我们这个公网的服务器，它会代转给我们的服务集群。它相当于对外界屏蔽了我们整个内网服务集群的信息。\n  ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"Java静态代理模式"},{"content":"MySQL（一）   MySQL的基本介绍 MySQL的基本使用 增删改查 约束   MySQL的基本介绍   sql、DB、DBMS分别是什么，他们之间的关系？\nDB：DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）\nDBMS：DataBase Management System（数据库管理系统，常见的有：MySQL、Oracle、DB2、Sybase、SqlServer\u0026hellip;）\nSQL：结构化查询语言，是一门标准通用的语言。标准的SQL适合于所有的数据库产品。SQL属于高级语言。SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DNMS完成）\n DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据\n   什么是表？\n  表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。\n  一个表包括行和列：\n 行：被称为数据/记录（data） 列：被称为字段（column）每一个字段包括字段名、数据类型、相关的约束      学习MySQL主要还是学习通用的SQL语句，那么SQL语句包括增删改查，SQL语句怎么分类？\n DQL（数据查询语言）：查询语句，凡是select语句都是DQL。 DML（数据操作语言）：insert(增加)、delete(删除)、update(修改)，对表当中数据进行增删改。 DDL（数据定义语言）：create(增加)、drop(删除)、alter(修改) ，对表结构的增删改。 TCL（事务控制语言）：commit提交事务、rollback回滚事务 DCL（数据控制语言）：grant授权、revoke撤销权限等。    当因为sql脚本中的数据量太大的而无法打开的时候，可以使用source。\n  MySQL的基本使用 MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格：\n 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\\物的方法, 键的值在当前列中具有唯一性。  登录数据库 mysql-h127.0.0.1-u用户名-pmysql-D所选择的数据库名-h主机名-u用户名-pmysql\u0026gt;exit# 退出 使用 “quit;” 或 “\\q;” 一样的效果 mysql\u0026gt;status;# 显示当前mysql的version的各种信息 mysql\u0026gt;selectversion();# 显示当前mysql的version信息 mysql\u0026gt;showglobalvariableslike\u0026#39;port\u0026#39;;# 查看MySQL端口号 创建数据库 对于表的操作需要先进入库use 库名;\n-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbk createdatabasesamp_dbcharactersetgbk;dropdatabasesamp_db;-- 删除 库名为samp_db的库 showdatabases;-- 显示数据库列表。 usesamp_db;-- 选择创建的数据库samp_db showtables;-- 显示samp_db下面所有的表名字 describe表名;-- 显示数据表的结构(缩写为desc) deletefrom表名;-- 清空表中记录 创建数据库表  使用 create table 语句可完成对表的创建, create table 的常见形式: 语法：create table 表名称(列声明);\n -- 如果数据库中存在user_accounts表，就把它从数据库中drop掉 DROPTABLEIFEXISTS`user_accounts`;CREATETABLE`user_accounts`(`id`int(100)unsignedNOTNULLAUTO_INCREMENTprimarykey,`password`varchar(32)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;用户密码\u0026#39;,`reset_password`tinyint(32)NOTNULLDEFAULT0COMMENT\u0026#39;用户类型：0－不需要重置密码；1-需要重置密码\u0026#39;,`mobile`varchar(20)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;手机\u0026#39;,`create_at`timestamp(6)NOTNULLDEFAULTCURRENT_TIMESTAMP(6),`update_at`timestamp(6)NOTNULLDEFAULTCURRENT_TIMESTAMP(6)ONUPDATECURRENT_TIMESTAMP(6),-- 创建唯一索引，不允许重复 UNIQUEINDEXidx_user_mobile(`mobile`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT=\u0026#39;用户表信息\u0026#39;;数据类型的属性解释\n NULL：数据列可包含NULL值； NOT NULL：数据列不允许包含NULL值； DEFAULT：默认值； PRIMARY：KEY 主键； AUTO_INCREMENT：自动递增，适用于整数类型； UNSIGNED：是指数值类型只能为正数； CHARACTER SET name：指定一个字符集； COMMENT：对表或者字段说明；  需要注意的是，创建的时候字段名字需要用**``**来标记，而非**‘ ’**\n增删改查 SELECT  SELECT 语句用于从表中选取数据。 语法：SELECT 列名称 FROM 表名称 语法：SELECT * FROM 表名称\n 单表查询   简单查询\n-- 查看当前数据库版本 selectversion();-- 查看当前使用的是哪个数据库 selectdatabase();-- 查询单个字段 select字段名from表名；-- 查询多个字段（使用逗号隔开） selectdeptno,dnameformdept;-- 查询所有字段 select*fromdept;-- 实际开发中不建议； selecta,b,c,d...fromdept;-- 给查询的列起别名，as关键字可以省略 SELECTdeptno,dnameASdeptnameFROMdept;SELECTdeptno,dnamedeptnameFROMdept;-- 倘若别名中有空格，则用单引号括起来 SELECTdeptno,dname\u0026#39;dept name\u0026#39;FROMdept;-- 字段可以使用数学表达式！ SELECTename,sal*12ASyearsalFROMemp;  条件查询\n不是将表中所有数据都查出来。是查询出来符合条件的。\n-- 语法格式： select字段1,字段2,字段3....from表名where条件;-- = 等 SELECTempno,enameFROMempWHEREsal=800;-- !=或\u0026lt;\u0026gt;不等于 SELECTename,empnoFROMempWHEREsal!=800;SELECTename,empnoFROMempWHEREsal\u0026lt;\u0026gt;800;-- \u0026lt; 小于 \u0026gt; 大于 \u0026lt;= 小于等于 \u0026gt;= 大于等于 SELECTename,empnoFROMempWHEREsal\u0026lt;2000;SELECTename,empnoFROMempWHEREsal\u0026lt;=2000;SELECTename,empnoFROMempWHEREsal\u0026gt;2000;SELECTename,empnoFROMempWHEREsal\u0026gt;=2000;-- between ... and ...,查询两个值之间 使用between...and... 必须左小右大，且为闭区间！ SELECTename,empno,salFROMempWHEREsalBETWEEN2450AND3000;-- 等价于 SELECTename,empno,salFROMempWHEREsal\u0026gt;=2450ANDsal\u0026lt;=3000;-- is null 为 null（is not null 不为空）在数据库中null不能使用=衡量！ SELECTename,empno,salcommFROMempWHEREcommISNULL;SELECTename,empno,salcommFROMempWHEREcommISNOTNULL;-- AND-\u0026gt;并且 OR-\u0026gt;或者 AND的优先级高于OR。如需OR先执行，需要加小括号 SELECT*FROMempWHEREsal\u0026gt;2500AND(deptno=10ORdeptno=20);-- IN 包含相当于多个OR。NOT IN 不包含 SELECTempno,ename,jobFROMempWHEREJOBIN(\u0026#39;MANAGER\u0026#39;,\u0026#39;SALESMAN\u0026#39;);like 称为模糊查询，支持%或下划线匹配\n %匹配任意多个字符 下划线：任意一个字符。（%是一个特殊的符号，_ 也是一个特殊符号）  -- 找出含有O的名字 SELECTenameFROMempWHEREenameLIKE\u0026#39;%O%\u0026#39;;-- 找出第二个字母为O的名字 SELECTenameFROMempWHEREenameLIKE\u0026#39;_O%\u0026#39;;-- 找出名字中含有下划线的 用\\转义 SELECTenameFROMempWHEREenameLIKE\u0026#39;%\\_%\u0026#39;;  排序查询\n ORDER BY : 升序排序，默认\nORDER BY \u0026hellip; desc;：指定降序排序\nORDER BY \u0026hellip; asc;：指定升序排序\n -- 默认排序查询 SELECTename,salFROMempORDERBYsal;-- 指定降序排序 SELECTename,salFROMempORDERBYsaldesc;-- 指定升序排序 SELECTename,salFROMempORDERBYsalasc;-- 按多个字段进行排序 SELECTename,salFROMempORDERBYsalasc,enamedesc;-- sal在前，起主导，只有当sal相等时才会启用ename比较 综合案例：找出工资在1250到3000之间的员工信息，要求按照薪资降序排列。\nSELECT*FROMempWHEREsalBETWEEN1250AND3000ORDERBYsalDESC; 以上执行顺序必须掌握！排序总是在最后！\n   数据处理函数\n  数据处理函数又被称为单行处理函数\n  单行处理函数的特点：一个输入对应一个输出。\n  和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）\n    常见的单行处理函数\n  Lower\t转换小写\nSELECTLOWER(ename)ASenameFROMemp;  upper\t转换大写\nSELECTUPPER(ename)ASenameFROMemp;  substr\t取子串（substr(被截取的字符串,起始下标(从1开始),截取的长度)）\nSELECTSUBSTR(ename,1,1)ASenameFROMemp;  length\t取长度\nSELECTLENGTH(ename)enamelengthFROMemp;  trim\t去空格,可以去前后空白\nSELECT*FROMempWHEREename=trim(\u0026#39; KING\u0026#39;)  str_to_date\t将字符串转换成日期\n  date_format\t格式化日期\n  format\t设置千分位\n  round\t四舍五入\n-- 生成100以内的随机整数 SELECTROUND(RAND()*100,0)FROMemp;  rand()\t生成随机数\nSELECTRAND()FROMemp;  Ifnull\t可以将null转换成一个具体值\n ifnull是空处理函数，专门处理null的。 在所有的数据库中，null只要参与运算，最终结果一定是null。\n需要使用ifnull函数处理，用法：\nifnull(数据，替换值)\n -- 计算年薪的时候，把补贴为null的值替换成0，这样子就可以避免最后算出来的年薪为null SELECTename,(sal+IFNULL(comm,0))*12ASyearsalFROMemp;  concat函数进行字符串的拼接\nSELECTCONCAT(ename,empno)FROMemp;  case..when..then..when..then..else..end\n当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常。 （注意：不修改数据库，只是将查询结果显示为工资上调）\nSELECTename,job,salASoldsal,(CASEJOBWHEN\u0026#39;MANAGER\u0026#39;THENsal*1.1WHEN\u0026#39;SALESMAN\u0026#39;THENsal*1.5ELSEsalEND)ASnewsalFROMemp;      分组函数（多行处理函数）\n 分组函数在使用时必须进行分组才能使用。 如果没有对数据进行分组，那么整张表就会默认为一组    count 计数\nSELECTCOUNT(sal)FROMemp;  sum 求和\nSELECTSUM(sal)FROMemp;  avg 平均值\nSELECTavg(sal)FROMemp;  max 最大值\nSELECTMAX(sal)FROMemp;  min 最小值\nSELECTMIN(sal)FROMemp;    分组函数需要注意的点：\n  分组函数自动处理null，使用时不需要对null进行处理\nSELECTCOUNT(comm)AScommFROMemp;  count(具体字段)：表示统计该字段下所有不为null的元素总数\n  count * ：统计表当中的总行数。只要有一行数据count就++。\n  分组函数不能直接使用在where子句中。\n  所有分组函数都可以组合起来用。\n      分组查询\n sql语句各关键字的执行顺序：FROM-\u0026gt;WHERE-\u0026gt;GROUP BY-\u0026gt;SELECT-\u0026gt;ORDER BY\n ​\t由上面的执行顺序，我们可以知道为什么分组函数不能直接使用在where子句中；因为sql语句在执行的时候，select在group by后面，所以**SELECT MIN(sal) FROM emp;可以正常执行，但SELECT ename FROM emp WHERE sal \u0026gt;(sal);（WHERE在group by前面，还没分组）**却会报错。\n-- 找出每个工作岗位的工资和 SELECTSUM(sal)FROMempGROUPBYJOB; ​\t在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数！其他字段或函数一律不能写在select后面\n 使用Having可以对分完组之后的数据做进一步的过滤（having与group by配套使用）\n-- 找出每个部门最高薪资，要求显示最高薪资大于3000的 SELECTdeptno,MAX(sal)FROMempGROUPBYdeptnoHAVINGMAX(sal)\u0026gt;3000;优化策略：where与having都可以解决的问题，优先使用where\nSELECTdeptno,MAX(sal)FROMempWHEREsal\u0026gt;3000GROUPBYdeptno;这样子可以先选出符合要求的数据再进行分组，优化了执行效率。\n不能使用where的情况\n-- 找出每个部门平均薪资，要求显示平均薪资高于2500的SELECT deptno,AVG(sal)FROM empGROUP BY deptnoHAVING AVG(sal)\u0026gt;2500; 因为上述要求的是平均薪资，即为AVG(sal)，而where后面不能跟分组函数，所以where无法解决上述问题，只能使用having\n  单表查询总结\n当我们需要从某张表中查询数据，需要先经过where条件筛选出有价值的数据，再对这些有价值的数据进行分组。分组之后可以使用having 继续筛选，然后select查询出来，最后排序输出。\n练习：找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，要求按照平均薪资降序排序。\nSELECTjob,AVG(sal)ASavgsalFROMempWHEREjob!=\u0026#39;MANAGER\u0026#39;GROUPBYjobHAVINGavgsal\u0026gt;1500ORDERBYavgsalDESC;  DISTINCT关键字\n DISTINCT关键字可以把查询结果去除重复的记录（原表数据不会被修改）。\n   作用于单列\n-- 查询工作岗位类型 selectDISTINCTjobFROMemp;  作用于多列\nSELECTDISTINCTdeptno,jobFROMemp;上述语句是同时作用在**“deptno+job”**上面的，实际上是根据**“deptno+job”**实现去重。即同一部门同一岗位的信息去掉。\n  需要注意的是DISTINCT只能出现在所有的字段的最前方。\n  count+distinct使用\n    多表查询   什么是多表查询（连接查询）\n从一张表中单独查询，称为单表查询。 emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。 这种跨表查询，多张表联合起来查询数据，被称为连接查询。\n  连接查询的分类\n  根据语法的年代分类： SQL92：1992年的时候出现的语法 SQL99：1999年的时候出现的语法 我们这里重点学习SQL99.(这个过程中简单演示一个SQL92的例子)\n  根据表连接的方式分类：\n  内连接：\n  等值连接\n-- SQL92语法 SELECTe.ename,d.dnameFROMempe,deptdWHEREe.deptno=d.deptno;-- SQL99语法 SELECTe.ename,d.dnameFROMempe(INNER)JOIN-- INNER可以省略，但带着INNER可读性更好！ deptdONe.deptno=d.deptnoWHERE\u0026#39;筛选条件\u0026#39;; sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。\nsql99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where\n   非等值连接\n条件不是一个等量关系，称为非等值连接。\n-- 找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级 SELECTe.ename,e.sal,s.gradeFROMempeJOINsalgradesONe.salBETWEENs.losalANDs.hisalORDERBYgrade;  自连接\n一张表看作两张表来用\n-- 查询员工的上级领导，要求显示员工名和对应的领导名 SELECTa.enameAS\u0026#39;员工名\u0026#39;,b.enameAS\u0026#39;领导名\u0026#39;FROMempaJOINempbONa.mgr=b.empno;      外连接：\n 外连接就是在内连接的基础上，在JOIN的左边加上一个关键字RIGHT或LEFT。\nRIGHT/LEFT代表什么：表示将join关键字右/左边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左/右边的表。在外连接当中，两张表连接，产生了主次关系。\n   左外连接（左连接）\nSELECTa.enameAS\u0026#39;员工名\u0026#39;,b.enameAS\u0026#39;领导名\u0026#39;FROMempaLEFTJOINempbONa.mgr=b.empno;  右外连接（右连接）\nSELECTa.enameAS\u0026#39;员工名\u0026#39;,b.enameAS\u0026#39;领导名\u0026#39;FROMempaRIGHTJOINempbONa.mgr=b.empno;  全连接（不常用）\n  注意：外连接的查询结果条数一定是大于或等于内连接的查询结果条数\n     当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（笛卡尔发现的，这是一个数学现象。）\n 注意：通过笛卡尔积现象可以得出表的连接次数越多效率越低，所以要尽量避免表的连接次数。\n实现案例：查询每个员工所在部门名称演示多表查询（避免笛卡尔乘积）\nSELECTename,dnameFROMemp,deptWHEREemp.DEPTNO=dept.DEPTNO;给表起别名，优化效率：\n-- SQL92语法 SELECTe.ename,d.dnameFROMempe,deptdWHEREe.deptno=d.deptno;多张表的连接查询\n三张表，四张表怎么连接？\nselect...fromajoinbona和b的连接条件joincona和c的连接条件rightjoindona和d的连接条件一条SQL中内连接和外连接可以混合。都可以出现！\n  子查询\nselect语句中嵌套select语句，被嵌套的select语句称为子查询。\n  子查询可以出现在那些地方\nselect..(select).from..(select).where..(select).  where子句中的子查询\n-- 找出比最低工资高的员工姓名和工资 SELECTename,salFROMempWHERE(SELECTMIN(sal)FROMemp);  from子句中的子查询\n注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。\n案例：找出每个岗位的平均工资的薪资等级\n第一步：先把每个岗位的平均薪资查询出来\nSELECTJOB,AVG(sal)ASavgsalFROMempGROUPBYJOB第二步：把以上的查询结果就当做一张真实存在的表t让t表和s表进行表连接，条件：t表avg(sal) between s.losal and s.hisal;\nSELECTt.*,s.gradeFROM(SELECTJOB,AVG(sal)ASavgsalFROMempGROUPBYJOB)tJOINsalgradesONt.avgsalBETWEENs.`LOSAL`ANDs.`HISAL`;查询结果：\n  select后面出现的子查询\n-- 找出每个员工的部门名称，要求显示员工名，部门名 selecte.ename,e.deptno,(selectd.dnamefromdeptdwheree.deptno=d.deptno)asdnamefromempe;  注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果\n    union合并结果集\n-- 查询工作岗位是MANAGER和SALESMAN的员工 -- 使用表连接查询 SELECTename,jobFROMempWHEREjob=\u0026#39;MANAGER\u0026#39;ORjob=\u0026#39;SALESMAN\u0026#39;;-- 使用union查询 SELECTename,jobFROMempWHEREjob=\u0026#39;MANAGER\u0026#39;UNIONSELECTename,jobFROMempWHEREjob=\u0026#39;SALESMAN\u0026#39;;union的效率要高一些。对于表连接来说，每连接一次新表，每次匹配的次数满足笛卡尔积都会翻倍；但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。\nunion在使用的时候的注意事项：\n union在进行结果集合并的时候，要求两个结果集的列数相同 在MySQL中，允许结果集合并时列和列的数据类型不一致。但Oracle结果集合并时列和列的数据类型要一致。    limit：将查询结果集的一部分取出来。通常使用在分页查询当中。\n分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。\n-- 按照薪资降序，取出排名在第【5-9】名的员工 SELECTename,salFROMempORDERBYsalDESCLIMIT4,5;limit语法：\n 完整用法：limit startIndex, length startIndex是偏移量（起始下标），length是需要取出的数据长度。起始下标从0开始\n省略用法：limit 5；取出0-5个数据\nlimit在order by之后执行\n 在Java中，若我们需要每页显示pageSize条记录，会有下面的公式\n limit (pageNo-1)*pageSize , pageSize;\t其中pageNo是页码\n   DQL语句的执行顺序\n1.from2.where3.groupby4.having5.select6.orderby7.limit..  CREATE   表的创建（建表属于DDL语句，DDL包括：create drop alter）\n语法：\ncreatetable表名(字段名1数据类型,字段名2数据类型,字段名3数据类型);createtable表名(字段名1数据类型,字段名2数据类型,字段名3数据类型);表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。 字段名：见名知意。 表名和字段名都属于标识符。\n  mysql中的数据类型：\n  varchar(最长255)：可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。 优点：节省空间 缺点：需要动态分配空间，速度慢\n  char(最长255)：定长字符串，不管实际的数据长度是多少。分配固定长度的空间去存储数据。使用不恰当的时候，可能会导致空间的浪费。\n优点：不需要动态分配空间，速度快。 缺点：使用不当可能会导致空间的浪费。\n  int(最长11)：数字中的整数型。等同于java的int\n  bigint：数字中的长整型。等同于java中的long。\n  float：单精度浮点型数据\n  double：双精度浮点型数据\n  date：短日期类型\n  datetime：长日期类型\n  clob：字符大对象，最多可以存储4G的字符串。超过255个字符的都要采用CLOB字符大对象来存储。\n  blob：二进制大对象。专门用来存储图片、声音、视频等流媒体数据。\n    创建表与增加数据\n创建表\nCREATETABLEt_student(NOINT,NAMEVARCHAR(32),sexCHAR(1),ageINT(3),emailVARCHAR(255));增加数据\n-- 注意字段名要和值一一对应。即数量对应，数据类型对应。 INSERTINTOt_student(NO,NAME,sex,age,email)VALUES(1,\u0026#39;张三\u0026#39;,\u0026#39;男\u0026#39;,20,\u0026#39;123456@qq.com\u0026#39;);-- 顺序可以不一样 INSERTINTOt_student(email,NAME,sex,age,NO)VALUES(\u0026#39;lisi@123.com\u0026#39;,\u0026#39;lisi\u0026#39;,\u0026#39;f\u0026#39;,20,2);-- INSERT可以添加单个字段。没添加到的字段默认值为null INSERTINTOt_student(NO)VALUES(3);-- 如果添加时省略所有字段名，则说明添加全部字段名 insertintot_studentvalues(4);-- 错误的 insertintot_studentvalues(4,\u0026#39;xiaoming\u0026#39;,\u0026#39;f\u0026#39;,21,\u0026#39;ming@123.com\u0026#39;);-- 需要把其他值也添加上 INSERT添加日期\n-- t_user表中的birth为date属性。 INSERTINTOt_user(id,name,birth)VALUES(1,\u0026#39;jack\u0026#39;,STR_TO_DATE(\u0026#39;01-10-1990\u0026#39;,\u0026#39;%d-%m-%Y\u0026#39;)); str_to_date函数可以将字符串转换成日期类型date。通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，需要通过该函数将字符串转换成date\nmysql的日期格式：%Y -\u0026gt; 年，%m -\u0026gt; 月，%d -\u0026gt; 日，%h -\u0026gt; 时，%i -\u0026gt; 分，%s -\u0026gt; 秒\n -- 这个函数可以将日期类型转换成特定格式的字符串。 selectid,name,date_format(birth,\u0026#39;%Y/%m/%d\u0026#39;)asbirthfromt_user; date_format(日期类型数据, \u0026lsquo;日期格式\u0026rsquo;)；这个函数通常使用在查询日期方面。设置展示的日期格式\n   date和datetime两个类型的区别\n date是短日期：只包括月日信息。mysql短日期默认格式：%Y-%m-%d datetime是长日期：包括年月日时分秒信息。mysql长日期默认格式：%Y-%m-%d %h:%i:%s  now() 函数可以获取系统当前的时间，获取到的信息带有：时分秒信息！是datetime类型的。\n-- 在表t_user中增加一个字段create——time ALTERTABLEt_userADDcreate_timeDATETIME;  INSERT插入多条数据\ninsertintot_user(id,name,birth,create_time)values(1,\u0026#39;zs\u0026#39;,\u0026#39;1980-10-11\u0026#39;,now()),(2,\u0026#39;lisi\u0026#39;,\u0026#39;1981-10-11\u0026#39;,now()),(3,\u0026#39;wangwu\u0026#39;,\u0026#39;1982-10-11\u0026#39;,now());  将查询结果插入到一张表当中\ncreatetabledept_bakasselect*fromdept;insertintodept_bakselect*fromdept;  UPDATE   语法格式：update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3... where 条件;\n注意：没有条件限制会导致所有数据全部更新。\n-- 更新t_user表中id=1的数据 UPDATEt_userSETNAME=\u0026#39;mary\u0026#39;,birth=\u0026#39;2000-10-1\u0026#39;,create_time=NOW()WHEREid=1;  DELETE   删除表中的数据\n语法格式：delete from 表名 where 条件;\n注意：没有条件，整张表的数据会全部删除！\n-- 删除t_user表中 id为2的数据 deletefromt_userwhereid=2;  删除表：\n-- 这不是删除表中的数据，这是把表删除。 droptablet_user;  快速删除表中的数据\n传统删除表中的数据是使用delete语句，其原理如下\n 表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！\n缺点是：删除效率比较低。\n优点是：支持回滚，后悔了可以再恢复数据！！！(使用rollback)\n 快速删除表中的数据使用truncate语句，其原理如下：\n 语法：truncate table dept_bak;\n删除效率比较高，表被一次截断（删除表中的所有数据），物理删除。\n缺点：不支持回滚\n优点：快速删除表中的数据。\n   约束  常见的约束  非空约束，not null 唯一约束，unique 主键约束，primary key 外键约束，foreign key      非空约束（not null）\n非空约束，针对某个字段设置其值不为空，如：学生的姓名不能为空\ndroptableifexistst_student;CREATETABLEt_student(student_idINT(10),student_nameVARCHAR(20)NOTNULL,sexCHAR(2)DEFAULT\u0026#39;m\u0026#39;,birthdayDATE,emailVARCHAR(30),classes_idINT(3));插入数据\ninsertintot_student(student_id,birthday,email,classes_id)values(1002,\u0026#39;1988-01-01\u0026#39;,\u0026#39;qqq@163.com\u0026#39;,10);因为插入的数据没有插入student_name字段的值，所以系统会报错\nnot null只有列级约束，没有表级约束\n  唯一约束（unique）\n唯一性约束，它可以使某个字段的值不能重复，如：email 不能重复。\ndroptableifexistst_student;createtablet_student(student_idint(10),student_namevarchar(20)notnull,-- 非空约束 sexchar(2)default\u0026#39;m\u0026#39;,birthdaydate,emailvarchar(30)unique,-- 唯一约束 classes_idint(3));-- 联合唯一 createtablet_vip(vip_idint,vip_namevarchar(20),unique(vip_id,vip_name));上述联合唯一的unique(vip_id,vip_name)由于约束没有添加在列的后面，所以被称为表级约束。\nunique和not null联合使用\ncreatetablet_vip(idint,namevarchar(20)notnullunique-- 主键字段 );在mysql中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）\n  主键约束（primary key）\n每个表应该具有主键，主键可以标识记录的唯一性，主键分为单一主键和复合（联合）主键，单一主键是由一个字段\n构成的，复合（联合）主键是由多个字段构成的。\n 主键约束：就是一种约束 主键字段：该字段上添加了主键约束，这样的字段叫做主键字段 主键值：：主键字段中的每一个值都叫做主键值（建议使用int，bigint，char；不建议使用varchar）  droptableifexistst_student;createtablet_student(student_idint(10)primarykey,/*列级约束*/student_namevarchar(20)notnull,sexchar(2)default\u0026#39;m\u0026#39;,birthdaydate,emailvarchar(30),classes_idint(3));-- 复合主键 createtablet_vip(vip_idint,vip_namevarchar(20),primarykey(vip_id,vip_name));-- 实际开发中，不建议使用复合主键！ **注意：**每一张表都必须有主键，否则这张表无效。且一张表只能有一个主键\n 自然主键：主键值是一个自然数，和业务没有关系。 业务主键：主键值和业务紧密关联，例如银行卡账号做主键值。这就是业务主键   实际开发中，自然主键使用比较多，因为主键只要做到不重复就行，不需要任何意义。而主键一旦和业务挂钩，那么当业务发生变动的时候可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。\n auto_increment：表示自增，从1开始，以1递增，用于维护主键。\n  外键约束（foreign key）\n外键主要是维护表之间的关系的，主要是为了保证参照完整性，如果表中的某个字段为外键字段，那么该字段的值必须来源于参照的表的主键，如：emp 中的 deptno 值必须来源于 dept 表中的 deptno 字段值。\n 外键约束：就是一种约束 外键字段：该字段上添加了外键约束，这样的字段叫做外键字段 外键值：：外键字段中的每一个值都叫做外键值。外键值可以为null  建立学生和班级表之间的连接：\n首先建立班级表 t_classes\ndroptableifexistst_classes;createtablet_classes(classes_idint(3),classes_namevarchar(40),constraintpk_classes_idprimarykey(classes_id));然后创建表t_student\ndroptableifexistst_student;createtablet_student(student_idint(10),student_namevarchar(20),sexchar(2),birthdaydate,emailvarchar(30),classes_idint(3),constraintstudent_id_pkprimarykey(student_id),constraintfk_classes_idforeignkey(classes_id)referencest_classes(classes_id));注意：t_classes是父表，t_student是子表。\n 外键不一定是主键，但一定要有unique约束\n   ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/mysql%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"MySQL基本介绍与使用"},{"content":"MySQL（二）   存储引擎 事务 索引 备份与还原 视图   存储引擎 ​\t存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）；实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。\n  创建存储引擎\nCREATETABLE`t_student`(`student_id`intNOTNULL,`student_name`varchar(20)DEFAULTNULL,`sex`char(2)DEFAULTNULL,`birthday`dateDEFAULTNULL,`email`varchar(30)DEFAULTNULL,`classes_id`intDEFAULTNULL,PRIMARYKEY(`student_id`),KEY`fk_classes_id`(`classes_id`),CONSTRAINT`fk_classes_id`FOREIGNKEY(`classes_id`)REFERENCES`t_classes`(`classes_id`))ENGINE=InnoDBDEFAULTCHARSET=gbk-- ENGINE=InnoDB就是指定存储引擎 CHARSET是字符集  mysql默认的存储引擎是InnoDB。CHARSET默认的字符集是utf8\n   MySQL有哪些常用的存储引擎\nCMD下使用show engines\\G可以查看MySQL支持的存储引擎\n  MyISAM存储引擎 它管理的表具有以下特征： 使用三个文件表示每个表：\n 格式文件 — 存储表结构的定义（mytable.frm） 数据文件 — 存储表行的内容（mytable.MYD） 索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。 可被转换为压缩、只读表来节省空间   提示一下：对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引。\nMyISAM存储引擎特点：可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！\nMyISAM不支持事务机制，安全性低。\n   InnoDB存储引擎\n 这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。 InnoDB存储引擎最主要的特点是：非常安全。 它管理的表具有下列主要特征：  每个 InnoDB 表在数据库目录中以.frm 格式文件表示 InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名，表空间存储数据+索引。） 提供一组用来记录事务性活动的日志文件 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理 提供全 ACID 兼容 在 MySQL 服务器崩溃后提供自动恢复 多版本（MVCC）和行级锁定 支持外键及引用的完整性，包括级联删除和更新   InnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，不能很好的节省存储空间。    MEMORY存储引擎\n 使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定， 这两个特点使得 MEMORY 存储引擎非常快。 MEMORY 存储引擎管理的表具有下列特征：  在数据库目录内，每个表均以.frm 格式的文件表示。 表数据及索引被存储在内存中。（目的就是快，查询快！） 表级锁机制。 不能包含 TEXT 或 BLOB 字段。   MEMORY 存储引擎以前被称为HEAP 引擎。 MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。 MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。    MyISAM和InnoDB的区别\n​\t在MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。\n​\t虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。\n​\t5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。\n下面是两者的简单对比：\n  是否支持行级锁\nMyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(eow-level locking)和表级锁，默认为行级锁。\n也就是说，MyISAM一锁就锁住了整张表，这在并发写的时候会很蠢！！这也就是为什么InnoDB在并发写的时候，性能更加厉害了。\n  是否支持事务\nMyISAM不提供事务支持\nInnoDB提供事务支持，具有提交(commit)和回滚(rollback)事务的能力\n  是否支持外键\nMyISAM不支持，InnoDB支持\n 一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定\n   是否支持数据库异常崩溃后的安全恢复\nMyISAM不支持，InnoDB支持。\n使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log 。\n  MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是可重复读 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。     是否支持 MVCC\nMyISAM 不支持，而 InnoDB 支持。\n讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。\nMVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。\n      锁机制与InnoDB锁算法\nMyISAM和InnoDB存储引擎使用的锁：\n MyISAM采用表级锁(table-level locking) InnoDB支持行级锁(row-level locking)  表级锁和行级锁对比：\n  表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。\n  行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。\n 锁粒度：所谓加锁粒度就是你要锁住的范围是多大。\n比如你在家上卫生间，你只要锁住卫生间就可以了吧，不需要将整个家都锁起来不让家人进门吧，卫生间就是你的加锁粒度。\n   InnoDB存储引擎的锁的算法有三种：\n Record lock：记录锁，单个行记录上的锁 Gap lock：间隙锁，锁定一个范围，不包括记录本身 Next-key lock：record+gap临键锁，锁定一个范围，包含记录本身    事务   什么是事务？\n事务其实就是一个完整的业务逻辑。\n 一个完整的业务逻辑：假设A向B转账1000；将A账户的钱减去1000；将B账户的钱增加1000。这就是一个完整的业务逻辑\n以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的\n 在本质上，一个事务其实就是多条DML语句同时成功或同时失败。\n  只有DML语句才会有事务，其他语句和事务无关。因为 只有insert、update、delete三个语句是数据库表中数据进行增、删、改的。只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。\n 事务是怎么做到多条DML语句同时成功和同时失败的\nInnoDB存储引擎：提供一组用来记录事务性活动的日志文件\n 在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。\n 在事务的执行过程中，我们可以提交事务，也可以回滚事务。\n演示事务的回滚操作\nmysql\u0026gt;usebjpowernodeDatabasechangedmysql\u0026gt;select*fromdept_bak;Emptyset(0.00sec)-- 开启事务 mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)-- 回滚操作 mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.30sec)mysql\u0026gt;select*fromdept_bak;Emptyset(0.00sec)演示事务的提交操作\nmysql\u0026gt;select*fromdept_bak;Emptyset(0.00sec)-- 开启事务 mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)-- 提交事务 mysql\u0026gt;commit;QueryOK,0rowsaffected(0.07sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)由上面代码测试，我们可以知道\n commit：提交事务 rollback：回滚事务（回滚永远都是只能回滚带上一次的提交点！）   在mysql中，默认情况下是支持自动提交事物的（自动提交！），即没执行一条DML语句，则提交一次。\n这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条\n 使用start transaction可以把mysql的自动提交机制关闭掉\n  事务的三个特性\n 原子性：说明事务是最小的工作单元。不可再分。 一致性：所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。 隔离性：A事务和B事务之间具有一定的隔离。例如教室A和教室B之间有一道墙，这道墙就是隔离性。 持久性：事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上！    事物的隔离级别\n 读未提交：read uncommitted（最低的隔离级别）  事务A可以读取到事务B未提交的数据。 这种隔离级别存在的问题就是：脏读现象！(Dirty Read)；我们称读到了脏数据 这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是读已提交起步   读已提交：read committed  事务A只能读取到事务B提交之后的数据。 这种隔离级别解决了脏读的现象。 这种隔离级别存在不可重复读取数据的问题。 这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。 oracle数据库默认的隔离级别是：read committed   可重复读：repeatable read  事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。 解决了不可重复读取数据。 可重复读会出现幻读。每一次读取到的数据都是幻象。不够真实   序列化/串行化：serializable（最高的隔离级别）  这是最高隔离级别，效率最低。解决了所有的问题。 这种隔离级别表示事务排队，不能并发！与synchronized相似，线程同步（事务同步） 每一次读取到的数据都是最真实的，并且效率是最低的。     InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。\n——摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章\n 设置隔离级别：set global transaction isolation level read uncommitted;\n查看隔离级别：SELECT @@tx_isolation\n  索引   什么是索引\n索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。\n索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，也可以多个字段联合起来添加索引。\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。\n 对于一本字典来说，查找某个汉字有两种方式： 第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。效率比较低。 第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过索引检索，效率较高。\n   索引的底层数据结构\n  索引类型\n  主键索引(Primary Key)\n数据表的主键列使用的就是主键索引。\n一张数据表只能有一个主键，并且主键不能为null，不能重复。\n在Mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。\n  二级索引（辅助索引）\n二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位到主键的位置。\n唯一索引，普通索引，前缀索引等索引属于二级索引。\n 唯一索引(Unique K)：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。**建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率、 普通索引(Index)：普通索引的唯一作用就是快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。 **前缀索引(Prefix)：**前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建议的数据更小，因为只取几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。  二级索引：\n    索引的优缺点\n优点：\n 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  缺点：\n 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。  但是，使用索引一定能提高查询性能吗?\n大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。\n  MySQL的查询方式\n 第一种方式：全表扫描（如果字段没有添加索引就是用全表扫描，效率低） 第二种方式：根据索引检索。   在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。\n遵循左小又大原则存放。采用中序遍历方式遍历取数据。\n   索引的实现原理\n假设现在有一张表t_user\nid(PK)name每一行记录在硬盘上都有物理存储编号------------------------------------------------------------------------ 100\tzhangsan\t0x1111 120lisi0x222299wangwu0x888888zhaoliu0x9999101jack0x666655lucy0x5555130tom0x7777提醒：\n 在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。 在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。 在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）  索引的简单实现原理：存放遵循左小右大原则\n注意：上图只是索引的实现原理的大概模型，事实上索引的实现原理远比上图复杂的多！\n  索引的创建和删除\n创建索引：\n-- 给emp表的ename字段添加索引，起名：emp_ename_index createindexemp_name_indexonemp(ename);删除索引：\n-- 将emp表上的emp_ename_index索引对象删除。 dropindexemp_name_indexonemp;mysql中查看一个SQL语句是否使用了索引检索\nexplainselect*fromempwhereename=\u0026#39;KING\u0026#39;;  需要添加索引的条件。\n 在mysql当中，主键上，以及unique字段上都会自动添加索引的\n  条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同） 条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。 条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）  建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。 建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。\n  索引失效\n  select * from emp where ename like '%T';ename上即使添加了索引，也不会走索引。原因是因为模糊匹配当中以“%”开头了！尽量避免模糊查询的时候以“%”开始。这是一种优化的手段/策略。\nexplainselect*fromempwhereenamelike\u0026#39;%T\u0026#39;;  使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会实现。所以这就是为什么不建议使用or的原因。\nexplainselect*fromempwhereename=\u0026#39;KING\u0026#39;orjob=\u0026#39;MANAGER\u0026#39;;  使用复合索引的时候，没有使用左侧的列查找，索引失效\n 两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。\n createindexemp_job_sal_indexonemp(job,sal);explainselect*fromempwheresal=800;  在where当中索引列参加了运算，索引失效。\ncreateindexemp_sal_indexonemp(sal);explainselect*fromempwheresal+1=800;  在where当中索引列使用了函数\nexplainselect*fromempwherelower(ename)=\u0026#39;smith\u0026#39;;    备份与还原 /* 备份与还原 */------------------ 备份，将数据的结构与表内数据保存起来。 利用mysqldump指令完成。-- 导出 mysqldump[options]db_name[tables]mysqldump[options]---databaseDB1[DB2DB3...]mysqldump[options]--all--database1.导出一张表mysqldump-u用户名-p密码库名表名\u0026gt;文件名(D:/a.sql)2.导出多张表mysqldump-u用户名-p密码库名表1表2表3\u0026gt;文件名(D:/a.sql)3.导出所有表mysqldump-u用户名-p密码库名\u0026gt;文件名(D:/a.sql)4.导出一个库mysqldump-u用户名-p密码--lock-all-tables--database库名\u0026gt;文件名(D:/a.sql)可以-w携带WHERE条件-- 导入 1.在登录mysql的情况下：source备份文件2.在不登录的情况下mysql-u用户名-p密码库名\u0026lt;备份文件视图   什么是视图\n​\t视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表并且在引用视图时动态生成。\n​\t视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n​\t视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n  ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/mysql%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/","title":"MySQL的进阶使用"},{"content":"注解 注解简述   为什么要引入注解\n在使用注解之前，XML被广泛应用于描述元数据，得到各大框架的青睐，它以松耦合的方式完成了框架中几乎所有的配置。但是随着项目越来越庞大，XML的内容也越来越复杂，一些开发人员和架构师发现维护成本变高。他们希望使用一些和代码紧耦合的东西来解决这个问题。于是就有人提出了一种标记式高耦合的配置方式——注解。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。\n 下面我们通过一个例子来理解这两者的区别。\n假如你想为应用设置很多的常量或参数，这种情况下，**【XML】是一个很好的选择，因为它不会同特定的代码耦合。如果你想把某个方法声明为服务，那么使用【注解】会更好一些，因为这种情况下需要注解和方法紧密耦合起来，**开发人员也必须认识到这点。\n同时，【注解】定义了一种标准的描述元数据的方式。\n关于【注解】和【XML】两种不同的配置模式，争论了好多年，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 【XML】 相对于注解则是相反的。追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。目前，许多框架将【XML】和【注解】两种方式结合使用，平衡两者之间的利弊。\n   什么是注解\n注解也叫元数据，即一种描述数据的数据。例如例如我们常见的@Override和@Deprecated。注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。\n在Annotation接口中有下面这句话来描述注解：Annotation 是所有注解继承的公共接口。\nThe common interface extended by all annotation types. 所以，注解的本质就是一个继承了Annotation接口的接口。\n一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。\n而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们先不讨论，而编译器的扫描指的是编译器在对 Java 代码编译成字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。\n@Override public String toString(){ return \u0026#34;Hello Annotation\u0026#34;; } 在上述代码中，我重写了toSting()方法，并使用了@Override注解、但是，即使我不使用@Override注解标记代码，程序也能够正常执行。\n那么，该注解表示什么呢？这样写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法（描述方法的元数据），如果父类中不存在该方法时，编译器会报错，提示该方法并没有重写父类的方法。\n如果我们不小心拼写错误，例如将toString()写成了toStrring()，而且我们也没有使用@Override注解**，此时程序依然能编译运行。但是运行结果会和期望的大不相同。**\n现在我们了解了什么是注解，并且使用注解有助于提高代码的可读性。\n  注解的用途\n 生成文档，通过代码里标识的元数据生成javadoc文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例    注解的分类\n Java自带的标准注解，包括@Override（标明重写某个方法）、@Deprecated（标明某个类或方法过时）和@SuppressWarnings（标明要忽略的警告），使用这些注解后编译器就会进行检查 元注解，元注解是用于定义注解的注解，包括@Retention（标明注解被保留的阶段）、@Target（标明注解使用的范围）、@Inherited（标明注解可继承）、@Documented（标明是否生成javadoc文档） 自定义注解，可以根据自己的需求定义注解    元注解 元注解是用于修饰注解的注解\n元注解有@Retention、@Documented、@Target、@Inherited、@Repeatable五种\n  @Retention\nRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。\n它的取值如下：\n RententionPolicy.SOURCE注解只在源码阶段保留，在编译期进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。如Java内置注解，@Override、@Deprecated、@SuppressWarnning等 RetentionPolicy.RUNTIME 注解可以**保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。**如SpringMvc中的@Controller、@Autowired、@RequestMapping等。    @Documented\n这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。\n  Target\nTarget 是目标的意思，@Target 指定了注解运用的地方（即作用范围）。\n可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。\n类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值\n ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举    @Inherited\nInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类使用了@Inherited 注解，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。\n  @Repeatable\nRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。\nRepeatable使用场景：在需要对同一种注解多次使用时，往往需要借助@Repeatable。\n  下面举例说明一下，在生活中一个人往往是具有多种身份，如果我把每种身份当成一种注解该如何使用\n  先声明一个Persons类用来包含所有的身份\npackage com.annotation_; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @Author: minster * @Date: 2021/10/12 21:13 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Persons { Person[] value(); } 这里@Target是声明Persons注解的作用范围，参数ElementType.Type代表可以给一个类进行注解\n@Retention是注解的有效时间，RetentionPolicy.RUNTIME是指程序运行的时候。\n  然后再声明Person注解，表示一个身份\npackage com.annotation_; import java.lang.annotation.Repeatable; /** * @Author: minster * @Date: 2021/10/12 21:14 */ @Repeatable(Persons.class) public @interface Person { String role() default \u0026#34;\u0026#34;; } @Repeatable括号内的就相当于用来保存该注解内容的容器。\n  然后声明一个Man类，给该类赋予一些身份\npackage com.annotation_; import java.lang.annotation.*; /** * @Author: minster * @Date: 2021/10/12 19:02 */ @Person(role=\u0026#34;CEO\u0026#34;) @Person(role=\u0026#34;husband\u0026#34;) @Person(role=\u0026#34;father\u0026#34;) @Person(role=\u0026#34;son\u0026#34;) public class Man { String name = \u0026#34;\u0026#34;; } 在这里，一个Man可以有多重身份，是CEO、丈夫、父亲、儿子等等。每一个身份我们都使用@Person注解来声明\n  在主方法中访问注解\npackage com.annotation_; import java.lang.annotation.Annotation; /** * @Author: minster * @Date: 2021/10/12 21:16 */ public class Test { public static void main(String[] args) { //获取所有注解  Annotation[] annotations = Man.class.getAnnotations(); //打印获取到的注解的数量，因为只声明了Person一个注解，所以为1  System.out.println(annotations.length); Persons p1 = (Persons) annotations[0]; for (Person person : p1.value()) { System.out.println(person.role()); } } }   注解的特性与使用   注解的属性\n注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation{ int id(); String msg(); } 上面代码定义了 @TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。\n赋值的方式是在注解的括号内以value=\u0026quot;\u0026quot;形式，多个属性之间用,隔开。\n@TestAnnotation(id=3, msg=\u0026#34;hello annotation\u0026#34;) public class Test { }   注解的快捷方式\n所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，**如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。**这可以应用于任何合法类型的元素，记住，这限制了元素名必须为value，简单案例如下\n@Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface IntegerVaule{ int value() default 0; String name() default \u0026#34;\u0026#34;; } public class QuicklyWay { @IntegerVaule(20) public int age; @IntegerVaule(value = 10000, name = \u0026#34;MONEY\u0026#34;) public int money; }   注解不支持继承\n注解是不支持继承的，因此不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口\n  声明注解 这里总共定义了4个注解来演示注解的声明\n  定义一个可以注解在Class，interface，enum上的注解\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnTargetType { /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default \u0026#34;定义在类接口枚举类上的注解元素value的默认值\u0026#34;; }   定义一个可以注解在METHOD上的注解\n@Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnTargetMethod { /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default \u0026#34;定义在方法上的注解元素value的默认值\u0026#34;; }   定义一个可以注解在FIELD上的注解\n@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnTargetField { /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default \u0026#34;定义在字段上的注解元素value的默认值\u0026#34;; }   定义一个可以注解在PARAMETER上的注解\n@Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnTargetParameter { /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default \u0026#34;定义在参数上的注解元素value的默认值\u0026#34;; }   ","date":"2021-09-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/%E6%B3%A8%E8%A7%A3/","title":"注解"},{"content":"索引的底层数据结构 Hash表 哈希表是键值对的集合，通过键（key）即可快速取出对应的值（value），因此哈希表可以快速检索数据（时间复杂度接近O(1)）。\n为何能通过key快速取出value呢？原因在于哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到value对应的index值，找到了index也就找到了对应的value。\nhash = hashfunc(key); index = hash %array_size; 但是！哈希算法会有个Hash冲突问题，也就是说多个不同的key最后得到的index相同。通常情况下，我们会使用链地址法来解决这个问题。链地址法就是将哈希冲突数据存放在链表中。就比如JDK1.8之前HashMap就是通过链地址法来解决哈希冲突的。不过JDK1.8以后HashMap为了减少链表过长的时候搜索时间过长的问题，就引入了红黑树\n为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。\n既然哈希表这么快，为什么MySQL 没有使用其作为索引的数据结构呢？\n1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。\n2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。\n试想一种情况:\nSELECT*FROMtb1WHEREid\u0026lt;500;在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。\nB树\u0026amp;B+树 B树也成B-Tree，全称多路平衡查找树，B+树是B树的一种变体。B树和B+树中的B是Balanced（平衡）的意思\n目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。\nB-Tree B-Tree是为磁盘设备设计的一种平衡查找树。\n系统从磁盘读取数据到内存，是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性取出来，而不是需要什么取什么。\nInnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：\nshowvariableslike\u0026#39;innodb_page_size\u0026#39;;而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\n满足以下条件的，就是B-Tree\n根结点至少有两个子女 每一个结点最多包含K个孩子，K的大小取决于磁盘页的大小。\n模拟查找关键字29的过程：\n根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 在磁盘块8中的关键字列表中找到关键字29。\n​\t分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。\n​\t总结：说到底，B-Tree就是将原先一个结点只能存储一个值的情况，改为一个结点可以存储多个值，因为查找的时候，需要将数据从磁盘中读取到内存里面，一旦磁盘IO次数过多，就会造成查询缓慢，所以这里存储多个值，可以一次性读取相近的值，从而避免查询多次IO，将查询操作放到内存里面。内存执行效率可以忽略不计。\n​\t再简单说，举个例子，数据库有10条数据，id为1,2,3…10，以前要查询第10条，我查询数据库10次，然后for循环到第10条（对应二叉树）；现在不用了，现在我把1,2,3…10直接查出来，放到内存里面，直接从内存里面比较然后拿出来（对应B-Tree）\n​\t缺点： 结点中的数据，不仅存储了key，还存储了value值，而这些数据是存储在页中的，每一页为16KB，页存储的空间是有限的，所以有可能存在，每一个结点，只存储了一个key和value就存不下去了，也就是变成了二叉树的数据结构。深度一样，磁盘IO树也是一样了。所以又衍生出了B+Tree。\nB+Tree B+Tree是B-Tree的一种优化，更适合实现外存储索引结构，InnoDB就是用B+Tree实现索引结构。\n满足以下条件，就是B+Tree\n  非叶子结点，不保存数据，只保存索引；所有的数据都保存在叶子结点中\n  叶子结点中，保存所有数据的信息，及指向含这些元素记录的指针，并且叶子结点本身根据关键字的大小自小而大顺序链接，是一个链表结构。\n  每一个父结点的数据都出现在子结点中，是子结点的最大或最小元素 如查找元素3，B+Tree，因为没有非叶子结点没有存储数据，所以同样大小的磁盘页可以容纳更多的索引。\n  与B-Tree的比较\n 存储结构不一样，单一节点存储更多的元素，使得查询的IO次数更少 查找方式一致，所有查询都要查找到叶子节点，查询性能稳定 所有叶子节点形成有序链表，便于范围查询  数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。\n辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。\n在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）\n MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。\nInnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。\n 总结 B+Tree就是，将原先每一个非叶子结点存储的key，value这种结构，改为只存储key，然后叶子结点存储key，value，通过使用链接结构，上一个指针指向上一个值，下一个指针指向下一个值这种方式。\n","date":"2021-09-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"索引的底层数据结构"},{"content":"Java编程思想集合篇（二） Java HashMap为什么通过(n - 1) \u0026amp; hash 获取哈希桶数组下标？\n看过HashMap源码人应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，就是通过(n - 1) \u0026amp; hash来计算的，那么为什么用的是位运算而不是取模运算(hash % n)呢？\n获取hash桶数组下标源码\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 一. 位运算与取模运算时间比较\npackage com.polymorphic; public class Test { int a = 1; int number = 100000; // 数据集数量，初始定义为十万  // 位运算  public long bitwise() { long start = System.currentTimeMillis(); //从十万开始，一直到Integer的最大值，计算所需时间  for (int i = number; i \u0026gt; 0; i++) { a \u0026amp;= i; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\u0026#34;位运算时间为：\u0026#34; + time + \u0026#34;ms\u0026#34;); return time; } // 取模运算  public long module() { long start = System.currentTimeMillis(); for (int i = number; i \u0026gt; 0; i++) { a %= i; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\u0026#34;取模运算时间为：\u0026#34; + time + \u0026#34;ms\u0026#34;); return time; } public static void main(String[] args) { Test t = new Test(); t.bitwise(); t.module(); } } 运行结果为\n从测试结果我们可以看出，如果数据集足够的大，那么取模运算的时间将会是位运算时间的十几倍。这只是一方面，如果数据集足够大的话，HashMap的初始容量肯定不够，这也触发了HashMap的扩容机制。所以采用二进制位操作 \u0026amp;，相对于%能够提高运算效率\n二.位运算是如何保证索引不越界\n讲到这，我们也就要想想为什么HashMap的容量是2的n次幂？两者之间有着千丝万缕的联系。\n当 n 是2的次幂时， n - 1 通过 二进制表示即尾端一直都是以连续1的形式表示的。当(n - 1) 与 hash 做与运算时，会保留hash中 后 x 位的 1，这样就保证了索引值 不会超出数组长度。\n同时当n为2次幂时，会满足一个公式：(n - 1) \u0026amp; hash = hash % n。\n","date":"2021-08-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%BA%8C/","title":"Java编程思想集合篇（二）"},{"content":"Lamda表达式   Lambda表达式，可以称为闭包，它是推动Java8发动的最重要新特性\n  Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）\n  为什么要使用Lambda表达式\n 可以避免匿名内部类定义过多 可以让你的代码看起来更加简洁 去掉了一堆没有意义的代码，只留下核心的逻辑    基本语法\n(parameters)-\u0026gt;expression[表达式]; (parameters)-\u0026gt;statement[语句]; (parameters)-\u0026gt;{statement};   函数式接口（Functional Interface）是学习Lambda表达式的关键所在。其定义为：\n  任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。\npublic interface Runnable{ public abstract void run(); }   对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。\n    Lambda表达式的推导演示\n现在，我们有一个函数式接口LambdaInterface，它只有一个抽象方法我们该怎样实现他的方法并执行呢？\n  接口LambdaInterface\n//创建函数式接口 interface LambdaInterface { void lambda(); }     创建实现类去实现接口，再创建实现类的对象，调用该方法\n//1.创建实现类实现接口 class LambdaImp implements LambdaInterface { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda1\u0026#34;); } } main函数中调用\npublic static void main(String[] args) { LambdaInterface lambdaImp = new LambdaImp(); lambdaImp.lambda(); }   上述需要在外部写一个实现类，比较繁琐，我们简化一下用一个静态内部类实现。\n在TestLambda类中\n//2.静态内部类实现 static class LambdaImp2 implements LambdaInterface { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda2\u0026#34;); } } main函数中\nLambdaImp2 lambdaImp2 = new LambdaImp2(); lambdaImp2.lambda();   因为静态内部类的实现不能直接在main函数中写，我们可以继续简化，在main函数中写一个局部内部类实现接口\n//3.局部内部类实现 class LambdaImp3 implements LambdaInterface { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda3\u0026#34;); } } LambdaImp3 lambdaImp3 = new LambdaImp3(); lambdaImp3.lambda();   因为是使用局部内部类实现需要写方法名和继承的接口，所以我们继续简化，使用匿名内部类来实现接口\n//4.匿名内部类实现  lambdaImp = new LambdaInterface() { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda4\u0026#34;); } }; lambdaImp.lambda();   倘若我们要继续简化下去，把一些接口、类和方法的声明都省略掉，仅保留核心代码。此时可以使用Lambda表达式来进行简化！\n//6.Lambda表达式简化实现 lambdaImp = ()-\u0026gt;{ System.out.println(\u0026#34;I am Lambda5\u0026#34;); }; lambdaImp.lambda(); 运行结果：\n​\t我们可以发现，步骤1到步骤5都能实现需求。而每一个步骤都可以做出一定的简化，从步骤1的外部类实现到使用Lambda表达式保留核心代码，使我们的代码更为的简洁了，这便是Lambda表达式的推导过程。\n    Lambda的简化\n创建接口LambdaInterface02\n//1.创建函数式接口 interface LambdaInterface02 { void lambda(int a); } 创建测试类TestLambda02\npackage com.lambda; public class TestLambda02 { public static void main(String[] args) { LambdaInterface02 lambdaInterface = null; //Lambda表达式  LambdaInterface02 lambda1 = (int a) -\u0026gt; { System.out.println(\u0026#34;I am Lambda\u0026#34;+a); }; lambda1.lambda(1); //简化1：去掉括号与类型  LambdaInterface02 lambda2 = a -\u0026gt; { System.out.println(\u0026#34;I am Lambda\u0026#34;+a); }; lambda1.lambda(2); //简化2：去掉花括号  LambdaInterface02 lambda3 = (int a) -\u0026gt; System.out.println(\u0026#34;I am Lambda\u0026#34;+a); lambda1.lambda(3); } }   总结\n  Lambda表达式只能有一行代码的情况下才能简化成为一行（去掉花括号），如果有多行代码，就需要用代码块包裹（花括号）\n  使用Lambda表达式的前提是接口为函数式接口\n  多个参数也可以去掉参数类型，但是需要把全部参数类型都去掉且必须加上小括号\nLambdaInterface02 lambda2 = (a,b) -\u0026gt; { System.out.println(\u0026#34;I am Lambda\u0026#34;+a+b); };     ","date":"2021-08-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"Lambda表达式"},{"content":"编译类型、运行类型及多态的区别 Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态。\n 因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋值给一个父类引用变量，无须任何转型，或者被称为向上转型，由系统自动完成。  测试代码\n  Father类\npackage com.polymorphic; public class Father { public Father(){ System.out.println(\u0026#34;Father的构造方法\u0026#34;); } public void doWork(){ System.out.println(\u0026#34;Father Do Work!\u0026#34;); } }   Son类\npackage com.polymorphic; public class Son extends Father{ public Son(){ System.out.println(\u0026#34;Son的构造方法\u0026#34;); } public void doWork(){ System.out.println(\u0026#34;Son Do Work!\u0026#34;); } }   Test类\npackage com.polymorphic; public class Test { public static void main(String[] args) { Father child = new Son(); son.doWork(); } }   运行结果\n在测试类中：\nFather child = new Son(); 在这里我们声明了一个Father的引用变量，指向了Son类的一个实例，我们可以得知child这个引用变量的Father类就是编译类型，而new Son()中的Son类就是运行类型。\n  由运行结果可知：程序在运行时，首先会调用父类的构造器，然后再调用子类的构造器，接下来：在编译过程中，就会自动检查引用变量child的编译类型中，是否包含doWork方法，很明显，在父类中有doWork方法（如果没有会报错），但是，在JVM运行时，由于在子类中覆盖了doWork方法，所以child实际运行时，是调用了子类的doWork方法，而不是父类的，这也就是多态的一种（运行时多态）。\n  什么是编译类型和运行类型呢？\n ​\t引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法（意思是说：编写代码时，只能调用父类中具有的方法，如果子类重写了该方法，运行时实际调用的是运行时类型的该方法。程序在编译时，会在编译类型中检查是否具有所调用的方法，如果编写代码时，使用引用变量调用子类中的特有方法，或者调用了重载父类中的方法，而父类中找不到该方法，则会编译报错），因此，编写Java代码时，引用变量只能调用声明该变量所用类里包含的方法。与方法不同的是，对象的属性则不具备多态性。通过引用变量来访问其包含的实例属性时，系统总是访问它编译时类所定义的属性，而不是它运行时所定义的属性(属性无多态，方法具有多态)。\n​\t要访问子类中特有的方法和属性，在编写代码时，必须进行类型转换。\n——以上摘自《疯狂Java讲义》\n   什么是多态？\n 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n 在测试类中：\n//编译时类型 引用变量 运行时类型  Father child = new Son(); 这行代码编译时类型和运行时类型不一致(父类引用指向子类)，同时Son继承了Father并且重写了Father的doWork方法，这就是所谓的多态。\n  代码演示方法具有多态，属性无多态\nClass A\npackage com.polymorphic; public class A { String a = \u0026#34;This is A!\u0026#34;; public String getString(){ return this.a; } } **Class B **\npackage com.polymorphic; public class B extends A{ String a = \u0026#34;This is B!\u0026#34;; public String getString(){ return this.b; } } Test\npackage com.polymorphic; public class Test { public static void main(String[] args) { A a1 = new A(); System.out.println(a1.getClass()+\u0026#34; \u0026#34;+a1.getString()+\u0026#34; \u0026#34;+a1.a); B b1 = new B(); System.out.println(b1.getClass()+\u0026#34; \u0026#34;+b1.getString()+\u0026#34; \u0026#34;+b1.a); a1 = b1; System.out.println(a1.getClass()+\u0026#34; \u0026#34;+a1.getString()+\u0026#34; \u0026#34;+a1.a); b1 = (B)a1; System.out.println(b1.getClass()+\u0026#34; \u0026#34;+b1.getString()+\u0026#34; \u0026#34;+b1.a); A a2 = new B(); System.out.println(a2.getClass()+\u0026#34; \u0026#34;+a2.getString()+\u0026#34; \u0026#34;+a2.a); } } 运行结果\n ​\t从这个结果可以看出类继承时，子类会覆盖与父类相同的属性。总结一点就是：对象访问变量看声明，访问方法看实际对象类型（new出来的类型）。也可以说：属性无多态，而方法具有多态。\n   ","date":"2021-06-28T16:22:25+08:00","permalink":"https://minster77.github.io/p/polymorphic/","title":"polymorphic"},{"content":"JavaIO流2   BufferedReader与BufferedWriter 使用字节流实现对二进制文件复制 对象流 标准输入输出流 转换流 打印流 Properties类   BufferedReader与BufferedWriter   BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的。\n  关闭处理流的时候，只需要关闭外层流即可\n演示bufferedReader的使用\npackage com.java_io; import java.io.BufferedReader; import java.io.FileReader; public class BufferedReaderTest { public static void main(String[] args) throws Exception{ String path = \u0026#34;E://note.txt\u0026#34;; //创建BufferedReader对象  BufferedReader bufferedReader = new BufferedReader(new FileReader(path)); //按行读取，提高效率  String line; /* * bufferedReader.readLine()是按行读取文件的 * 当返回null时，表示已读取完毕 */ while ((line =bufferedReader.readLine())!=null){ System.out.println(line); } bufferedReader.close(); } }   需要注意的是，关闭流时只需要关闭BufferedReader。因为底层会自动关闭节点流\n底层代码\npublic void close() throws IOException { synchronized (lock) { if (in == null) return; try { in.close(); } finally { in = null; cb = null; } } }   演示BufferedWriter\npackage com.java_io; import java.io.BufferedWriter; import java.io.FileWriter; public class BufferedWriterTest { public static void main(String[] args) throws Exception{ String path = \u0026#34;E://a.txt\u0026#34;; //创建对象，把FileWriter的Boolean值置为true可以实现追加功能  //默认为false，会覆盖原来的内容  BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(path,true)); bufferedWriter.write(\u0026#34;hello,成志恒\u0026#34;); //插入一个当前系统的换行符  bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;hello2,成志恒\u0026#34;); bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;hello3,成志恒\u0026#34;); bufferedWriter.newLine(); bufferedWriter.close(); } }   使用bufferd进行文件拷贝\npackage com.bufferd; import java.io.*; public class BufferedCopy_ { public static void main(String[] args) { String path1 = \u0026#34;e://a.txt\u0026#34;; String path2 = \u0026#34;e://a1.txt\u0026#34;; BufferedReader br = null; BufferedWriter bw = null; String line; try { br = new BufferedReader(new FileReader(path1)); bw = new BufferedWriter(new FileWriter(path2)); while ((line = br.readLine())!=null){ bw.write(line); bw.newLine(); } } catch (IOException e) { e.printStackTrace(); } finally { try { if(br != null){ br.close(); } if(bw != null){ bw.close(); } } catch (Exception e) { e.printStackTrace(); } } } } 使用说明：\n BufferedReader和BufferedWriter是按照字符操作的 如果去操作二进制文件（声音，视频，doc，pdf），可能造成文件损坏    使用字节流实现对二进制文件复制   BufferedOutputstream和BufferedInputStream结合实现对图片的拷贝\npackage com.bufferd; import com.sun.xml.internal.ws.api.ha.StickyFeature; import java.io.*; public class BufferedOutputStream_ { public static void main(String[] args) { String path1 = \u0026#34;e://567.jpg\u0026#34;; String path2 = \u0026#34;e://678.jpg\u0026#34;; BufferedInputStream bis = null; BufferedOutputStream bos = null; try { bis = new BufferedInputStream(new FileInputStream(path1)); bos = new BufferedOutputStream(new FileOutputStream(path2)); byte[] b = new byte[1024]; int len; while((len = bis.read(b))!=-1){ bos.write(b,0,len); } System.out.println(\u0026#34;拷贝成功...\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { if(bis!=null){ bis.close(); } if (bos!=null){ bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } }   字节流可以操作二进制文件，也可以操作文本文件\n  对象流   序列化和反序列化\n 序列化就是在保存数据时，保存数据的值和数据类型 反序列化就是在恢复数据时，恢复数据的值和数据类型 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，改类必须实现两个接口之一：  Serializable //这是一个标记接口，没有方法 Externalizable //该接口有方法需要实现，一般不使用      ObjectOutputStream提供序列化功能\n  序列化后保存的文件格式不是纯文本的，而是按照序列化的格式来保存\n  常用的几种基本类型都实现了Serializable接口，所以可以直接保存其数据类型\n  如果需要实例化某个类的对象，该类需要实现Serializable\n  代码演示\npackage com.outputstream; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class ObjectOutputStream_ { public static void main(String[] args) throws Exception{ String filePath = \u0026#34;e:\\\\a.bat\u0026#34;; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); oos.write(100);//int -\u0026gt; Integer(实现了Serializable接口)  oos.writeBoolean(true);//boolean -\u0026gt; Boolean(实现了Serializable接口)  oos.writeChar(\u0026#39;a\u0026#39;);//char -\u0026gt; Character(实现了Serializable接口)  oos.writeUTF(\u0026#34;成志恒\u0026#34;);//string -\u0026gt; String(实现了Serializable接口)  oos.writeDouble(9.5);//double -\u0026gt; Double(实现了Serializable接口)  //保存一个dog对象  oos.writeObject(new Dog(\u0026#34;dog\u0026#34;,10)); oos.close(); System.out.println(\u0026#34;保存成功...\u0026#34;); } } class Dog implements Serializable { public Dog(String name, int age) { this.name = name; this.age = age; } private String name; private int age; }   ObjectInputStream提供反序列化功能\n 读取（反序列化）的顺序需要和你保存数据（序列化）的顺序一致 在反序列化的时候，如果需要调用对象（dog）的方法，则需要向下转型，而实现向下转型的关键是当前类可以引用dog类，即在当前类下引用类。  代码演示\npackage com.inputstream_; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import com.outputstream.Dog;8//引用dog类  public class ObjectInputStream_ { public static void main(String[] args) throws IOException, ClassNotFoundException { String filePath = \u0026#34;e:\\\\a.bat\u0026#34;; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readUTF()); System.out.println(ois.readDouble()); Object dog = ois.readObject(); System.out.println(\u0026#34;类型为:\u0026#34;+dog.getClass()); System.out.println(dog); //向下转型  Dog dog1 = (Dog)dog; System.out.println(dog1.getAge()); ois.close(); System.out.println(\u0026#34;反序列成功\u0026#34;); } }   注意事项和细节说明\n  读写顺序要一致\n  要求实现序列化或反序列化对象，需要实现Serializable接口\n  序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性\n//SerialVersionUID序列化的版本号，可以提高兼容性 private static final long serialVersionUID = 1L;   序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员\n//下面两个属性都不会被序列化 private static String color; private transient String nation;   序列化对象时，要求里面属性的类型也需要实现序列化接口\n代码演示\nMaster类\npackage com.outputstream; public class Master { } Dog类新增加一个Master类型的属性\nprivate Master master = new Master(); 此时运行ObjectOutputStream_系统会报错\n如果要解决上述问题，需要Master类实现Serializable接口\npackage com.outputstream; import java.io.Serializable; public class Master implements Serializable { } 此时再运行ObjectOutoutStream_，保存成功\n  序列化具备可继承性，也就是如果某类已经 实现了序列化，则它的所有子类也已经默认实现了序列化\n    标准输入输出流   System.in(标准输入：键盘)\n 该流为System类中的public final static InputStream in = null; 编译类型：InputStream 运行类型：BufferedInputStream    System.out(标准输出：显示器)\n 该流为System类中的public final static PrintStream out = null; 编译类型：PrintStream 运行类型：PrintStream    代码演示\npackage com.standard; import java.util.Scanner; public class OutAndIn { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入数据\u0026#34;); String next = scanner.next(); System.out.println(\u0026#34;next=\u0026#34;+next); } }   转换流   在读取文件内容时，会默认文件为utf-8方式编码的，一旦文件编码方式改变了，所读取到的信息就会产生乱码，所以有转换流的出现\n  转换流可以把一个字节流转换成字符流，而字节流读取文件信息可以按照其编码方式来读取，所以能很好解决乱码问题\n  转换流有InputStreamReader与OutputStreamWriter\n  InputStreamReader：Reader的子类，可以将InputStream包装成Reader\n  OutputStreamWriter：Writer的子类，可以将OutputStream包装成Writer\n  当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\n  可以在使用是指定编码格式（比如utf-8，gbk，gb2312等）\n    演示使用InputStreamReader转换流解决中文乱码问题\n将字节流FileInputStream转换成字符流InputStreamReader，指定编码gbk/utf-8\npackage com.inputstream_; import java.io.*; public class InputStreamReader_ { public static void main(String[] args) throws IOException { String filePath = \u0026#34;e:\\\\a.txt\u0026#34;; //1.将FieleInputStream转换成InputStreamReader，编码方式为gbk  InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath),\u0026#34;gbk\u0026#34;); //2.将InputStreamReader传入BufferedReader  BufferedReader br = new BufferedReader(isr); //3.读取文件  String s = br.readLine(); //4.打印文件内容  System.out.println(s); //5.关闭流  br.close(); } } 为了减少代码行数，在开发中经常把1和2合在一起写\nBufferedReader br = new BufferedReader( new InputStreamReader( new FileInputStream(filePath),\u0026#34;gbk\u0026#34;));   OutStreamWriter同理\npackage com.outputstream; import java.io.BufferedWriter; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; public class OutStreamWriter_ { public static void main(String[] args) throws IOException { String filePath = \u0026#34;e:\\\\a.txt\u0026#34;; String charSet = \u0026#34;utf-8\u0026#34;; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(filePath),charSet); osw.write(\u0026#34;hello,成志恒11\u0026#34;); osw.close(); } }   打印流   打印流只有输出流没有输入流\n  PrintStream(字节打印流)\n在默认情况下，PrintStream输出数据的位置是标准输出（显示器）\n演示代码\npackage com.print; import java.io.PrintStream; public class PrintStream_ { public static void main(String[] args) { PrintStream printStream = System.out; printStream.println(\u0026#34;hello,word\u0026#34;); printStream.close(); } } 通过查看Print的底层源码\npublic void print(String s) { if (s == null) { s = \u0026#34;null\u0026#34;; } write(s); } 可以知道print底层使用的是write，所以我们可以直接调用write进行打印/输出\nprintStream.write(\u0026#34;hello,word\u0026#34;,getBytes()); 所得运行结果跟上述一样。\n另外，通过System.setOut()方法可以将内容输出到指定的的设备上\nString filePath = \u0026#34;e:\\\\a.txt\u0026#34;; System.setOut(new PrintStream(filePath)); System.out.println(\u0026#34;hi，word！\u0026#34;); 运行结果\n  PrintWriter(字符字符打印流)\n PrintWriter使用完之后必须关闭流，否则写入的内容不会刷新  使用PrintWriter将内容输出到指定设备\npackage com.print; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class PrintWriter_ { public static void main(String[] args) throws IOException { PrintWriter printWriter = new PrintWriter(new FileWriter(\u0026#34;e:\\\\a.txt\u0026#34;)); printWriter.print(\u0026#34;hello.word!!!\u0026#34;); //必须关闭流！  printWriter.close();//相当于flush+关闭流  } }   Properties类   Properties类主要用于读取Java的配置文件。\n  传统的读取配置文件信息的方法\n代码演示\npackage com.properties; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class Properties_ { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(\u0026#34;src\\\\mysql.properties\u0026#34;)); String line = \u0026#34;\u0026#34;; while((line = br.readLine()) != null){ //利用split将等号前后的内容划分成两个数组  String[] split = line.split(\u0026#34;=\u0026#34;); System.out.println(split[0]+\u0026#34;值为\u0026#34;+split[1]); } } } 如果我们使用传统方法获取指定的ip值，会有很多问题，所以一般使用Properties类去读取配置文件\n  Properties类读取配置文件\n  该类是专门用于读取配置文件的集合类，配置文件的格式需要按照一下格式编写：\n 键=值\n键=值\n   注意：键值对不需要有空格，值不需要用引号括起来，默认类型为String\n  Properties的常见方法\n load：加载配置文件的键值对到Priperties对象 list：将数据显示到指定设备 getProperty(key)：根据键获取值 setProperty(key,value)：设置键值对到Properties对象 store：将Properties中的键值对存储到配置文件。在idea中，保存信息到配置文件，如果信息含有中文，会存储为Unicode码 http://tool.chinaz.com/tools/unicode/aspx Unicode码查询工具    代码演示\npackage com.properties; import java.io.FileReader; import java.io.IOException; import java.util.Properties; public class Properties_01 { public static void main(String[] args) throws IOException { //1.创建Properties对象  Properties properties = new Properties(); //2.加载指定文件  properties.load(new FileReader(\u0026#34;src\\\\mysql.properties\u0026#34;)); //3.把k-v输出到控制台  properties.list(System.out); //4.根据key值获取相对应的value  String user = properties.getProperty(\u0026#34;user\u0026#34;); System.out.println(\u0026#34;用户名=\u0026#34;+user); } } 运行结果\n  使用Properties类来创建配置文件\npackage com.properties; import java.io.FileWriter; import java.io.IOException; import java.util.Properties; public class Properties_02 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.setProperty(\u0026#34;charset\u0026#34;,\u0026#34;utf8\u0026#34;); properties.setProperty(\u0026#34;user\u0026#34;,\u0026#34;志恒\u0026#34;);//中文保存为Unicode码  properties.setProperty(\u0026#34;pwd\u0026#34;,\u0026#34;11111\u0026#34;); properties.store(new FileWriter(\u0026#34;src\\\\mysql2.properties\u0026#34;),null); System.out.println(\u0026#34;保存成功\u0026#34;); } } 运行结果\n  使用Properties来修改文件内容\n 如果该文件没有key，就会自动创建 如果该文件有key，就会修改  properties.setProperties(\u0026#34;pwd\u0026#34;,888888);   Properties父类是Hashtable，所以其核心代码底层就是Hashtable 的核心方法\npublic synchronized V put(K key, V value) { // Make sure the value is not null  if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable.  Entry\u0026lt;?,?\u0026gt; tab[] = table; int hash = key.hashCode(); int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; entry = (Entry\u0026lt;K,V\u0026gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) \u0026amp;\u0026amp; entry.key.equals(key)) { V old = entry.value; entry.value = value;//如果key存在，就替换  return old; } } addEntry(hash, key, value, index);//如果是新的值，就addEntry  return null; } ​\n  ","date":"2021-06-19T16:22:25+08:00","permalink":"https://minster77.github.io/p/java_io%E6%B5%81_2/","title":"Java_IO流_2"},{"content":"泛型   引出泛型 泛型的介绍及使用 泛型的使用细节 泛型课堂练习题 自定义泛型 Junit   引出泛型   现在有这样的一个需求\n 编写一个程序，在ArrayList中，添加三个Dog对象 Dog对象含有name和age，并输出name和age（要求使用getXxx方法）  用传统的方法编码，代码演示如下\n创建Dog类\nclass Dog{ private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 创建测试类Generic01\npackage com.generic; import java.util.ArrayList; public class Generic01 { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(new Dog(\u0026#34;旺财\u0026#34;,10)); arrayList.add(new Dog(\u0026#34;小黄\u0026#34;,8)); arrayList.add(new Dog(\u0026#34;富贵\u0026#34;,5)); //使用增强for遍历  for (Object o : arrayList) { //向下转型  Dog dog = (Dog) o; System.out.println(dog.getName()+\u0026#34;--\u0026#34;+dog.getAge()); } } } 用传统方式即可很快完成需求。\n假如程序员不小心把一个Cat对象添加到集合里面，会发生什么呢？\narrayList.add(new Cat(\u0026#34;小黑\u0026#34;,3)); 编译运行，发现程序报错\n可以发现，倘若我们使用传统的方式来解决需求时，程序会有两个缺点\n 不能对加入到集合ArrayList中的数据类型进行约束（不安全，会发生上面那样的编译错误，而且编译器编译时识别不了） 遍历的时候需要进行类型转换，如果集合中的数据量较大时会对效率有影响  而我们使用泛型便可以很好的解决上述两个缺点！\n把测试类Generic01中集合的定义改为\nArrayList\u0026lt;Dog\u0026gt; arrayList = new ArrayList\u0026lt;Dog\u0026gt;(); 便是使用了泛型，可以规范ArrayList集合中元素的取值。而且当我们使用泛型之后，如果编译器发现添加的类型不满足集合规定的要求，就会报错，可以避免发生异常。\n同时，我们遍历集合的时候，不再需要先取出Object类型再进行向下转型了，可以直接获取到Dog类型的数据。\n//使用增强for遍历 for (Dog dog : arrayList) { System.out.println(dog.getName()+\u0026#34;--\u0026#34;+dog.getAge()); } 使用泛型的好处\n 编译时，编译器会检查添加元素的类型，提高了安全性 减少了类型转换的次数，提高效率    泛型的介绍及语法与使用   泛型的介绍（泛型是可以代表一种数据类型的）\n  泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题\n  在类声明或实例化时只要指定好需要的具体类型即可\n  Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时使代码更加简洁、健壮\n  泛型的作用是：可以在类声明时通过一个标识表示类中的某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型（看下面代码理解）。\n 在编程时，我们新建一个类的属性的时候，有时候可能会不确定该属性的类型，让其由用户来决定，这时候我们便可以使用泛型\n class Person\u0026lt;E\u0026gt;{ //E表示数据类型  E s; //E也可以是参数类型  public Person(E s) { this.s = s; } //E做返回类型  public E getS() { return s; } } 我们在Generic02中，可以根据所需来声明E的类型\npackage com.generic; public class Generic02 { public static void main(String[] args) { //当我们要s为String类型的时候  Person\u0026lt;String\u0026gt; stringPerson = new Person\u0026lt;String\u0026gt;(\u0026#34;jack\u0026#34;); //当我们要s为int类型的时候  Person\u0026lt;Integer\u0026gt; person = new Person\u0026lt;Integer\u0026gt;(1); } } E的数据类型在定义Person时指定，即在编译期间就可以确定E的类型\n    泛型的语法\ninterface 接口 \u0026lt;E\u0026gt;{ } class 类\u0026lt;K,V,E\u0026gt;{ } 其中，K,T,V不代表值，而是表示类型\n任意字母都可以。常用T表示\n  泛型的应用实例\n 创建三个学生对象 把学生对象放到HashMap中，而且学生名字为key，学生对象为value 用两种方式遍历学生对象  代码演示\n创建Student类\nclass Student{ private String name; private int age; public Student(String name,int age) { this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 创建测试类GenericExercise\npackage com.generic; import java.util.*; public class GenericExercise { public static void main(String[] args) { Student jack = new Student(\u0026#34;jack\u0026#34;, 10); Student tom = new Student(\u0026#34;tom\u0026#34;, 13); Student mary = new Student(\u0026#34;mary\u0026#34;, 15); HashMap\u0026lt;String,Student\u0026gt; hashMap = new HashMap\u0026lt;String,Student\u0026gt;(); hashMap.put(jack.getName(),jack); hashMap.put(tom.getName(),tom); hashMap.put(mary.getName(),mary); Set\u0026lt;String\u0026gt; strings = hashMap.keySet(); Iterator\u0026lt;String\u0026gt; iterator = strings.iterator(); while (iterator.hasNext()) { String next = iterator.next(); System.out.println(next+\u0026#34;:\u0026#34;+hashMap.get(next)); } System.out.println(\u0026#34;==============\u0026#34;); Set\u0026lt;Map.Entry\u0026lt;String, Student\u0026gt;\u0026gt; entries = hashMap.entrySet(); for (Map.Entry\u0026lt;String, Student\u0026gt; entry : entries) { System.out.println(entry.getKey()+\u0026#34;=\u0026#34;+entry.getValue()); } } } 运行结果\n  泛型的使用细节   interface List\u0026lt;T,V\u0026gt;等泛型的声明中，其中T,V只能是引用类型，不能为基本数据类型！\n//正确的定义 List \u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;Integer\u0026gt;(); //错误的定义\tList \u0026lt;int\u0026gt; list2 = new ArrayList\u0026lt;int\u0026gt;();   在给泛型指定的具体类型后，可以传入该类型或该子类类型（继承）。\nclass Detail{ public static void main(String[] args){ Pig\u0026lt;A\u0026gt; piga = new Pig\u0026lt;A\u0026gt;(new A()); Pig\u0026lt;A\u0026gt; piga = new Pig\u0026lt;A\u0026gt;(new B()); } } class A{ } class B extends A{ } class Pig\u0026lt;E\u0026gt;{ E e; publiu Pig(E e){ this.e = e; } }   泛型的使用方式\n//传统写法 List \u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;Integer\u0026gt;(); //实际开发中，通常使用简写。因为编译器会进行类型推断，所以后面的可以不写 List \u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;();//推荐这种写法！   如果是这样写 List list1 = new ArrayList(); 也会使用泛型，默认是Object\nList list1 = new ArrayList(); //等价于 List \u0026lt;Object\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;();   泛型课堂练习题 定义Employee类\n  该类包含：private成员变量 name，sal，birthday，其中birthday为Mydate类的对象；\n  为每一个属性定义getter，setter方法；\n  重写toString方法输出name，sal，birthday\n  MyDate类包含：private成员变量month，day，year；并为每一个属性定义getter，setter方法；\n  创建Employee类的三个对象，并把这些对象放入ArrayList集合中（ArrayList需要使用泛型来定义），对集合中的元素进行排序，并遍历输出；\n  排序方式：调用ArrayList的sort方法，传入Comparator对象，先按照name排序，如果name相同，则按照生日日期的先后排序。\n创建MyDate类\npackage com.generic; class MyDate implements Comparable\u0026lt;MyDate\u0026gt;{ private int year; private int month; private int day; public MyDate(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getMonth() { return month; } public void setMonth(int month) { this.month = month; } public int getDay() { return day; } public void setDay(int day) { this.day = day; } @Override public String toString() { return \u0026#34;MyDate{\u0026#34; + \u0026#34;year=\u0026#34; + year + \u0026#34;, month=\u0026#34; + month + \u0026#34;, day=\u0026#34; + day + \u0026#39;}\u0026#39;; } //实现Comparable的方法，让Birthday的比较封装在MyDate类中  //封装后代码的维护性和可复用行大大提高！  @Override public int compareTo(MyDate o) { //按照year的大小进行排序  int yearMinus = this.getYear() - o.getYear(); //如果year不相同，返回比较值  if (yearMinus != 0){ return yearMinus; } //按照month的大小进行排序  int monthMinus = this.getMonth() - o.getMonth(); if (monthMinus != 0){ return monthMinus; } //如果year与month相同，按照day的大小进行排序  return this.getDay() - o.getDay(); } } 创建Employee类\npackage com.generic; class Employee{ private String name; private double sal; private MyDate birthday; public Employee(String name, double sal, MyDate birthday) { this.name = name; this.sal = sal; this.birthday = birthday; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } public MyDate getBirthday() { return birthday; } public void setBirthday(MyDate birthday) { this.birthday = birthday; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;\\nEmployee{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, sal=\u0026#34; + sal + \u0026#34;, birthday=\u0026#34; + birthday + \u0026#39;}\u0026#39;; } } 创建测试类GenericExercise02\npackage com.generic; import java.util.ArrayList; import java.util.Comparator; public class GenericExercise02 { public static void main(String[] args) { Employee jack = new Employee(\u0026#34;jack\u0026#34;, 1000, new MyDate(2000, 03, 20)); Employee tom = new Employee(\u0026#34;tom\u0026#34;, 2000, new MyDate(1999, 02, 1)); Employee mary = new Employee(\u0026#34;jack\u0026#34;, 3000, new MyDate(2000, 02, 19)); ArrayList\u0026lt;Employee\u0026gt; employees = new ArrayList\u0026lt;\u0026gt;(); employees.add(jack); employees.add(tom); employees.add(mary); System.out.println(); employees.sort(new Comparator\u0026lt;Employee\u0026gt;() { @Override public int compare(Employee emp1, Employee emp2) { if(!(emp1 instanceof Employee )\u0026amp;\u0026amp; !(emp2 instanceof Employee)){ System.out.println(\u0026#34;类型不正确...\u0026#34;); return 0; } //按照name排序，字母的先后顺序  int i = emp1.getName().compareTo(emp2.getName()); //i不等于0说明name不相同，即通过名字即可完成排序，所以返回i；  if(i != 0){ return i; } //如果name长度相同，便按照birthday进行排序  return emp1.getBirthday().compareTo(emp2.getBirthday()); } }); System.out.println(employees); } } 运行结果\n  自定义泛型   自定义泛型类\n  基本语法\nclass 类名 \u0026lt;T,V...\u0026gt;{ }   注意细节\n 普通成员可以使用泛型（属性、方法） 使用泛型的数组，不能初始化（因为数组在创建的时候，不能确定泛型的类型，无法在内存开辟空间） 静态方法中不能使用类的泛型（因为static是与类相关的，在类加载时，对象还没有创建，而泛型是在对象创建时才产生的。） 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型） 如果在创建对象时，没有指定类型，默认为Object      自定义泛型接口\n  基本语法\ninterface 接口名 \u0026lt;T,E,R...\u0026gt;{ }   注意细节\n  在接口中，静态成员也不能使用泛型\n  泛型接口的类型，在继承接口或者实现接口时确定\ninterface IA\u0026lt;T,V\u0026gt;{ T get(V v); } //继承接口时确定泛型的类型 //T-\u0026gt;Double,V-\u0026gt;String interface IB extends IA\u0026lt;Double,String\u0026gt;{ } //当我们区实现IB接口时，因为IB在继承IA时指定了T为Double，V为String //所以在实现IA的方法时，会自动替换掉T,V class IBImp implements IB{ @Override public Double get(String v){ } }   没有指定类型，默认为Object\n  在jdk8中，default方法也能使用泛型\n      自定义泛型方法\n  基本语法\n修饰符 \u0026lt;T,R\u0026gt;返回类型 方法名(参数列表){ }   注意细节\n 泛型方法，可以定义在普通类中，也可以定义在泛型类中 当泛型方法被调用时，类型会确定 public void eat(E e){}，修饰符后面没有\u0026lt;T,R\u0026hellip;\u0026gt; eat方法不是泛型方法，而是使用了泛型 泛型方法可以使用类声明的泛型，也可以使用自己声明的泛型      泛型的继承和通配符\n  泛型不具备继承性\nList \u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();//系统会报错           JUnit  一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中 如果有多个功能代码测试，就需要来回注销，切换很麻烦 而使用JUnit便可以很好的解决上述问题    基本介绍\n JUnit是一个Java语言的单元测试框架 多数Java的开发环境都已经继承了JUnit作为单元测试的工具    使用\n在需要测试的文件上面增加一个@Test即可\n  ","date":"2021-06-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E6%B3%9B%E5%9E%8B/","title":"Java泛型"},{"content":"Java IO流1（概念及节点流）   文件 IO流原理及流的分类 InputStream的子类及使用 OutputStream的子类及使用 利用FileInputStream及FileOutputStream进行文件copy Reader与Writer的子类及使用 节点流和处理流   文件   文件是保存数据的地方，例如word文档，txt文档等都是文件。\n  文件流\n文件在程序中是以流的形式来操作的\n 流：数据在数据源(文件）和程序（内存）之间经历的路径 输入流：数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径    常用的文件操作\n    使用new File（String pathname）创建\npackage com.java_io; import org.junit.Test; import java.io.File; import java.io.IOException; public class FileCreate1 { public static void main(String[] args) { } //方法1：使用new File(filePath)创建文件  @Test public void createFile01() throws IOException { //创建的文件路径名称  String filePath = \u0026#34;e:\\\\news1.txt\u0026#34;; File file = new File(filePath); try { file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } }   使用new File(File parent,String child)创建\n@Test public void createFile02(){ File parentFile = new File(\u0026#34;e:\\\\\u0026#34;); String fileName = \u0026#34;news2.txt\u0026#34;; //此时的file对象在Java程序(内存)中只是一个对象而已  //只有执行了createNewFile方法才会真正在磁盘创建文件  File file = new File(parentFile,fileName); try { //此时在磁盘中创建了文件  file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } }   使用new File(String parent,String child)创建\n@Test public void createFile03(){ String parentPath = \u0026#34;e:\\\\\u0026#34;; //String parentPath = \u0026#34;e:/\u0026#34;; 也可以  String fileName = \u0026#34;new3.txt\u0026#34;; File file = new File(parentPath,fileName); try { file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } }   获取文件信息\n getName()：获取文件名字 getAbsolutePath()：获取文件绝对路径 getParent()：获取父级目录 length()：获取文件大小(字节) exists()：查看文件是否存在 isFile()：检测是不是一个文件 isDirectory()：检测是不是一个目录  代码演示\npackage com.java_io; import org.junit.Test; import java.io.File; public class fileInformation { public static void main(String[] args) { } @Test public void fileInformation(){ //先创建文件对象  File file = new File(\u0026#34;e:\\\\news1.txt\u0026#34;); //调用对应的方法，得到相应的信息  System.out.println(\u0026#34;文件名字=\u0026#34;+file.getName()); System.out.println(\u0026#34;文件绝对路径=\u0026#34;+file.getAbsolutePath()); System.out.println(\u0026#34;文件父级目录=\u0026#34;+file.getParent()); System.out.println(\u0026#34;文件大小（字节）=\u0026#34;+file.length()); System.out.println(\u0026#34;文件是否存在=\u0026#34;+file.exists()); System.out.println(\u0026#34;是不是一个文件=\u0026#34;+file.isFile()); System.out.println(\u0026#34;是不是一个目录=\u0026#34;+file.isDirectory()); } }   目录的操作\n delete()：删除目录。 mkdir()：创建一级目录 mkdirs()：创建多级目录  代码示例\n//检查目录下是否存在news2.txt文件，若存在则删除  @Test public void m1(){ File file = new File(\u0026#34;e:\\\\news2.txt\u0026#34;); if (file.exists()) { if (file.delete()) { System.out.println(\u0026#34;删除成功\u0026#34;); }else { System.out.println(\u0026#34;删除失败\u0026#34;); } }else { System.out.println(\u0026#34;找不到改文件...\u0026#34;); } } } 创建目录\n//检查e:\\\\demo\\\\a\\\\b\\\\c是否存在，若不存在则创建  @Test public void m2(){ String directoryPath = \u0026#34;e:\\\\demo\\\\a\\\\b\\\\c\u0026#34;; File file = new File(directoryPath); if (file.exists()) { System.out.println(\u0026#34;改目录存在...\u0026#34;); }else { if (file.mkdirs()) { System.out.println(directoryPath+\u0026#34;目录创建成功\u0026#34;); }else { System.out.println(directoryPath+\u0026#34;目录创建失败\u0026#34;); } } }   IO流原理及流的分类   输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中\n  输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中\n  流的分类\n 按操作数据单位不同分为：  字节流（8bit）：二进制文件使用 字符流（按字符）：文本文件使用   按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：字节流，处理流/包装流  而Java IO流有四个抽象基类\n    字节流 字符流     输出流 OutputStream Writer   输入流 InputStream Reader    其他的流都是继承于这四大基类的。下图是Java IO流的整体架构图\n所理解的流就像快递小哥，在物流中心和客户之间做传递作用\n  InputStream的子类及使用   InputStream的常用子类\n FileInputStream：文件输入流 BufferedInputStream：缓冲字节输入流 ObjectInoutStream：对象字节输入流    使用FileInputStream读取文件\nread()读取单个字节\npackage com.java_io; import org.junit.Test; import java.io.FileInputStream; import java.io.IOException; public class FileInputStreamTest { public static void main(String[] args) { } @Test public void InputStream(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; FileInputStream fileInputStream = null; int readFile = 0; try { //创建FileInputStream对象，用于读取文件  fileInputStream = new FileInputStream(filePath); //read()：从输入流中读取一个字节的数据，如果没有输入，则被阻止  //如果返回-1.则表示读取完毕  while ((readFile = fileInputStream.read())!=-1){ System.out.print((char) readFile); } } catch (Exception e) { e.printStackTrace(); }finally { //关闭文件流，释放资源  try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } read(byte[b])缓冲区读取b个字节\n@Test public void InputStream02(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; byte [] buf = new byte[8];//每次读取8个字节的数据  FileInputStream fileInputStream = null; int readLen = 0;//记录读取的字节数  try { fileInputStream = new FileInputStream(filePath); /* * 创建FileInputStream对象，用于读取文件 * 从输入流读取最多buf.length字节数据到字节数组，若没有输入，则阻塞此方法 * 如果返回值为-1，表示读取完毕 * 如果读取正常则返回读取的字节数*/ while((readLen = fileInputStream.read(buf))!=-1){ //new Sting(buf,0,len):把一个字节数组从0取到len构造成一个新的String  System.out.print(new String(buf,0,readLen)); } } catch (IOException e) { e.printStackTrace(); } finally { try { //关闭流，释放资源  fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 需要注意的是使用FileInputStream读取文件时，读取到的字符是乱码的\n    OutputStream的子类及使用   FileOutputStream\n演示使用FileOutputStream。将数据写到文件中，如果该文件不存在，则创建该文件。\npackage com.java_io; import org.junit.Test; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class FileOutputStreamTest { public static void main(String[] args) { } @Test public void fileOutputStream(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; FileOutputStream fileOutputStream = null; try { //创建FileOutputStream对象，对文件操作  fileOutputStream = new FileOutputStream(filePath,true); //向文件写入一个字节的数据  fileOutputStream.write(\u0026#39;H\u0026#39;); //向文件写入字符串  //str.getBytes()将字符串转换为字节数组  String str = \u0026#34;Hello,Word!\u0026#34;; fileOutputStream.write(str.getBytes()); System.out.println(\u0026#34;写入成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } }   若需要写入指定的字符，使用\n//write(byte[] b,int off,int len); fileOutputStream.write(str.getBytes(),0,str.length()); 可以将len字节从偏移量off的指定字节数组写入此文件输入流\n  需要注意的是，如果使用\nfileOutputStream = new FileOutputStream(File file,boolean append); 时没有将append设置为true的话，系统会默认append的值为false，则会清空记事本再写入新的内容（覆盖之前的内容）。\n若需要换行或者添加制表符输入，使用其转义字符即刻\nfileOutputStream.write(\u0026#34;\\n\u0026#34;.getBytes());//换行 fileOutputStream.write(\u0026#34;\\t\u0026#34;.getBytes());//增加制表符     利用FileInputStream及FileOutputStream进行文件Copy   思路分析\n 创建文件的输入流，将文件读到程序中 创建文件的输出流，将读取到的文件输入写到指定的文件中    代码演示\npackage com.java_io; import org.junit.Test; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopy { public static void main(String[] args) { } /* * 将\u0026#34;e:\\\\567.jpg\u0026#34;复制到\u0026#34;d:\\\\567.jpg\u0026#34;*/ @Test public void fileCopy(){ String srcPath = \u0026#34;e:\\\\567.jpg\u0026#34;; String destPath = \u0026#34;d:\\\\567.jpg\u0026#34;; //创建输入流及输出流对象  FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try { //定义字节数组接收，提高效率  byte [] buf = new byte[1024]; int readlen = 0; fileInputStream = new FileInputStream(srcPath); fileOutputStream = new FileOutputStream(destPath); while ((readlen = fileInputStream.read(buf))!=-1){ fileOutputStream.write(buf,0,readlen); } System.out.println(\u0026#34;写入成功！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { //关闭输入输出流，释放资源  if(fileInputStream==null){ fileInputStream.close(); } if(fileOutputStream==null){ fileOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 需要注意的是，写入文件时，必须使用\nwrite(byte[],0,readLength) 写入。readLength为读入数据的长度，这样写可以避免byte数组过大时把其余子集读入造成文件损失\n  Reader与Writer的子类及使用   FileReader的相关方法：\n new FileReader(File/String)：创建对象 read()：每次读取单个字符并返回，如果到文件末尾，返回-1 read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾则返回-1。  相关API\n new String(char[])：将char[] 转换成String new String(char[],off,len)：将char[]的指定部分转换成String  代码演示\npackage com.java_io; import org.junit.Test; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class FileReaderTest { public static void main(String[] args) { } @Test public void FileReaderTest(){ String filePath = \u0026#34;e:\\\\story.txt\u0026#34;; FileReader fileReader = null; char [] chars = new char[1024]; try { //新建对象  fileReader = new FileReader(filePath); try { while ((fileReader.read(chars))!=-1){ System.out.println(chars); } } catch (IOException e) { e.printStackTrace(); } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { if(fileReader==null){ //关闭流，释放资源  fileReader.close(); } } catch (IOException e) { e.printStackTrace(); } } } }   FileWriter的相关方法\n new FileWriter(File/String)：覆盖模式，相当于流的指针在首端 new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端 write(int)：写入单个字符 write(char[])：写入指定数组 write(char[],off,len)：写入指定数组的指定部分 write(String)：写入整个字符串 write(String,off,len)：写入字符串的指定部分  相关API\n toCharArray：将String转换成char[];  注意：\n  FileWriter使用后，必须关闭(close)或刷新(flush),否则写入不到指定的文件\n  FileWriter的类图如下\n  FileWriter的使用\npackage com.java_io; import org.junit.Test; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; public class FileWriterTest { public static void main(String[] args) { } @Test public void FileWriter(){ String filePath = \u0026#34;e:\\\\note.txt\u0026#34;; FileWriter fileWriter = null; String str = \u0026#34;AD\u0026#34;; char [] chars ={\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}; int writerLen = 3; try { fileWriter = new FileWriter(filePath,true); fileWriter.write(\u0026#39;H\u0026#39;); fileWriter.write(\u0026#34;\\n\u0026#34;);//换行  fileWriter.write(str); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(chars); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(chars,0,writerLen); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(str,0,1); } catch (IOException e) { e.printStackTrace(); } finally { try { fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } }   如果需要换行或者输入制表符则可以\nfileWriter.write(\u0026#34;\\n\u0026#34;);//换行 fileWriter.write(\u0026#34;\\t\u0026#34;);//制表符     节点流和处理流   节点流可以从一个特定的数据源读写数据\n  处理流(包装流)是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter\n  分析BufferedReader处理流\n查看BufferedReader的源码可以知道，BufferedReader中定义了一个Reader属性，即他可以封装任意一个节点流，所以使用BufferedReader去操作的时候，其可以访问各种不同的数据源。其功能更为强大\nBufferedWriter同理。\n  节点流与处理流的区别和联系\n 节点流是底层流/低级流，直接跟数据源相接。 处理流(包装流)包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出 处理流(包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连    模拟装饰者设计模式来理解处理流BufferedReader/BufferedWriter\n创建Reader抽象类(Reader_)\npackage com.decorator_pattern; public abstract class Reader_ { public void readString(){ } public void readFile(){ } } 创建节点流子类FileReader_\npackage com.decorator_pattern; public class FileReader_ extends Reader_{ public void readFile(){ System.out.println(\u0026#34;readFile\u0026#34;); } } 创建节点流子类StringReader_\npackage com.decorator_pattern; public class StringReader_ extends Reader_{ public void readString(){ System.out.println(\u0026#34;readString\u0026#34;); } } 创建处理流BufferedReader_\npackage com.decorator_pattern; public class BufferedReader_ extends Reader_{ private Reader_ reader_;//属性时Reader_类型  public BufferedReader_(Reader_ reader_) { this.reader_ = reader_; } //封装方法  public void readFile(){ reader_.readFile(); } //装饰者模式的特性：增加新功能  public void readStrings(int num){ for (int i = 0; i \u0026lt; num; i++) { reader_.readString(); } } } Test类\npackage com.decorator_pattern; public class Test { public static void main(String[] args) { //新建bufferedReader_对象，把FileReader_传进去，使方法可以对文件操作  BufferedReader_ bufferedReader_1 = new BufferedReader_(new FileReader_()); bufferedReader_1.readFile(); //必须是相应的对象的方法才会有用  bufferedReader_1.readStrings(10);//无效  //新建bufferedReader_对象，把StringReader_传进去，使方法可以对字符串操作  BufferedReader_ bufferedReader_2 = new BufferedReader_(new StringReader_()); bufferedReader_2.readStrings(10); } } 测试结果\n通过上述设计模式可以让BufferedReader包装其他节点流，这样子就能提高对数据源操作的效率\n可以使用统一的一个read方法来优化上述代码。如：\n在Reader_抽象类中使用抽象方法read\npackage com.decorator_pattern; public abstract class Reader_ { public abstract void read(); } 然后子类实现此方法即可\npackage com.decorator_pattern; public class FileReader_ extends Reader_{ public void read(){ System.out.println(\u0026#34;readFile\u0026#34;); } } 此时，想要操作相应的数据则需要利用对象的动态绑定机制，绑定到对应的实现子类即可\t。\n所以Test中的\n//多态性，因为bufferedReader_1是new了FileReader_对象，所以去找FileReader_对象  bufferedReader_1.readStrings(10); 能输出readFile。\n  处理流的功能\n 性能的提高：主要以增加缓冲的方式来提高输入输出的效率 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便    ","date":"2021-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java_io%E6%B5%81/","title":"Java_IO流"},{"content":"单例设计模式 什么是设计模式  静态方法和属性的经典实用 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索  什么是单例模式   单例：就是单个的实例\n  所谓的类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法\n  单例模式有两种方式：\n  饿汉式（只有类被加载了，该对象就会被创建）\n 将构造器私有化 在类的内部之间创建（该对象是static） 提供一个公共的static方法，返回对象  例如，我们规定一个人必须专一，只能有一个女朋友！\npackage com.singleton; public class SingleTon { public static void main(String[] args) { GirlFriend instance = GirlFriend.getInstance(); System.out.println(instance); //无论你怎么创建，该对象都是同一个  GirlFriend instance1 = GirlFriend.getInstance(); System.out.println(instance1); //返回结果为True  System.out.println(instance==instance1); } } class GirlFriend{ private String name ; //在类内部创建了对象，加static是为了可以在静态方法中返回girlFriend对象  private static GirlFriend girlFriend = new GirlFriend(\u0026#34;小红\u0026#34;); //构造器私有化  private GirlFriend(String name){ this.name = name; } public static GirlFriend getInstance(){ return girlFriend; } @Override public String toString() { return \u0026#34;GirlFriend{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 由于类被加载之后，对象无论如何都会被创建，会造成资源的浪费。\npackage com.singleton; public class SingleTon { public static void main(String[] args) { System.out.println(GirlFriend.n); } } class GirlFriend{ private String name ; public static int n = 100; //对象，通常是重量级的对象，饿汉模式可能造成创建了对象，但没有使用  private static GirlFriend girlFriend = new GirlFriend(\u0026#34;小红\u0026#34;); //构造器私有化  private GirlFriend(String name){ System.out.println(\u0026#34;构造器被调用了\u0026#34;); this.name = name; } public static GirlFriend getInstance(){ return girlFriend; } @Override public String toString() { return \u0026#34;GirlFriend{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 使用懒汉式可以很好的解决这个问题\n  懒汉式（不调用就不会创建对象）\n 将构造器私有化 定义一个static静态属性对象 提供一个public的static方法，可以返回一个对象  懒汉式：只有当用户使用getInstance时才会返回一个对象。后面再调用时，会返回上次创建的对象\npackage com.singleton; public class SingleTon01 { public static void main(String[] args) { System.out.println(Cat.n); System.out.println(\u0026#34;================\u0026#34;); Cat cat = Cat.getInstance(); System.out.println(cat); } } class Cat{ private String name; public static int n = 100; private static Cat cat; private Cat(String name){ System.out.println(\u0026#34;构造器被调用\u0026#34;); this.name = name; } public static Cat getInstance(){ //判断有没有创建Cat对象  if(cat == null){ cat = new Cat(\u0026#34;miao\u0026#34;); } return cat; } @Override public String toString() { return \u0026#34;Cat{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }     饿汉式VS懒汉式\n 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例而懒汉式是在使用时才创建 饿汉式不存在线程安全问题，懒汉式存在线程安全问题 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。 在我们的JavaSE标准类中，java.lang.Runtime就是经典的单例模式    ","date":"2021-05-28T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"Java单例模式"},{"content":"JavaInterface   接口的基本介绍 接口的注意事项及使用细节 接口实现与类的继承 接口的多态性   接口基本介绍   接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。\n接口的定义：\ninterface 接口名{ //属性  //方法 } 类实现接口:\nclass ClassName implements Interface { //自己的属性  //自己的方法  //必须实现的接口的抽象方法 }   在jdk7前，接口里的所以方法都没有方法体，即都是抽象方法。\n  jdk8后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。但默认方法需要使用default关键字修饰\n  在接口中，定义抽象方法时可以省略abstract关键字。如果一个类实现了接口，则需要把接口的所有抽象方法都实现。\n代码演示\n创建接口Interface01\npackage com.interface_; public interface Interface01 { //定义属性  public int n =1; //定义抽象方法  public void A(); //定义默认方法  default public void B(){ System.out.println(\u0026#34;我是默认方法\u0026#34;); } //定义静态方法  public static void C(){ System.out.println(\u0026#34;我是静态方法\u0026#34;); } } 创建实现类InterfaceImp01\npackage com.interface_; public class InterfaceImp01 implements Interface01{ @Override public void A() { System.out.println(\u0026#34;实现抽象方法\u0026#34;); } @Override public void B() { Interface01.super.B(); } } 创建测试类InterfaceTest\npackage com.interface_; public class InterfaceTest { public static void main(String[] args) { InterfaceImp01 interfaceImp01 = new InterfaceImp01(); interfaceImp01.A(); interfaceImp01.B(); //调用静态方法  Interface01.C(); } } 输出结果：\n  对于初学者来说，接口的概念不难理解。难的是不知道什么时候使用接口，下面例举应用场景来理解接口的使用：\n 现在要制作战斗机，武装直升机。专家只需要把飞机需要的功能/规格定下来即可，然后让工程师来实现 现在有一个项目经理，管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员来实现。    接口的注意事项与使用细节   接口不能被实例化\n  接口中所有的方法都是public，接口中的抽象方法可以不用abstract修饰\ninterface Interface{ void say(); //相当于  public abstract void say(); }   一个普通类实现接口，就必须将该接口的所有方法都实现(可以使用alt+enter来解决)\n  抽象类去实现接口时，可以不实现接口的抽象方法\n  一个类可以同时实现多个接口。\n创建接口Interface01\ninterface Interface01{ say(); } 创建接口Interface02\ninterface Interface02{ hi(); } 实现类dog\nclass dog implements Interface01,Interface02{ @Override public void hi(){ } @Override public void say(){ } }   接口中的属性只能是final，而且是public static final修饰符。属性的访问形式为接口名.属性名\ninterface Interface01{ int n = 1; //实际上是  public static final int n = 1;//必须初始化值 } 证明：创建测试类InterfaceTest\npackage com.interface_; public class InterfaceTest { public static void main(String[] args) { //此处可以直接调用接口Interface01的属性，证明该属性为static  Interface01.n; Interface01.n = 10;//系统会报错，证明该属性被final修饰  } }   接口不能继承其他的类，但是可以继承其他接口。\ninterface Interface03 extends Interface01,Interface02{ } 而且继承其他接口时不用实现其他接口的方法。\n  接口的修饰符与类一样，只能是public或者是默认\n  思考题：下面程序是否正确，正确的话输出什么？\n//创建接口 public interface Interface02 { int a = 23; } //创建接口实现类 public class InterfaceImp02 implements Interface02{ } //创建测试类 public class InterfaceTest { public static void main(String[] args) { InterfaceImp02 imp02 = new InterfaceImp02(); System.out.println(imp02.a); //因为InterfaceImp02实现了接口Interface02 所以也可以成功输出  System.out.println(InterfaceImp02.a); //a为static属性，所以可以输出  System.out.println(Interface02.a); } } 代码正确，输出结果为\n  接口实现与类继承   当子类继承了父类，就会**自动的拥有父类的功能(方法)。**而如果子类需要拓展功能，可以通过实现接口的方式拓展\n  可以理解成实现接口就是对Java单继承机制的一种补充\n下面举个例子理解接口实现与类继承\n例：假如有一只小猴子悟空，他继承了父亲的爬树技能。当他看到鱼儿在游泳时，就跟鱼儿学习了游泳技能；当他看到鸟儿在飞翔时，就跟鸟儿学习了飞翔技能\u0026hellip;\n代码演示：\n创建猴子父类 Monkey\npackage com.interface_; public class Monkey { private String name; public Monkey(String name) { this.name = name; } public void climbing(){ System.out.println(name + \u0026#34;在爬树\u0026#34;); } } 子类LittleMonkey\npackage com.interface_; public class LittleMonkey extends Monkey{ public LittleMonkey(String name) { super(name); } } 此时，LittleMonkey继承了Monkey，所以很自然的会爬树\n因为悟空需要拓展技能，我们创建接口FishAble和BirdAble\npackage com.interface_; public interface FishAble { public void Swimming(); } package com.interface_; public interface BirdAble { public void flying(); } 而且LittleMonkey也实现了FishAble与BirdAble\npackage com.interface_; public class LittleMonkey extends Monkey implements BirdAble,FishAble{ public LittleMonkey(String name) { super(name); } @Override public void flying() { System.out.println(this.getName()+\u0026#34;通过学习，学会了飞翔\u0026#34;); } @Override public void Swimming() { System.out.println(this.getName()+\u0026#34;通过学习，学会了游泳\u0026#34;); } } 最终，悟空学会了飞翔与游泳\npublic class InterfaceTest { public static void main(String[] args) { LittleMonkey wuKong = new LittleMonkey(\u0026#34;悟空\u0026#34;); wuKong.climbing(); wuKong.flying(); wuKong.Swimming(); } }   实现接口VS继承类\n接口和继承解决的问题不同\n 继承的价值主要在于：解决代码的复用性和可维护性 接口的价值主要在于：设计好各种规范（方法），让它的实现类去实现这些方法。更加的灵活  接口比继承更加灵活\n  继承是满足is-a的关系，而接口只需满足like-a的关系即可。\n比如：猫它是动物(is-a)，而猫像鱼一样会游泳(like-a)\n  接口在一定程度上实现代码解耦（即：接口的规范性+动态绑定机制）\n  接口的多态性   接口类型的变量可以指向实现了接口类的对象实例\npackage com.interface_; public class InterfacePolyParameter { public static void main(String[] args) { //接口的多态体现  IF if01 = new Monster(); if01 = new Car(); } } interface IF{} class Monster implements IF{} class Car implements IF{}     多态参数的体现\n演示一个案例：有一个接口UsbInterface usb，既可以接收手机对象，又可以接收相机对象，就体现了接口的多态（接口引用可以指向实现了接口的类的对象）\n创建接口UsbInterface\npackage com.interface_; public interface UsbInterface { void start(); void stop(); } 创建接口实现类Phone1\npackage com.interface_; public class Phone1 implements UsbInterface{ @Override public void start() { System.out.println(\u0026#34;Phone开始工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Phone停止工作\u0026#34;); } } 创建接口实现类Camera1\npackage com.interface_; public class Camera1 implements UsbInterface{ @Override public void start() { System.out.println(\u0026#34;Camera开始工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Camera停止工作\u0026#34;); } } 创建类Computer01\npackage com.interface_; public class Computer01 { //1. UsbInterface usbInterface 说明Work的形参类型是UsbInterface  //2. 这个参数可以接收实现了UsbInterface接口的类的对象实例  public void Work(UsbInterface usbInterface){ usbInterface.start(); usbInterface.stop(); } } Tset\npackage com.interface_; public class InterfaceTest02 { public static void main(String[] args) { //创建手机对象，Phone1实现了UsbInterface接口  Phone1 phone1 = new Phone1(); //创建相机对象，Camera1实现了UsbInterface接口  Camera1 camera1= new Camera1(); //创建计算机对象  Computer01 computer01 = new Computer01(); //把手机接入电脑  computer01.Work(phone1); System.out.println(\u0026#34;===============\u0026#34;); //把相机接入电脑  computer01.Work(camera1); } } 运行结果\n  多态数组的体现\n演示一个案例：给定Usb数组中，存放Phone和Camera对象，Phone类还有一个特有的方法call()，请遍历Usb数组，如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用Phone特有方法call。\n创建接口Usb\ninterface Usb{ void Work(); } 创建接口实现类Phone2与Camrea2\nclass Phone2 implements Usb{ @Override public void Work() { System.out.println(\u0026#34;Phone工作了\u0026#34;); } public void call(){ System.out.println(\u0026#34;Phone打电话\u0026#34;); } } class Camera2 implements Usb{ @Override public void Work() { System.out.println(\u0026#34;Camera工作了\u0026#34;); } } 创建测试类InterfacePolyAry\npackage com.interface_; public class InterfacePolyAry { public static void main(String[] args) { //多态数组 -\u0026gt;接口类型数组  Usb[] usbs = new Usb[2]; usbs[0] = new Phone2(); usbs[1] = new Camera2(); for (int i = 0; i\u0026lt;usbs.length; i++){ usbs[i].Work();//多态绑定  //需要进行类型的向下转型  if(usbs[i] instanceof Phone2){ ((Phone2) usbs[i]).call(); } } } } 运行结果\n    接口存在多态传递现象（代码演示）\n创建接口InterfacePoly1\ninterface InterfacePoly1{ void hi(); } 创建接口InterfacePoly2继承了接口创建接口InterfacePoly1\ninterface InterfacePoly2 extends InterfacePoly1{ } 创建接口实现类InterfacePolyImp\nclass InterfacePolyImp implements InterfacePoly2{ @Override public void hi() { System.out.println(\u0026#34;hi\u0026#34;); } } 创建测试类InterfacePolyPass\npackage com.interface_; public class InterfacePolyPass { public static void main(String[] args) { //接口类型的变量可以指向实现了该接口的对象实例  InterfacePoly2 interfacePoly2 = new InterfacePolyImp(); //如果InterfacePoly2继承了InterfacePoly1接口，而InterfacePolyImp实现了InterfacePoly2接口  //那么实际上就相当于InterfacePolyImp实现了InterfacePoly1接口  //这就是所谓的接口多态传递现象  InterfacePoly1 interfacePoly1 = new InterfacePolyImp(); } }   ","date":"2021-05-04T16:22:25+08:00","permalink":"https://minster77.github.io/p/javainterface/","title":"JavaInterface"},{"content":"JavaException   什么是异常 异常体系结构 Java异常处理机制 自定义异常 总结   1、什么是异常   软件程序在运行过程中，非常可能遇到一些异常问题，在Java中称为异常。\n  异常指程序运行中出现的不期而至的各种状况，如文件找不到、网络连接错误等。\n  需要掌握的三种类型的异常\n 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常：运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。 错误ERROR：错误不是异常，而是脱离程序员控制的问题。    2、异常体系结构   在Exception分支中有一个重要的子类RuntimeException(运行时异常)\n ArrayIndexOutOfBoundsException(数组下标越界异常) NullPointerException(空指针异常) ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFountException（找不到类）  等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。\n  这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n  Exception与Error的区别\n Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程 Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能去处理这些异常    3、异常处理机制   当编写的代码出现异常时，程序会自动报出现异常错误\npackage com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; System.out.println(a/b); } } 控制台会报出Exception\n  在代码中加入了try\u0026hellip;catch\u0026hellip;finally异常处理机制\npackage com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; try{//监控区域  System.out.println(a/b); }catch (ArithmeticException e){//catch 捕获异常  System.out.println(\u0026#34;程序出现错误，变量b不能为0\u0026#34;); }finally {//处理后续工作  System.out.println(\u0026#34;finally\u0026#34;); } } } finally在异常捕获块中主要用于一些IO流及资源的关闭工作，可以不写。\ncatch里面的参数表示想要捕获的异常类型，Throwable为最高异常\n  假设要捕获多个异常，需要从小到大的去捕获\n  throw与throws主动抛出异常，前者用在方法中，后者用在方法上\npackage com.exception; public class Throw { public static void main(String[] args) { try { new Throw().test(1,0); } catch (ArithmeticException e) { e.printStackTrace(); } } //假设在方法中，处理不了这个异常，就用throws在方法上抛出  public void test(int a,int b)throws ArithmeticException{ if(b==0){ throw new ArithmeticException(); } } }   4、自定义异常   使用Java内置的异常类可以描述在编程中出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即刻。\n  在程序中自定义异常类，大体可以分为一次啊几个步骤：\n 创建自定义异常类 在方法中通过throw关键字抛出异常对象 如果在抛出异常的方法中处理异常，可以使用try\u0026hellip;catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续下一步操作 在出现异常方法类的调用中捕获并处理异常。  创建MyException异常类\npackage com.exception.demo02; //自定义异常类 public class MyException extends Exception{ int a = 5; public MyException(int a){ this.a = a; } @Override public String toString() { return \u0026#34;MyException{\u0026#34; + \u0026#34;a=\u0026#34; + a + \u0026#39;}\u0026#39;; } } 测试类Test\npackage com.exception.demo02; import com.oop.Tset; public class Test { public static void test(int a) throws MyException { System.out.println(\u0026#34;传递的参数为\u0026#34;+a); if(a\u0026gt;5){//如果参数大于5，抛出异常  throw new MyException(a); } System.out.println(\u0026#34;OK\u0026#34;); } public static void main(String[] args) { try { test(10); } catch (MyException e) {//捕获异常  System.out.println(e); } } }   5、总结  处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 对于不确定的代码，也可以加上try-catch处理潜在的异常 尽量去处理异常，切记知识简单地调用printStackTrace去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句去释放占用的资源  ","date":"2021-05-03T16:22:25+08:00","image":"https://minster77.github.io/Java_Exception.jpg","permalink":"https://minster77.github.io/p/javaexception/","title":"JavaException"},{"content":"Java内部类   内部类的基本介绍 局部内部类 匿名内部类 成员内部类 静态内部类   内部类基本介绍   一个类的内部又完整的嵌套了另一个类结构。被嵌套的类又称为内部类，嵌套其他类的类称为外部类。是类的五大成员之一（属性、方法、构造器、代码块、内部类）。\n  内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\n  基本语法\nclass Outer{//外部类  class Inner{//内部类  } } class Other{//外部其他类  }   内部类的分类\n 定义在外部类的局部位置上（比如方法内）：  局部内部类（有类名） 匿名内部类（没有类名，重点！）   定义在外部类的成员位置上：  成员内部类（没用static修饰） 静态内部类（使用static修饰）      局部内部类 说明：局部内部类是定义在外部类的局部位置上的，通常在方法中，并且有类名。\n  可以直接访问外部类的所有成员，包含私有的\n  不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final。（使用了final说明该内部类不能被继承！）\n  作用域：仅仅在定义它的方法或代码块中。\n  局部内部类访问外部类的成员（访问方式：直接访问）\n  外部类访问局部内部类的成员（访问方式：创建对象，再访问[注意，必须在作用域内！]）\n代码演示\npackage com.innerclass; public class LocalInnerClass { public static void main(String[] args) { Outer01 outer01 = new Outer01(); outer01.m2(); } } class Outer01{ private int n = 100; private void m1(){ System.out.println(\u0026#34;m1\u0026#34;); } public void m2(){ //定义为final就不能被继承  //作用域：定义它的方法或代码块中  final class Inner01{//局部内部类  public void f1(){ //访问外部类的成员属性n与m1  System.out.println(\u0026#34;n = \u0026#34;+ n); m1(); } } //外部类调用必须在内部类的作用域内！  Inner01 inner01 = new Inner01(); inner01.f1(); } }     外部其他类不能访问局部内部类！因为局部内部类是一个局部变量\n  如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想要访问外部类的成员，则可以使用(外部类目.this.成员)去访问。\nSystem.out.println(\u0026#34;OuterClass的n2 = \u0026#34;+ OuterClass.this.n2); OuterClass.this本质就是外部类的对象，即哪个对象调用了内部类作用域的方法，OuterClass.this就是哪个对象\n  匿名内部类 说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名（系统的底层有给他分配名字）。\n  匿名内部类的基本语法\nnew 类或接口(参数列表){ //类体 };   匿名内部类的本质（代码演示）\n有一个需求，想要使用AnonInterface接口，并创建对象。\n传统的方式是写一个类，实现该接口，并创建其对象。\nAnonmousInterface接口\ninterface AnonInterface{ public void cry(); } Tiger类\nclass Tiger implements AnonInterface{ public void cry(){ @Override System.out.println(\u0026#34;Titge 在叫\u0026#34;); } } 然后在main函数创建其对象即可\npackage com.innerclass; public class AnonymousInnerClass { public static void main(String[] args) { AnonInterface tiger = new Tiger(); tiger.cry(); } } 如果我们现在的需求改为Tiger类只使用一次，后面不再使用时。我们可以使用匿名内部类来简化开发。\nAnonInterface接口\ninterface AnonInterface{ public void cry(); } 外部类Outer02\nclass Outer02{ private int n = 10; public void method(){ //使用匿名内部类  AnonInterface tiger = new AnonInterface(){ @Override public void cry() { System.out.println(\u0026#34;tiger 在叫\u0026#34;); } }; tiger.cry(); } } main\npackage com.innerclass; public class AnonymousInnerClass { public static void main(String[] args) { Outer02 outer02 = new Outer02(); outer02.method(); } } 上述代码与传统方式均实现了需求，而且上面的代码，Tiger类只使用了一次。这就是匿名内部类的奇妙之处！\n思考：上述外部类Outer02中，Tiger的编译类型及运行类型分别是什么？\n  Tiger的编译类型为接口AnonInterface\n  Tiger的运行类型为匿名内部类 Outer02$1\n其实在使用匿名内部类时，底层是给该内部类分配了名字的\nClass Outer02$1 implements AnonInterface{ @Override pubilc void cry(){ System.out.println(\u0026#34;Tiger 在叫\u0026#34;); } } 我们通过getclass()方法可以验证上述代码。\nSystem.out.println(tiger.getClass()); 而且，在外部类Outer02中，AnonInterface tiger = new AnonInterface()这条语句的执行，jdk底层会在创建匿名内部类Outer02$1时，立刻创建Outer02$1实例，并且把地址返回给tiger\n  需要注意的是：匿名内部类Outer02$1是只使用一次，就不能再使用。而对象Tiger能重复使用！\n基于类构建的匿名内部类也与上述大体一致。\n  匿名内部类的细节\n  匿名内部类的语法比较奇特，需要注意的是，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征。因此可以直接调用匿名内部类的方法。\n代码演示：\n创建Person类\nclass Person{ public void hi(){ System.out.println(\u0026#34;hi\u0026#34;); } public void sayHi(String name){ System.out.println(\u0026#34;Hi \u0026#34;+name); } } 创建外部类Outer03\nclass Outer03{ private int i = 10; public void f1(){ Person person = new Person(){ @Override public void hi() { System.out.println(\u0026#34;匿名内部类重写了Hi方法\u0026#34;); } }; //动态绑定，person的运行类型是Outer03$1  person.hi(); //因为匿名内部类返回的是一个对象（new），所以可以直接调用方法  //在底层 class 匿名内部类 extends Person  new Person(){ @Override public void sayHi(String name) { super.sayHi(name); } }.sayHi(\u0026#34;jack\u0026#34;); } } 创建AnonymousInnerClassDetail\npackage com.innerclass; public class AnonymousInnerClassDetail { public static void main(String[] args) { Outer03 outer03 = new Outer03(); outer03.f1(); } } 输出结果：\n  外部其他类不能访问匿名内部类\n    匿名内部类的实践\n匿名内部类可以当做实参直接传递，简洁高效，避免硬编码\n创建接口InterfaceExercise\ninterface InterfaceExercise{ public void show(); } 创建InnerClassExercise01\npackage com.innerclass; public class InnerClassExercise01 { public static void main(String[] args) { //匿名内部类做形参，简洁高效。  f1(new InterfaceExercise(){ @Override public void show() { System.out.println(\u0026#34;这是一幅名画...\u0026#34;); } }); } //静态方法，参数是接口类型  public static void f1(InterfaceExercise iE){ iE.show(); } } 如果使用实现类实现该接口，那修改一个实现类的对象时会影响到其他的实现类对象。而使用匿名内部类，可以避免这个问题，并且这个类只使用一次即可。\n  成员内部类 说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。\n  可以直接访问外部类的所有成员，包含私有的\n  可以添加任意访问修饰符(public,protected,默认,private)，因为它的地位就是一个成员。\n代码演示：\n创建外部类Outer05\nclass Outer05{ private int i = 10; //定义在成员位置上，可以添加修饰符！  public class Inner04{ public void say(){ //可以访问外部类的私有属性  System.out.println(\u0026#34;成员内部类 i = \u0026#34;+i); } } //因为作用域是方法或代码块内，所以需要写一个方法来使用内部类  public void t1(){ Inner04 inner04 = new Inner04(); inner04.say(); } } 创建测试类MemberInnerClass\npackage com.innerclass; public class MemberInnerClass { public static void main(String[] args) { Outer05 outer05 = new Outer05(); outer05.t1(); } } 运行结果：\n  作用域与外部类的其他成员一样，为整个类体。比如上述案例，在外部类的成员方法中创建成员内部类对象，再调用方法。\n  外部其他类可以访问成员内部类\n外部其他类使用成员内部类的两种方式\n第一种方式\n//第一种方式 //outer05.new Inner04();相当于把 new Inner04()当做是outer05的成员 Outer05.Inner04 inner04 = outer05.new Inner04(); 第二种方式\n//在外部类中编写一个方法，可以返回一个Inner04的值 Outer05.Inner04 getInner04 = outer05.getInner04(); 外部类Outer05中\n//该方法返回一个成员内部类 Inner04 getInner04(){ return new Inner04(); }   静态内部类 说明：静态内部类定义在外部类的成员位置，并且有static修饰\n  可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问非静态成员\n  可以添加任意访问修饰符(public,protected,默认,private)，因为它的地位就是一个成员。\n  作用域：同其他成员，为整个类体\n代码演示\n创建Outer06类\nclass Outer06{ private int n1 = 10; private static int n2 = 100; static class Inner06{ void say(){ System.out.println(\u0026#34;hi n = \u0026#34; + n2); } } void t1(){ Inner06 inner06 = new Inner06(); inner06.say(); } } 创建测试类StaticInnerClass\npackage com.innerclass; public class StaticInnerClass { public static void main(String[] args) { Outer06 outer06 = new Outer06(); outer06.t1(); } } 运行结果：\n  静态内部类要访问外部类的话，可以访问其全部静态成员。\n  外部类访问静态内部类，需要先创建对象，再访问。\n  外部其他类使用静态内部类的方式有两种，与成员内部类的一样。\n  ","date":"2021-05-03T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%86%85%E9%83%A8%E7%B1%BB/","title":"Java内部类"},{"content":"深入面向对象   面向对象三大特性 static关键字详解 抽象类和接口 内部类及OOP实战   面向对象三大特性 封装   我们在程序设计中要追求“高内聚，低耦合”。\n 高内聚：就是类的内部数据操作细节由自己完成，不允许外部干涉 仅暴露少量的方法给外部使用    所以在设计时需要把一些数据与方法封装起来（数据的隐藏）\n  属性私有，get/set调用\n  作用\n 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 增加了系统可维护性    代码演示\nStudent类\npackage com.oop.demo02; //学生类 public class Student { private String name; private int age; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } Test类\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Student s1 = new Student(); s1.setName(\u0026#34;成志恒\u0026#34;); s1.setAge(21); s1.setSex(\u0026#34;男\u0026#34;); System.out.println(s1.getName()+\u0026#34; \u0026#34;+s1.getAge()+\u0026#34; \u0026#34;+s1.getSex()); } }   继承   继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\n  JAVA中类只有单继承，没有多继承\n  在java中，所有类都默认直接或者间接继承Object类\n继承使用关键字extends来表示，代码示例如下\nPerson类\npackage com.oop.demo03; public class Person { public int money = 10000; public String name = \u0026#34;mayun\u0026#34;; } Person类为父类，只定义了两个属性\nStudent类\npackage com.oop.demo03; public class Student extends Person{ public void print(){ System.out.println(this.money+\u0026#34; \u0026#34;+this.name); } } Student类为子类，继承了父类的属性与方法\nTest类\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); student.print(); } } 结果：\n由此可见，在Java中通过extends实现继承关系，而子类可以使用父类中的属性与方法（私有的不能调用）。\n  在继承中，当子类中有与父类相同的属性或方法时，可以使用super关键字来调用父类的属性或方法\n  super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。\n代码示例：\nPerson类\npackage com.oop.demo03; public class Person { public int money = 10000; public String name = \u0026#34;Person\u0026#34;; public void print(){ System.out.println(\u0026#34;Person调用了\u0026#34;); } } Student类\npackage com.oop.demo03; public class Student extends Person{ public int money = 50000; public String name = \u0026#34;Student\u0026#34;; public void print(){ System.out.println(\u0026#34;Student调用了\u0026#34;); } public void test(String name){ System.out.println(name); System.out.println(this.name); System.out.println(super.name); } public void test1(){ print();//子类的方法  this.print();//子类的方法  super.print();//父类的方法  } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); student.test(\u0026#34;成志恒\u0026#34;); System.out.println(); student.test1(); } } 运行结果:\n可以看到，this调用的是Student类中本身的值，super调用了Person类中的值。方法亦如此\n  super调用构造器\nPerson类\npackage com.oop.demo03; public class Person { public Person(){ System.out.println(\u0026#34;Person无参执行了\u0026#34;); } } Student类\npackage com.oop.demo03; public class Student extends Person{ public Student(){ System.out.println(\u0026#34;Student无参执行了\u0026#34;); } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); } } 由此可见在Student类中的无参构造器默认调用了Person类中的无参构造器，即隐藏使用了super()方法。\n需要注意的是，super()方法必须要在子类构造器的第一行，否则系统会报错\n  super的注意点\n super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super与this不能同时调用构造方法    super与this的对比\n  代表的对象不同\nthis：本身调用者这个对象\nsuper：代表父类对象的应用\n  前提\nthis：没有继承也可以使用\nsuper：只能在继承条件才可以使用\n  构造方法\nthis()：本类的构造\nsuper()：父类的构造\n    方法的重写(父类的功能，子类不一定需要，所以要重写)\n 需要有继承关系，子类重写父类的方法，与属性无关 重写只跟非静态方法有关，方法名必须相同 参数列表必须相同 子类的方法必须要和父类的一致，方法体不同 IDEA快捷键：Alt+Insert ：override；  代码：\n父类B\npackage com.oop.demo03; public class B { public static void test1(){ System.out.println(\u0026#34;B==\u0026gt;test\u0026#34;); } public void test2(){ System.out.println(\u0026#34;B==\u0026gt;test\u0026#34;); } } 子类A\npackage com.oop.demo03; public class A extends B { public static void test1(){ System.out.println(\u0026#34;A==\u0026gt;test\u0026#34;); } @Override//注解（重写用）  public void test2() { System.out.println(\u0026#34;A==\u0026gt;test\u0026#34;); } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { A a = new A(); //父类的引用指向了子类  B b = new A(); a.test1(); b.test1(); System.out.println(\u0026#34;==============\u0026#34;); a.test2();//子类重写了父类的方法  b.test2(); } }   静态方法和非静态方法的区别\n 静态方法：方法的调用只与左边定义的数据类型有关 非静态：重写    多态   即同一方法可以根据发送对象的不同而采用多种不同的行为方式\n  一个对象的实际类型是确定的，但可以指向对象的引用类型有很多\n  对象能执行哪些方法，主要看左边的类型，与右边关系不大\n  多态存在的条件\n 有继承关系 子类重写父类的方法 父类引用子类对象  代码示例\nPerson类\npackage com.oop.demo04; public class Person { public void run(){ System.out.println(\u0026#34;run\u0026#34;); } } Student类\npackage com.oop.demo04; public class Student extends Person{ } Test\npackage com.oop.demo04; public class Test { public static void main(String[] args) { //一个对象的实际类型是可以确定的  //new Student  //new Person  //但可以指向的引用类型就不确定了：父类的引用指向子类  Student s1 = new Student(); Person s2 = new Student(); Object s3 = new Student(); s1.run(); s2.run(); } } 可以知道虽然s1，s2，s3的对象都是Student，但是它可以有不同的父类的引用，这就是方法的多态。\n如果子类重写了父类的方法，则执行子类的方法\n在Studunt类中重写run方法\npackage com.oop.demo04; public class Student extends Person{ @Override public void run() { System.out.println(\u0026#34;son run\u0026#34;); } } 运行结果：\n 假如在子类中写一个独有的方法，s2可以调用吗？\nStudent类\npackage com.oop.demo04; public class Student extends Person{ @Override public void run() { System.out.println(\u0026#34;son run\u0026#34;); } public void eat(){ System.out.println(\u0026#34;eat\u0026#34;); } } 在Student类中加了一个eat方法\n如果使用Test类中的s2调用这个方法，系统会报错\n所以父类可以指向子类，但是不能调用子类独有的方法\n  多态的注意事项：\n 多态是方法的多态，属性没有多态性 父类和子类需要有联系，不然会有类型转换异常(ClassCastException)    instanceof 是 Java 的一个二元操作符，类似于 ==，\u0026gt;，\u0026lt; 等操作符。\n  instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。\npackage com.oop.demo05; public class Test { public static void main(String[] args) { //Object \u0026gt; String  //Object \u0026gt; Person \u0026gt; Student  //Object \u0026gt; Person \u0026gt; Teacher  Object object = new Student(); System.out.println(object instanceof Student); System.out.println(object instanceof Person); System.out.println(object instanceof Object); System.out.println(object instanceof String); System.out.println(object instanceof Teacher); } }   ​\t需要注意的是若比较的两个类毫无联系，编译器会报错\n​\t  类型转换\n 父类引用指向子类的对象 把子类转换为父类：向上转型 把父类转换为子类：向下转型，强制转换  package com.oop.demo05; public class Test { public static void main(String[] args) { Student student = new Student(); student.run();//子类能直接调用父类的方法  Person person = student; ((Student)person).eat();//父类调用子类的方法需要强制转换  } }   Static关键字详解   static标注的属性或方法为静态属性或方法。\n  static(静态)方法只会在类加载的时候执行一次。\npackage com.oop.demo06; public class Person { //先与构造方法执行，可以用来定义常量  { System.out.println(\u0026#34;匿名代码块\u0026#34;); } //最先执行，但只执行一次  static { System.out.println(\u0026#34;静态代码块\u0026#34;); } //最后执行  Person(){ System.out.println(\u0026#34;构造方法\u0026#34;); } public static void main(String[] args) { Person person = new Person(); System.out.println(\u0026#34;================\u0026#34;); Person person1 = new Person(); } }   static关键字还可以用来静态导入包\n正常来说要使用Math类的方法每一次都需要在方法前面加\u0026quot;Math.\u0026quot;\nSystem.out.println(Math.random()); 否则会报错\n但是如果通过static导入包的话，就可以直接使用了\npackage com.oop; import static java.lang.Math.random; public class Tset { public static void main(String[] args) { System.out.println(random()); } }   抽象类和接口 抽象类   abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类，那么该类就是抽象类\npackage com.oop.demo08; //抽象类 public abstract class Action { //抽象方法  public abstract void run(); }   抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类\npackage com.oop.demo08; public abstract class Action { public abstract void run(); public void go(){ System.out.println(\u0026#34;go\u0026#34;); } }   抽象类不能new 只能靠子类去实现它\n  抽象类存在的意义：在一些复杂的项目中，把公有属性抽象出来，再使用时只需要继承这个抽象类即可，提高开发效率。\n  接口   接口就是规范，定义的是一组规则，体现了现实世界中“如果你是\u0026hellip;则必须能\u0026hellip;”的思想。\n  接口的本质是契约。\n  接口中的所有定义的方法都是public abstract的；属性为常量。\n  接口定义的关键字为interface，接口都需要有实现类\n接口UserService\npackage com.oop.demo09; public interface UserService { void add(String name); void delete(String name); void update(String name); void query(String name); } 实现类UserServiceImp\npackage com.oop.demo09; //实现了接口的类就必须要实现接口中的所有方法 public class UserServiceImp implements UserService{ @Override public void add(String name) { } @Override public void delete(String name) { } @Override public void update(String name) { } @Override public void query(String name) { } }   利用接口可以实现多继承！\n接口TimeService\npackage com.oop.demo09; import java.sql.Time; public interface TimeService { Time timer(); } 接口RunService\npackage com.oop.demo09; public interface RunService { void run(); } 实现类TestImp\npackage com.oop.demo09; import java.sql.Time; public class TestImp implements TimeService,RunService{ @Override public void run() { } @Override public Time timer() { return null; } }   内部类  内部类就是在一个类的内部再定义一个类,详解见内部类解析  成员内部类 静态内部类 局部内部类 匿名内部类    ","date":"2021-05-02T16:22:25+08:00","image":"https://minster77.github.io/Java_OOP_02.jpg","permalink":"https://minster77.github.io/p/javaoop_02/","title":"JavaOOP_02"},{"content":"初识面向对象   初识面向对象 方法回顾和加深 对象的创建分析   初识面向对象   面向过程思想\n 步骤清晰简单，第一步做什么，第二部做什么\u0026hellip;. 面向过程适合处理一些较为简单的问题    面向对象思想\n 物以类聚，分类的思想模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！    对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。\n  面向对象编程的本质就是：以类的方式组织代码，以对象的形式组织(封装)数据\n  面向对象的三大特性\n 封装：封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。 继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 多态：多态是同一个行为具有多个不同表现形式或形态的能力。    回顾方法和加深   静态方法与非静态方法的调用\n 静态方法定义： 在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。  Student类\npackage com.oop.demo01; public class Student { //静态方法  public static void eat(){ System.out.println(\u0026#34;kazikazi\u0026#34;); } //非静态方法  public void say(){ System.out.println(\u0026#34;hello\u0026#34;); } } Demo01类\npackage com.oop.demo01; public class Demo01 { public static void main(String[] args) { //调用静态方法可以直接调用  Student.eat(); System.out.println(\u0026#34;========================\u0026#34;); //调用非静态方法时需要实例化对象 new  //对象类型 对象名字 = new 对象值；  Student student = new Student(); student.say(); } } 运行结果\n可以知道，静态方法在main方法中调用可以直接调用，非静态方法则需要先实例化类(new一个对象)才能调用\n  值传递\npackage com.oop.demo01; public class Demo02 { public static void main(String[] args) { int a = 1; System.out.println(a);//1  change(a);//实参  System.out.println(a);//1  } //返回值为空  public static void change(int a){//形参  a = 10; } } 上述代码中a的值没有改变是因为实参传递给形参的是值 形参和实参在内存上是两个独立的变量 对形参做任何修改不会影响实参\n 通俗来说就是：小明去餐厅看到别人桌子上的糯米鸡好吃，然后小明就叫服务员点了一份糯米鸡，小明吃完了，别人桌上的却不受影响，因为他们吃的不是同一份糯米鸡。\n   引用传递\npackage com.oop.demo01; public class Demo04 { public static void main(String[] args) { Person person = new Person(); person.name = \u0026#34;高佬\u0026#34;; System.out.println(person.name); Demo04.change(person); System.out.println(person.name); } public static void change(Person person){ //person是一个对象，指向了一个对象  person.name=\u0026#34;志恒\u0026#34;; } } class Person{ String name; } 实参传递给形参的是参数对于 堆内存上的引用地址 实参和 形参在内存上指向 了同一块区域 对形参的修改会影响实参\n  对象的创建分析 对象的创建   对象可以通过new关键字来创建，示例如下\n创建一个Student类\npackage com.oop.demo02; //学生类 public class Student { //属性  String name; int age; //方法  public void print(){ System.out.println(this.name+\u0026#34;学生在学习\u0026#34;); } } Test类\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { /* 类：抽象的，需要实例化 * 类实例化之后会返回一个自己的对象 * student对象就是一个Student类的具体实例 * */ Student student1 = new Student(); Student student2 = new Student(); //给对象赋值  student1.name = \u0026#34;小明\u0026#34;; student1.age = 10; System.out.println(student1.name); System.out.println(student1.age); System.out.println(student2.name); System.out.println(student2.age); } } 运行结果：\n  使用new关键字创建的时候，除了分配空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用。\n  构造器   构造器又叫构造方法，在进行创建对象的时候必须要调用的。并且构造器有一下两个特点：\n 必须和类的名字相同 必须没有返回类型，也不能写void  作用\n 使用new关键字，本质就是在调用构造器 初始化对象的值  注意点\n 定义有参构造之后，如果想使用无参构造，就必须显示的定义一个无参的构造   ait+Insert IDEA生成构造器的快捷键\n   构造器代码示例：\nPerson类：\npackage com.oop.demo02; public class Person { //一个类即使什么都不写，它都会存在一个方法（构造器）  //显示的定义构造器  String name; int age; //无参构造  public Person() { } //有参构造：一旦定义了有参构造，无参就必须显示定义  public Person(String name,int age) { this.name = name; this.age = age; } } Test类：\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Person person = new Person(\u0026#34;minster\u0026#34;,21); System.out.println(person.name+\u0026#34; \u0026#34;+person.age); } }   对象的内存分析   首先先创建一个简单的Pet类\npackage com.oop.demo02; public class Pet { String name; int age; public Pet() { } public Pet(String name, int age) { this.name = name; this.age = age; } public void shout(){ System.out.println(this.name+\u0026#34;在叫\u0026#34;); } } Tset\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Pet dog = new Pet(\u0026#34;旺财\u0026#34;,3); Pet cat = new Pet(\u0026#34;cat\u0026#34;, 3); dog.shout(); cat.shout(); } } 内存分析图\n在内存中，创建一个对象，栈空间中存放的是对象的引用，而堆空间中存放的是new出来的东西，栈、堆两个空间通过一个内存地址相互连接。\n  ","date":"2021-05-01T16:22:25+08:00","image":"https://minster77.github.io/Java_OOP_01.jpg","permalink":"https://minster77.github.io/p/javaoop_01/","title":"JavaOOP_01"},{"content":"Java数组   数组概述 数组声明创建 java内存分析 数组使用 多维数组 Arrays类 冒泡排序 稀疏数组   数组概述  数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 每一个数据称作一个数组元素，数组元素可以通过一个下标来访问  数组声明与创建   首先必须声明数组变量，才能在程序中使用数组(声明时数组并不存在)。声明方法：\ndataType[] arrayRefvar;\t//首选方法 dataType addayRefvar[];\t//效果相同，但不是首选方法   java语言使用new操作符来创建方法(创建后数组就存在了)，语法如下：\ndataType[] arrayRefvar = new dataType[arraySize];   数组的元素是通过索引访问的，数组索引从0开始\n  获取数组长度：arrays.length\n  联系：给数组赋值并累加求值\npackage com.heng.array; public class Demo01 { public static void main(String[] args) { int[] arrays = new int[10]; int sum = 0; for (int i = 0; i \u0026lt;arrays.length ; i++) { arrays[i] = i; } for (int i = 0; i \u0026lt;arrays.length ; i++) { sum+=arrays[i]; } System.out.println(sum); } }   初始化\npackage com.heng.array; public class Demo02 { public static void main(String[] args) { //静态初始化:创建+赋值  int[] a = {1,2,3,4}; Demo01[] demo01s = {new Demo01(),new Demo01()}; //动态初始化  int[] b = new int[10]; } }   数组的四个基本特点\n 数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同的数据类型，不允许出现混合类型 数组中的元素可以是任何类型，包括基本类型和引用类型 数组可以看做一个对象，Java对象是在堆中的，数组对象本身是在堆中的。    数组边界\n数组的合法区间：[0,length-1],如果越界就就会报错！\npackage com.heng.array; public class Demo03 { public static void main(String args[]){ int[] a = new int[2]; System.out.println(a[2]);//越界！  } }   Java内存分析   堆\n 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用    栈\n 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址）    方法区\n 可以被所有的线程共享 包含了所有的class和static变量    java内存分析图示\n  数组使用   For-Each循环\npackage com.heng.array; public class Demo04 { public static void main(String[] args) { int[] array = {1,2,3,4,5}; for (int i : array) { System.out.println(i); } } }   数组作为参数\npackage com.heng.array; public class Demo05 { public static void main(String[] args) { int[] arrays = {1,2,3,4,5}; printArrays(arrays); } public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } } }   数组做返回值\npackage com.heng.array; public class Demo05 { public static void main(String[] args) { int[] arrays = {1,2,3,4,5}; int[] reverse = reverse(arrays); printArrays(reverse); } //反转数组  public static int[] reverse(int[] arrays){ int[] result = new int[arrays.length]; for (int i = 0,j=result.length-1; i \u0026lt; arrays.length; i++,j--) { result[j] = arrays[i]; } return result; } //打印数组  public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } } }   多维数组   多维数组可以看成是数组的数组。例如一个二维数组就是一个特殊的一维数组，每一个元素都是一个一维数组\n  多维数组的组成\npackage com.heng.array; public class Demo06 { public static void main(String[] args) { //创建一个二维数组  int[][] arrays = {{1,2},{3,4},{5,6},{7,8}}; /* * 相当于一个四行二列 [4][2] * {1,2} arrays[0] * {3,4} arrays[1] * {5,6} arrays[2] * {7,8} arrays[3] * */ //打印arrays[0]所得的结果为arrays[0]的地址  System.out.println(arrays[0]); System.out.println(\u0026#34;==================\u0026#34;); //但是通过printArrays函数打印就能把arrays[0]的值打印出来  printArrays(arrays[0]); System.out.println(\u0026#34;==================\u0026#34;); //或者用二维数组打印方式打印  System.out.println(arrays[0][0]+\u0026#34; \u0026#34;+arrays[0][1]); } public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } System.out.println(); } }   Arrays类   数组的工具类java.util.Arrays\n  该类包含用于操作数组的各种方法（如排序和搜索）。\npackage com.heng.array; import java.util.Arrays; public class Demo07 { public static void main(String[] args) { int[] a = {2,4,5,6,71,1,15,48,89,12,545}; System.out.println(Arrays.toString(a)); Arrays.sort(a);//排序方法 ：升序  System.out.println(Arrays.toString(a)); } }   冒泡排序   冒泡排序是最常用的八大排序算法之一，通过嵌套循环实现\n  冒泡排序的原理\n 比较数组中两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置 每一次比较都会产生一个最大或者最小的数字 下一轮则可以少一次排序 一次循环，直到结束    示例代码\npackage com.heng.array; import java.util.Arrays; public class Demo08 { public static void main(String[] args) { int[] a = {1,5,10,55,2,444,64,50}; System.out.println(Arrays.toString(a));\tSystem.out.println(\u0026#34;=================\u0026#34;); int[] sort = sort(a); //调用完排序方法后，返回一个排序后的数组  System.out.println(Arrays.toString(a)); } public static int[] sort(int[] array){ //临时变量  int temp = 0; //外层循环，判断我们要走多少次  for (int i = 0; i \u0026lt; array.length-1; i++) { //通过flag标识减少没有意义的比较  boolean flag = false; //内层循环，比较判断两个数，交换位置  for (int j = 0; j \u0026lt; array.length-1-i; j++) { if(array[j+1]\u0026gt;array[j]){ temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; flag = true; } } if(flag==false){ break; } } return array; } }   稀疏数组   稀疏数组就是一种数据结构\n  当一个数组中大部分元素为0，或者为同一值得数组时，可以使用稀疏数组来保存该数组。\n  稀疏数组的处理方式是：\n 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序的规模    原始数组转换成稀疏数组\npackage com.heng.array; public class Demo09 { public static void main(String[] args) { //五子棋游戏：创建一个二维数组 11*11 0：没有旗子 1：黑棋 2：白棋  int[][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; //输出原始的数组  System.out.println(\u0026#34;输出原始的数组\u0026#34;); for (int[] ints:array1) { for (int anInt:ints) { System.out.print(anInt+\u0026#34;\\t\u0026#34;); } System.out.println(); } //转换为稀疏数组  //获取有效值的个数  int sum = 0; for (int i = 0; i \u0026lt; 11; i++) { for (int j = 0; j \u0026lt; 11; j++) { if(array1[i][j]!=0){ sum++; } } } System.out.println(\u0026#34;有效值为：\u0026#34;+sum); //创建一个稀疏数组  int[][] array2 = new int[sum+1][3]; array2[0][0] = 11; array2[0][1] = 11; array2[0][2] = sum; //遍历二维数组，将非0的值存放到稀疏数组中  int count = 0; for (int i = 0; i \u0026lt; array1.length; i++) { for (int j = 0; j \u0026lt; array1[i].length; j++) { if(array1[i][j]!=0){ count++; array2[count][0] = i; array2[count][1] = j; array2[count][2] = array1[i][j]; } } } //输出稀疏数组  System.out.println(\u0026#34;输出稀疏数组\u0026#34;); for (int i = 0; i \u0026lt; array2.length; i++) { System.out.println(array2[i][0]+\u0026#34;\\t\u0026#34; +array2[i][1]+\u0026#34;\\t\u0026#34; +array2[i][2]+\u0026#34;\\t\u0026#34;); } } }   稀疏数组还原\n//输出稀疏数组  System.out.println(\u0026#34;输出稀疏数组\u0026#34;); for (int i = 0; i \u0026lt; array2.length; i++) { System.out.println(array2[i][0]+\u0026#34;\\t\u0026#34; +array2[i][1]+\u0026#34;\\t\u0026#34; +array2[i][2]+\u0026#34;\\t\u0026#34;); } System.out.println(\u0026#34;=======================\u0026#34;); System.out.println(\u0026#34;还原\u0026#34;); //稀疏数组转换成原始数组  //1.读取稀疏数组  int[][] array3 = new int[array2[0][0]][array2[0][1]]; //2.给其中的元素还原值  for (int i = 1; i \u0026lt; array2.length; i++) { array3[array2[i][0]][array2[i][1]] = array2[i][2]; } System.out.println(\u0026#34;输出还原后的数组\u0026#34;); for (int[] ints:array1) { for (int anInt:ints) { System.out.print(anInt+\u0026#34;\\t\u0026#34;); } System.out.println(); }   ","date":"2021-04-20T16:22:25+08:00","image":"https://minster77.github.io/cover04.jpg","permalink":"https://minster77.github.io/p/javaarray/","title":"JavaArray"},{"content":"Java集合类(四)   开发中如何选择集合实现类 TreeSet底层源码剖析 TreeMap底层源码剖析 Collections工具类 集合章节练习题   开发中如何选择集合实现类  在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：   先判断存储的类型（一组对象[单列]或一组键值对[双列]） 一组对象[单列]：Collection接口  允许重复：List  增删多：LinkedLike（底层维护了一个双向链表） 改查多：ArrayList（底层维护了Object类型的可变数组）   不允许重复：Set  无序：HashSet（底层是HashMap，维护了一个哈希表【数组+链表+红黑树】） 排序：TreeSet 插入和取出顺序一致：LinkeHashSet（底层是LinkedHashMap），维护了数组+双向链表     一对键值对：Map  键无序：HashMap（底层是哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树） 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap（底层是HashMap） 读取文件：Properties    TreeSet底层源码剖析   TreeSet的底层就是TreeMap\n key不允许重复。    TreeSet可以实现有序排序，但是当我们使用其无参构造器时，仍然是无序的。要使用TreeSet提供的一个构造器，传入一个比较器（匿名内部类）才能实现排序\n下面使用TreeSet对数据进行排序（按字符串长度比较）\n创建测试类TreeSet_\npackage com.conllection_.sets; import java.util.Comparator; import java.util.TreeSet; public class TreeSet_ { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度进行比较  return ((String)o1).length() - ((String)o2).length(); } }); treeSet.add(\u0026#34;jack\u0026#34;); treeSet.add(\u0026#34;tom\u0026#34;); treeSet.add(\u0026#34;a\u0026#34;); treeSet.add(\u0026#34;ha\u0026#34;); treeSet.add(\u0026#34;xiaohu\u0026#34;); System.out.println(\u0026#34;treeSet = \u0026#34; +treeSet); } } debug调试，我们可以看到TreeSet此时使用的构造器\npublic TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } 可以发现，该构造器把我们的一个比较器（匿名内部类）对象传到了TreeSet的底层TreeMap\npublic TreeMap(Comparator\u0026lt;? super K\u0026gt; comparator) { this.comparator = comparator; } 并且把比较器对象赋给了TreeMap的属性comparator。\n在调用treeSet.add(\u0026ldquo;tom\u0026rdquo;);时，在底层会执行put的方法\npublic boolean add(E e) { return m.put(e, PRESENT)==null; } 继续往下走，可以发现程序执行以下代码\nint cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths //cpr为我们传进去的匿名内部类 Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; //动态绑定到我们的匿名内部类对象，且调用了其compare方法。  cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else//如果两个元素比较后相等，即返回0，这个key就不能加入进去  return t.setValue(value); } while (t != null); } 此时的treeSet集合如下\n运行结果\n需要注意的是，排序规则可以自己定义，按照需求来定义。\n  TreeMap底层源码剖析   TreeMap机制与TreeSet大体一致，但TreeMap是键值对方式存储数据\n  TreeMap底层实现的是Entry数组\n创建TreeMap_测试类\npackage com.conllection_.maps; import java.util.Comparator; import java.util.TreeMap; public class TreeMap_ { public static void main(String[] args) { //使用有参构造，重写比较器  TreeMap treeMap = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { //按照字符串长度进行比较  return ((String)o1).length()-((String)o2).length(); } }); treeMap.put(\u0026#34;jack\u0026#34;,\u0026#34;杰克\u0026#34;); treeMap.put(\u0026#34;tom\u0026#34;,\u0026#34;汤姆\u0026#34;); treeMap.put(\u0026#34;xiaohu\u0026#34;,\u0026#34;小虎\u0026#34;); treeMap.put(\u0026#34;mary\u0026#34;,\u0026#34;玛丽\u0026#34;);//替换杰克  System.out.println(\u0026#34;treeMap = \u0026#34;+ treeMap); } } 调试程序，执行put方法，首次添加时会进行初始化\nEntry\u0026lt;K,V\u0026gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check  root = new Entry\u0026lt;\u0026gt;(key, value, null); size = 1; modCount++; return null; } 因为此时只有一个元素，不能进行比较，所以就直接添加到Entry里面了\n继续添加元素，程序执行以下代码\nint cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } 此时会调动到比较器进行比较，与TreeSet不同的是当key值比较结果相同时，程序会把新增的key的value值替换掉原来的key的value值。\n需要注意的是，key不能为null\n  Collections工具类   Collections是一个操作Set、List和Map等集合的工具类\n  Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n  排序操作（均为static方法）\n reverse(List)：反转List中元素的顺序 shuffle(List)：对List集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定List集合元素按升序排序 sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序 swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换  代码演示\n创建Collections01测试类\npackage com.collections_; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Collections02 { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;smith\u0026#34;); list.add(\u0026#34;h\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 1. reverse(List)：反转List中元素的顺序  Collections.reverse(list); System.out.println(\u0026#34;将list反转后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 2. shuffle(List)：对List集合元素进行随机排序  Collections.shuffle(list); System.out.println(\u0026#34;将list元素进行随机排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 3. sort(List)：根据元素的自然顺序对指定List集合元素按升序排序  Collections.sort(list); System.out.println(\u0026#34;自然排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 4. sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序  Collections.sort(list, new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度排序  //可以加入一些校验代码，提高严谨性  return ((String)o1).length()-((String)o2).length(); } }); System.out.println(\u0026#34;按字符串长度排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 5. swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换  Collections.swap(list,1,3); System.out.println(\u0026#34;将下标为1的元素与下标为3的元素互换\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); } } 运行结果：\n  查找、替换\n Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素 Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素 int frequency(Collection,Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值  代码演示\n创建Collections02测试类\npackage com.collections_; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Collections02 { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;smith\u0026#34;); list.add(\u0026#34;h\u0026#34;); System.out.println(\u0026#34;List = \u0026#34;+list); // 1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素  System.out.println(\u0026#34;返回自然顺序中的最大元素\u0026#34;); System.out.println(\u0026#34;然顺序中的最大元素是\u0026#34;+Collections.max(list)); // 2. Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素  System.out.println(\u0026#34;返回Comparator指定的顺序中的最大元素\u0026#34;); //比如返回字符串长度最长元素  Object maxObject = Collections.max(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String)o1).length() - ((String) o2).length(); } }); System.out.println(\u0026#34;字符串长度最长元素是\u0026#34; + maxObject); // 3. Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 // 4. Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素 // 5. int frequency(Collection,Object)：返回指定集合中指定元素的出现次数  System.out.println(\u0026#34;tom出现的次数为\u0026#34; + Collections.frequency(list, \u0026#34;tom\u0026#34;)); // 6. void copy(List dest,List src)：将src中的内容复制到dest中  ArrayList dest = new ArrayList(); for (int i = 0; i \u0026lt; list.size(); i++) { dest.add(\u0026#34;\u0026#34;); } Collections.copy(dest,list); System.out.println(\u0026#34;dest = \u0026#34;+ dest); // 7. boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值  Collections.replaceAll(list,\u0026#34;tom\u0026#34;,\u0026#34;汤姆\u0026#34;); System.out.println(\u0026#34;替换后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34; + list); } } 运行结果：\n需要注意的是，使用copy时，dest数组的大小必须大于src数组，否则会报数组越界异常\nint srcSize = src.size(); if (srcSize \u0026gt; dest.size()){ throw new IndexOutOfBoundsException(\u0026#34;Source does not fit in dest\u0026#34;); }   本章练习题   试分析HashSet和TreeSet分别如何实现去重的\n  HashSet去重机制：HashSet是通过hashCode()+equals()方法实现去重的。底层先通过hashCode方法计算出key对应的hash值，然后通过hash值查找在table表上对应索引位置上是否已经存在值。如果该位置上不存在值，则直接把key添加进去。否则通过equals方法遍历比较新增的key与已存在的key是否相同，相同就把key加入到已存在的key的后面，否则不添加。equals方法可以自定义比较的内容。\n  TreeSet去重机制：如果你在定义TreeSet时传入了一个Comparator匿名内部类（比较器），就使用该比较器中定义的compare方法实现去重。如果返回是0，则说明添加元素相同，不添加。如果你没有传入一个Comparator匿名内部类，系统会通过你添加的对象实现的Comprareable接口的compareTo实现去重。\nelse { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //把k指向key对象的类型实现的Comparable接口  Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; //动态绑定compareTo方法  cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); }     分析下面代码运行会不会抛出异常，并从源码层面说明原因\nTreeSet treeSet = new TreeSet(); treeSet.add(new Person()); class Person{ } 会抛出ClassCastException异常\n因为在定义TreeSet时没有传进去一个Comparator匿名类，所以在执行add的时候，程序会进入下述代码中\nelse { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //把k指向key对象的类型实现的Comparable接口  Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; //动态绑定compareTo方法  cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } 又因为Person类并没有实现Comparable接口，所以运行到第6行代码处时会抛出ClassCastException异常。\n  已知：Person类按照id和name重写了hashCode与equals方法。下面代码会输出什么？\nExercises04测试类\npackage com.collections_; import java.util.HashSet; import java.util.Objects; public class Exercises04 { public static void main(String[] args) { Person p1 = new Person(1001,\u0026#34;AA\u0026#34;); Person p2 = new Person(1002,\u0026#34;BB\u0026#34;); HashSet set = new HashSet(); set.add(p1); set.add(p2); System.out.println(set); p1.name = \u0026#34;CC\u0026#34;; set.remove(p1); System.out.println(set); set.add(new Person(1001,\u0026#34;CC\u0026#34;)); System.out.println(set); set.add(new Person(1001,\u0026#34;AA\u0026#34;)); System.out.println(set); } } Person类\nclass Person{ public int id; public String name; public Person(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(id, name); } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 输出结果为\n为什么set.remove(p1);执行了却没有remove成功呢？\n因为在执行remove方法之前，我们把p1的name值改变了**p1.name = \u0026ldquo;CC\u0026rdquo;;**而且我们在Person类中重写了hashCode方法，所以我们把name值改变的同时导致p1对应的hash值也发生改变。而我们观看remove的源码可以知道\nfinal Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) 此处传进去的hash值为p1更改后hash值而辅助变量p却指向了table表中的p1，即hash值为table的hash值\nif ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) 因为两个hash值不同，所以在接下来的几个if判断中结果都为false\nfinal Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, index; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) { Node\u0026lt;K,V\u0026gt; node = null, e; K k; V v; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))//False  node = p; else if ((e = p.next) != null) {//False  if (p instanceof TreeNode) node = ((TreeNode\u0026lt;K,V\u0026gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } //False  if (node != null \u0026amp;\u0026amp; (!matchValue || (v = node.value) == value || (value != null \u0026amp;\u0026amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 所以最后只能return null；然后回到remove方法\npublic V remove(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } 因为removeNode方法return null，所以返回到remove也只能return null 即修改失败。\n而后面添加\nset.add(new Person(1001,\u0026#34;CC\u0026#34;)); set.add(new Person(1001,\u0026#34;AA\u0026#34;)); 可以成功，原理跟上述图示一样\n因为后面添加的Person(1001,\u0026ldquo;AA\u0026rdquo;)同上面一样是指向索引为3处（该处为null），所以添加成功\n而Person(1001,\u0026ldquo;AA\u0026rdquo;)添加成功是因为此时索引为1出的Person值的name已发生改变。且计算出来的Hash值与索引为1处对应。所以该Person添加到索引为1处的Person后面\n  ","date":"2021-04-16T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%9B/","title":"Java集合类（四）"},{"content":"JavaMethod   什么是方法 方法的定义及调用 方法重载 命令行传参 可变参数 递归   何谓方法   方法是语句的结合，他们在一起执行一个功能。\n 方法是解决一类问题的步骤的有序组合 方法包含于类中 方法在程序中被创建，在其地方被引用    设计方法时，最好保持方法的原子性，就是一个方法只完成一个功能，这样子利于我们后期的拓展。\n  命名规则：首字母小写的驼峰命名法\n  方法创建及使用\npackage com.heng.method; public class Demo01 { //main方法  public static void main(String[] args) { int sum = add(1,3); System.out.println(sum); } //add方法  public static int add(int a , int b){ return a+b; }   方法的定义及调用  方法的定义    方法包含一个方法头和一个方法体。以下是一个方法的所有部分\n  修饰符：定义了该方法的访问类型\n  返回值类型：方法会根据所需返回对应的值得类型，当无需返回值时，方法的类型是void\n  方法名：是方法的实际名称，方法名和参数表共同构成方法签名\n  参数类型：参数像是一个占位符。有实参与形参，也可以不包含参数\n 形参：在方法被调用时用于接收外界输入的数据 实参：调用方法是实际传给方法的数据  public class Demo01 { public static void main(String[] args) { //实际参数：实际调用传递给他的参数  int sum = add(1,3); System.out.println(sum); } //形式参数，用来定义作用的  public static int add(int a , int b){ return a+b; }   方法体：方法体包含具体的语句。定义了方法的功能\npublic static int add(int a,int b){ /* 修饰符:public static * 返回值类型:int * 方法名:add * 参数类型:int 参数名:a */ return a+b;//方法体  }     return除了放回值之外也可以终止方法。\n  方法的调用   调用方法：对象名.方法名（实参列表）  方法的重载   重载是在一个类中，有相同的函数名称，但形参不同的函数。\n  方法重载的规则\n 方法名必须相同。 参数类别必须不同（个数不同、类型不同、参数排列顺序不同等） 方法的返回类型可以相同也可以不同 仅仅返回类型不同不足以成为方法的重载    下面代码两个方法名都为max 但方法类型不同，所以两个方法重载\npackage com.heng.method; public class Demo02 { public static void main(String[] args) { //调用double类型的返回方法  double max = max(20,30); //根据需要的类型调用方法  System.out.println(max); } public static int max(int num1,int num2){ int result = 0; if(num1==num2){ System.out.println(\u0026#34;num1=num2\u0026#34;); return 0;//终止方法  } if(num1\u0026gt;num2){ result = num1; }else { result = num2; } return result; } public static double max(double num1,double num2){ double result = 0; if(num1==num2){ System.out.println(\u0026#34;num1=num2\u0026#34;); return 0;//终止方法  } if(num1\u0026gt;num2){ result = num1; }else { result = num2; } return result; } }   命令行传参   有时候你希望运行一个程序再传递给它消息，这要靠传递命令行参数给main()函数实现\npackage com.heng.method; public class Demo03 { public static void main(String[] args) { for (int i = 0; i \u0026lt; args.length; i++) { System.out.println(\u0026#34;args[\u0026#34;+i+\u0026#34;]:\u0026#34;+args[i]); } } } 上述代码需要先进入到命令行模式编译成.class文件\n编译完成后，生成了一个class文件\n最后在命令行模式下执行Demo03.class；同时向main()函数传参\n需要注意的是执行class文件需要返回到src目录下才能执行\n  可变参数   可变参数又可以叫做不定项参数（本质就是数组）\n  在方法声明中，在指定参数类型后加一个省略号(\u0026hellip;)即表示可变参数\n  一个方法中只能指定一个可变参数，他必须是方法的最后一个参数。任何普通的参数必须在它之前声明\n  代码演示：\npackage com.heng.method; public class Demo04 { public static void main(String[] args) { //新建一个对象  Demo04 demo04 = new Demo04(); //调用对象方法  demo04.printMax(34,3,2,4,1,5.5); demo04.printMax(new double[]{1,2,3}); } public void printMax(double... number){ if(number.length==0){ System.out.println(\u0026#34;没有参数\u0026#34;); return; } double result = number[0]; //排序  for (int i = 1; i \u0026lt; number.length; i++) { if(number[i]\u0026gt;result){ result = number[i]; } } System.out.println(\u0026#34;max=\u0026#34;+result); } }   递归   递归结构包括两部分：\n 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环 递归体：什么时候调用自身方法。    需要注意的是递归是把函数堆压在栈里面的，如果递归的次数太多，栈内存会不过，即系统会报错\n  递归代码演示：\npackage com.heng.method; public class Demo05 { public static void main(String[] args) { Demo05 demo05 = new Demo05(); int result = demo05.f(5); System.out.println(result); } public int f(int i){ if(i==1){ return 1; }else { return i*f(i-1); } } } 上述代码的执行过程\n  ","date":"2021-04-08T16:22:25+08:00","image":"https://minster77.github.io/cover03.jpg","permalink":"https://minster77.github.io/p/javamethod/","title":"JavaMethod"},{"content":"Java集合类(三)   Map接口实现类的特点和常用方法 Map接口的六大遍历方式 Map小结及HashMap底层源码分析 Hashtable基本介绍   Map接口实现类的特点和常用方法 Map接口的特点 注意：这里讲的是Jdk8的Map接口特点\n  Map与Collection并列存在。用于保存具有映射关系的数据：key-value\n  Map中的key和value可以是任何引用类型的数据，会封装到HashMao$Node对象中\n  Map中的key不允许重复，原因和HashSet一样\n  Map中的value可以重复\n  Map的key可以为null，value也可以为null，但是key为null的结点只能有一个，value为null的结点可以有多个\n  常用String类作为Map的key\n  key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n代码演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class Map_ { public static void main(String[] args) { Map map = new HashMap(); //key不可以重复，重复的会被等价替换  //value可以重复  map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  map.put(\u0026#34;no1\u0026#34;,\u0026#34;张三丰\u0026#34;);//当有相同的key，就等于等价替换  map.put(\u0026#34;no3\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  //key只能有一个null  map.put(null,null); map.put(null,\u0026#34;abc\u0026#34;);//等价替换  //value可以多个为null  map.put(\u0026#34;no4\u0026#34;,null); map.put(\u0026#34;no5\u0026#34;,null);//value可以多个为null  map.put(1,\u0026#34;赵敏\u0026#34;); //通过get方法，传入key，会返回对应的value  System.out.println(map.get(\u0026#34;no3\u0026#34;)); System.out.println(\u0026#34;map = \u0026#34; + map); } }   Map接口k-v详解\n  Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的。因为Node实现了Entry接口，所以有些书上也说一对k-v就是一个Entry。\n  k-v 数据最后是存放在HashMap$Node node = newNode(hash,key,value,null) 这个对象里面的。\n  k-v 为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry。而一个Entry对象本身就具有key，value值。所以有EntrySet\u0026lt;Entry\u0026lt;K,V\u0026raquo;，即\ntransient Set\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; entrySet;   EntrySet中，定义的类型是Map.Entry，但是实际上存放的还是HashMap$Node。原因如下\nstatic class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt;   由于Map.Entry提供了两个重要的方法：K getKey(); V getValue() ，所以当我们把HashMap$Node对象存放到EntrySet就可以方便我们的遍历。\n程序演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; import java.util.Set; public class MapSource { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  Set set = map.entrySet(); for (Object obj:set) { //向下转型  Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey() + \u0026#34;-\u0026#34; + entry.getValue()); } System.out.println(\u0026#34;Map = \u0026#34; + map); } } 输出结果：\nkeySet()：与Node封装到EntrySet集合一样，不过他是封装到Set集合，利用该方法可以单独遍历Key值\nvalues：与Node封装到EntrySet集合一样，不过他是封装到Collection集合，利用该方法可以单独遍历Value值\nSet set1 = map.keySet(); System.out.println(set1); Collection values = map.values(); System.out.println(values); 运行结果\n  Map接口的常用方法   put()：添加元素\n  remove()：根据键删除映射关系\n  get()：根据键获取值\n  size()：获取元素的个数\n  isEmpty()：判断元素个数是否为0\n  clear()：清除集合键值对\n  containsKey()：查找键是否存在\n代码演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class MapMethod { public static void main(String[] args) { Map map = new HashMap(); // 1. put()：添加元素  map.put(\u0026#34;no1\u0026#34;,new Book(\u0026#34;小王子\u0026#34;,100)); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;); map.put(\u0026#34;no2\u0026#34;,\u0026#34;史森明\u0026#34;); map.put(\u0026#34;no3\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(\u0026#34;no4\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(null,\u0026#34;小虎\u0026#34;); map.put(\u0026#34;no5\u0026#34;,null); System.out.println(\u0026#34;map = \u0026#34; + map); // 2. remove()：根据键删除映射关系  map.remove(\u0026#34;no3\u0026#34;); System.out.println(\u0026#34;map = \u0026#34; + map); // 3. get()：根据键获取值  System.out.println(map.get(\u0026#34;no1\u0026#34;)); // 4. size()：获取元素的个数  System.out.println(map.size()); // 5. isEmpty()：判断元素个数是否为0  System.out.println(map.isEmpty()); // 6. clear()：清除集合键值对  map.clear(); System.out.println(map.isEmpty()); System.out.println(map.size()); // 7. containsKey()：查找键是否存在  map.put(\u0026#34;no1\u0026#34;,new Book(\u0026#34;小王子\u0026#34;,100)); System.out.println(map.containsKey(\u0026#34;no1\u0026#34;)); System.out.println(map.containsKey(\u0026#34;no5\u0026#34;)); } } class Book{ private String name; private double price; public Book(String name, double price) { this.name = name; this.price = price; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } }   Map接口的六大遍历方式   遍历以下Map接口的元素\nimport java.util.Set; public class MapFor { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;); map.put(\u0026#34;no2\u0026#34;,\u0026#34;史森明\u0026#34;); map.put(\u0026#34;no3\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(\u0026#34;no4\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(null,\u0026#34;小虎\u0026#34;); map.put(\u0026#34;no5\u0026#34;,null); } }     使用keySet()+增强for遍历k-v\nSystem.out.println(\u0026#34;=====第一种遍历方式=====\u0026#34;); Set keySet = map.keySet(); for (Object key : keySet) { System.out.println(key+\u0026#34;=\u0026#34;+map.get(key)); } 运行结果\n  使用keySet()+迭代器遍历k-v\nSystem.out.println(\u0026#34;=====第二种遍历方式=====\u0026#34;); Iterator iterator = keySet.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next+\u0026#34;=\u0026#34;+map.get(next)); } 运行结果\n  使用values()+增强for遍历value（因为value不能映射key，所以只能遍历value）\nSystem.out.println(\u0026#34;=====第三种遍历方式=====\u0026#34;); Collection values = map.values(); for (Object value : values) { System.out.println(value); } 运行结果\n  使用values()+迭代器遍历\nSystem.out.println(\u0026#34;=====第四种遍历方式=====\u0026#34;); Iterator iterator1 = values.iterator(); while (iterator1.hasNext()) { Object next = iterator1.next(); System.out.println(next); } 运行结果\n  使用EntrySet()+增强for遍历\nSystem.out.println(\u0026#34;=====第五种遍历方式=====\u0026#34;); Set entrySet = map.entrySet(); for (Object obj : entrySet) { //将obj转成Map.Entry  Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey()+\u0026#34;-\u0026#34;+entry.getValue()); } 运行结果\n  使用EntrySet()+迭代器遍历\nSystem.out.println(\u0026#34;=====第六种遍历方式=====\u0026#34;); Iterator iterator2 = entrySet.iterator(); while (iterator2.hasNext()) { Object next = iterator2.next(); Map.Entry entry = (Map.Entry)next; System.out.println(entry.getKey()+\u0026#34;-\u0026#34;+entry.getValue()); } 运行结果\n  HashMap练习题   使用HashMap添加三个元素对象，要求：\n 键：员工ID，值：员工对象 遍历显示工资\u0026gt;18000的员工（遍历方法两种） 员工类：姓名、工资、员工id  员工类Staff代码如下\nclass Staff{ private String name; private double wages; private int id; public Staff(String name, double wages, int id) { this.name = name; this.wages = wages; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getWages() { return wages; } public void setWages(double wages) { this.wages = wages; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \u0026#34;Staff{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, wages=\u0026#34; + wages + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } } 测试类MapExercise代码如下\npackage com.conllection_.maps; import java.util.*; public class MapExercise { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;01\u0026#34;,new Staff(\u0026#34;成志恒\u0026#34;,19000,01)); map.put(\u0026#34;02\u0026#34;,new Staff(\u0026#34;史森明\u0026#34;,20000,02)); map.put(\u0026#34;03\u0026#34;,new Staff(\u0026#34;小虎\u0026#34;,17000,03)); map.put(\u0026#34;04\u0026#34;,new Staff(\u0026#34;李元浩\u0026#34;,18000,04)); System.out.println(\u0026#34;===第一种方式===\u0026#34;); //使用entrySet方法返回映射中包含的映射的 Set 视图  Set entrySet = map.entrySet(); //利用增强for循环遍历  for (Object o : entrySet) { //向下转型，为了能调用父类的方法  Map.Entry entry = (Map.Entry)o; //把value对象指向从entry集中取出来的value  Object value = entry.getValue(); //向下转型，这样可以使用Staff对象的getWages方法。  Staff staff = (Staff) value; if(staff.getWages()\u0026gt;18000){ System.out.println(staff.toString()); } } System.out.println(\u0026#34;===第二种方式===\u0026#34;); //使用keySet()方法返回封装到Map封装到Set里面的结点的Key值  Set set = map.keySet(); //创建迭代器  Iterator iterator = set.iterator(); while (iterator.hasNext()) { //获取迭代器中的数据  Object next = iterator.next(); //向下转型，吧staff对象指向从map里面取到的value对象。  Staff staff1 = (Staff) map.get(next); if (staff1.getWages()\u0026gt;18000){ System.out.println(staff1); } } } } 运行结果：\n上述题目中，数据的封装情况如下图\n所以当我们需要取出value值时，我们需要先通过EntrySet取出Entry，然后通过Entry的指向取到HashSet$Node的值。\n  Map小结及HashMap底层源码分析 Map小结   Map接口的常用实现类：HashMap、Hashtable和Properties\n  HashMap是Map接口使用频率最高的实现类\n  HashMap是以key-value对的方式来存储数据的\n  key不能重复，但是value可以重复，允许使用null键（只能有一个）和null值（可以多个）\n  如果添加相同的可以，则会覆盖原来的key-value，等同于修改。（key不会替换，value会替换）\nif (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //此处e指向替换前的Node，所以 e.value = value;即可完成替换  e.value = value; afterNodeAccess(e); return oldValue; }   与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。\n  HashMap没有实现同步，因此线程是不安全的。方法没有做同步互斥的操作，没有synchronize\n  HashMap底层机制及源码剖析   HashMap底层机制示意图\n（key，value）是一个Node实现了Map$Entry\u0026lt;K,V\u0026gt;\n  HashMap的扩容机制[和HashSet扩容机制相同]\n HashMap底层维护了Node类型的数组table，默认为null 当创建对象时，将加载因子(loadfactor)初始化为0.75 当添加key-value是，通过key的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换value；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。 第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12 如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），否则任然采用数组扩容机制  源码分析\n创建MapSource类\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class MapSource { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  map.put(\u0026#34;no1\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  } } 调试程序，执行HashMap的无参构造器，=。\npublic HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 将负载因子(loadFactor)初始化并且创建一个空的table。\n向HashMap集合添加元素，执行put方法\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 通过hash方法计算key的Hash值，然后返回给putVal方法。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 执行putVal方法，程序首先判断table是否为null，如果为null就table的容量扩容到16\nif ((tab = table) == null || (n = tab.length) == 0){ n = (tab = resize()).length; } 实现扩容的方法为risize()方法。\n继续调试，程序会判断当前hash值对应的table索引位置上是否已经存在值，如果不存在值，就把当前Hash值的结点赋值进去。\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 然后modCount++（记录修改的次数），size++（记录已添加元素的个数）；\n倘若当前hash值对应的table索引位置上已存在值，首先会判断当前索引位置上的hash值是否与需要添加的key值对应的hash值相同且满足以下两个条件之一：\n 准备添加的key值与p指向的Node结点的key是同一个对象 p指向的Node结点的key的equals()和准备假如的key比较后相同。  如果上述条件皆成立，直接让e指向p（p为当前索引位置上的结点）,e为辅助变量\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ e = p; } 然后继续执行，把需要添加的key值对应的value值替换掉原先存在的key值的value值\nif (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 返回修改后的value值。\n倘若上述条件不成立，程序会继续进行判断，判断需要添加的结点是否为树结点\nelse if (p instanceof TreeNode){ e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); } 如果是树结点，会执行putTreeVal()方法，把需要添加的树节点添加到红黑树上。\n如果不是树节点，程序会继续调试，进入到下一个else。\nelse { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } 在此处程序会进入一个死循环，直至找到对应索引位置上的尾结点或者找到key相同的结点才会退出。详细见HashSet底层添加元素源码分析的最后一步。\n  模拟HashMap触发扩容、树化情况，并debug验证   创建测试类MapSource01\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; import java.util.Objects; public class MapSource01 { public static void main(String[] args) { Map map = new HashMap(); for (int i=0; i\u0026lt;12;i++){ map.put(new A(i),\u0026#34;hello\u0026#34;); } System.out.println(map); } } 创建A类，重写HashCode方法，让他们有统一的Hash值\nclass A{ private int no; public A(int no) { this.no = no; } public int getNo() { return no; } @Override public int hashCode() { return 100; } public void setNo(int no) { this.no = no; } @Override public String toString() { return \u0026#34;\\nA{\u0026#34; + \u0026#34;no=\u0026#34; + no + \u0026#39;}\u0026#39;; } } 运行调试，直至添加到第9个元素，因为达到树化的条件（一条链表的元素个数到达8个），但table的大小\u0026lt;MIN_TREEIFY_CAPACITY(默认是64)，所以table会扩容。\n继续调试，table再次扩容，直至table扩容到容量为64时，该链表会发生树化\n  Hashtable Hashtable的基本介绍   Hashtable存放的元素时键值对：即K-V\n  Hashtable的键和值都不能为null，否则会抛出NullPointerException\nif (value == null) { throw new NullPointerException(); }   Hashtable使用方法基本上和HashMap一样\n  Hashtable是线程安全的（synchronize），HashMap是线程不安全的\n  Hashtable底层的简单剖析\n  底层有数组 Hashtable$Entry[]，初始化大小为11\n  临界值 threshold = 8 （11*0.75）\n创建HashtableSource类调试\npackage com.conllection_.maps;\rimport java.util.Hashtable;\rpublic class HashtableSource {\rpublic static void main(String[] args) {\rHashtable hashtable = new Hashtable();\rhashtable.put(\u0026quot;john\u0026quot;,100);\rhashtable.put(\u0026quot;jack\u0026quot;,100);\rhashtable.put(\u0026quot;mary\u0026quot;,200);\rhashtable.put(\u0026quot;tom\u0026quot;,300);\rhashtable.put(\u0026quot;smith\u0026quot;,500);\rhashtable.put(\u0026quot;minster\u0026quot;,600);\rhashtable.put(\u0026quot;chris\u0026quot;,200);\rhashtable.put(\u0026quot;ssm\u0026quot;,500);\rSystem.out.println(\u0026quot;hashtable = \u0026quot; + hashtable);\r}\r}\r调试程序，我们可以发现\n  Hashtable按照自己的扩容机制进行扩容\n继续调试HashtableSource，执行put方法，可以发现该接口添加元素时执行了addEntry方法把添加的K-V封装到Entry\nprivate void addEntry(int hash, K key, V value, int index) { modCount++; Entry\u0026lt;?,?\u0026gt; tab[] = table; //当增加的元素数量大于或等于临界值时，执行rehash方法进行扩容  if (count \u0026gt;= threshold) { // Rehash the table if the threshold is exceeded  rehash(); tab = table; hash = key.hashCode(); index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry.  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; e = (Entry\u0026lt;K,V\u0026gt;) tab[index]; tab[index] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); count++; } 执行rehash方法进行扩容。下面截取部分rehash源码。\nprotected void rehash() { int oldCapacity = table.length; Entry\u0026lt;?,?\u0026gt;[] oldMap = table; // overflow-conscious code  //进行扩容  int newCapacity = (oldCapacity \u0026lt;\u0026lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets  return; newCapacity = MAX_ARRAY_SIZE; } //指向扩容后的Entry  Entry\u0026lt;?,?\u0026gt;[] newMap = new Entry\u0026lt;?,?\u0026gt;[newCapacity]; } 我们可以发现，当容量达到临界值时，rehash方法会通过 **int newCapacity = (oldCapacity \u0026laquo; 1) + 1;**这条语句进行扩容。所以hashtable第一次扩容后的容量为23（11*2+1）；\n  HashMap与Hashtable对比 Properties   Properties类继承于Hashtable类并实现了Map接口，也是使用一种键值对的形式来保存数据\n  他的使用特点和Hashtable类似\n  Properties还可以用了从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改\n  xxx.properties文件通常作为配置文件，详解见Java读取properties配置文件\nProperties的简单使用\nProperties_类\npackage com.conllection_.maps; import java.util.Properties; public class Properties_ { public static void main(String[] args) { //Properties 继承了Hashtable  //Properties 也是通过k-v存储数据，当然key与value都不能为null  Properties properties = new Properties(); //添加元素  properties.put(\u0026#34;jack\u0026#34;,1); properties.put(\u0026#34;john\u0026#34;,2); properties.put(\u0026#34;tom\u0026#34;,\u0026#34;2\u0026#34;); System.out.println(\u0026#34;properties = \u0026#34;+properties); //删除元素  properties.remove(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;properties = \u0026#34;+properties); //修改元素  properties.put(\u0026#34;jack\u0026#34;,3);//替换  System.out.println(\u0026#34;properties = \u0026#34;+properties); //查找元素  System.out.println(properties.get(\u0026#34;jack\u0026#34;)); System.out.println(properties.getProperty(\u0026#34;tom\u0026#34;)); } } 运行结果\n需要注意的是，使用getPeoperties时，当put进去的值不是String类型的时候，会返回null\n例如在Properties类中添加以下代码\nproperties.put(\u0026#34;jack\u0026#34;,1); System.out.println(properties.getProperty(\u0026#34;jack\u0026#34;)); 阅读getProperty源码，我们可以发现其中原理\npublic String getProperty(String key) { //把oval指向key对应的value  Object oval = super.get(key); //使用三目运算符，当oval是String类型时，返回强转为String类型的oval，否则为null  String sval = (oval instanceof String) ? (String)oval : null; //当sval为null，且设定了defaults的值时，返回defaultsValue，否则返回sval  return ((sval == null) \u0026amp;\u0026amp; (defaults != null)) ? defaults.getProperty(key) : sval; }   ","date":"2021-04-08T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%89/","title":"Java集合类（三）"},{"content":"Java流程控制   用户交互Scanner 顺序结构 选择结构 循环结构 break\u0026amp;continue 练习   用户交互Scanner   通过Scanner类来获取用户的输入\n  基础语法：\nScanner s = new Scanner(System.in);   通过Scanner类的next()方法获取输入的字符串，需要使用hasNext()判断是否还有输入的数据\npackage com.heng.scanner; import java.util.Scanner; public class demo01 { public static void main(String[] args) { //创建一个扫描器对象，用于接收用户输入的数据  Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;用next方式接收：\u0026#34;); //判断用户有没有输入字符串  if(scanner.hasNext()){ //使用next的方式来接收  String str = scanner.next(); System.out.println(\u0026#34;输出的内容为：\u0026#34;+str); } //凡是属于IO流的类如果不关闭就会一直浪费资源。所以要用完就关闭  scanner.close(); } } 因为使用next方法接收，所以空格后面的字符不能被str接收，因此可以使用nextLine()方法操作\n  通过nextLine()方法获取输入的字符串，需要使用hasNextLine()判断是否还有输入的数据\npackage com.heng.scanner; import java.util.Scanner; public class demo02 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;用nextLine方式接收：\u0026#34;); //判断是否还有输入  if(scanner.hasNextLine()){ //通过nextLine()方法来接收  String str = scanner.nextLine(); System.out.println(\u0026#34;输出的内容为：\u0026#34;+str); } scanner.close(); } }   next()方法与nextLine()方法都能用来接收输入的内容，大多数情况使用后者\n  scanner的进阶用法\n  scanner类中有许多个方法来接收不同的数据\n例：利用scanner类中方法来接收数字并求出其和以及平均值\npackage com.heng.scanner; import java.util.Scanner; public class demo03 { public static void main(String[] args) { //输入多个数字，求出其总和以及平均数，每输入一个数字用回车确认，通过输入非数字来结算循环  Scanner scanner = new Scanner(System.in); //用于计算总和  double sum = 0; //用于统计输入的数据个数.  int m = 0; System.out.println(\u0026#34;请输入数据:\u0026#34;); //用while循环来判断是否还有输入，并且在里面累加求和  while (scanner.hasNextDouble()){ double x = scanner.nextDouble(); m=m+1; sum = sum + x; System.out.println(\u0026#34;你输入了第\u0026#34;+m+\u0026#34;个数，当前总和sum=\u0026#34;+sum); } System.out.println(m+\u0026#34;个数的和为:\u0026#34;+sum); System.out.println(m+\u0026#34;个数的平均值为:\u0026#34;+(sum/m)); scanner.close(); } }     顺序结构  Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行 顺序结构是最基本的算法结构 顺序结构是任何一个算法都离不开的一个结构  选择结构 3.1 if单选择结构     语法结构\npackage com.heng.struct; import java.util.Scanner; public class Demo01 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入内容：\u0026#34;); String s = scanner.nextLine(); //equals:判断字符串是否相等  if(s.equals(\u0026#34;Hello\u0026#34;)){ System.out.println(s); } System.out.println(\u0026#34;END\u0026#34;); } }   3.2 if双选择结构   !if(布尔表达式){ //如果布尔表达式为true }else{ //如果布尔表达式为false }   3.3 if多选择结构   语法结构\nif(布尔表达式1){ //如果布尔表达式1的值为true 执行 }else if(布尔表达式2){ //如果布尔表达式2的值为true 执行 }else if(布尔表达式3){ //如果布尔表达式3的值为true 执行 }else { //如果以上布尔表达式都不为true 执行 }   else语句必须在所有的else if语句后面\n  if嵌套结构\nif(布尔表达式1){ if(布尔表达式2){ //执行  } }   3.4 switch选择结构   语法结构\nswitch(expression){ case value: //语句  break; case value: //语句  break; //可以有任意数量个case语句  default ://可选 一般在最后  //语句  }   switch语句中变量可以使 byte、short、int、char在jdk7之后还支持String类型\n  但字符的本质还是数字\npackage com.heng.struct; public class SwitchDemo01 { public static void main(String[] args) { String name = \u0026#34;志恒\u0026#34;; switch (name){ case \u0026#34;小胖\u0026#34; : System.out.println(\u0026#34;小胖\u0026#34;); break; case \u0026#34;志恒\u0026#34; : System.out.println(\u0026#34;志恒\u0026#34;); break; case \u0026#34;松涛\u0026#34; : System.out.println(\u0026#34;松涛\u0026#34;); break; default: System.out.println(\u0026#34;查无此人\u0026#34;); } } }   反编译 Java\u0026mdash;\u0026mdash;\u0026gt;class文件\u0026mdash;\u0026mdash;\u0026gt;反编译（IDEA实现）\n  需要注意的是case具有穿透性 如果不加break或继续执行后面的case\npackage com.heng.struct; public class SwitchDemo02 { public static void main(String[] args) { char grade = \u0026#39;B\u0026#39;; switch (grade){ case \u0026#39;A\u0026#39;: System.out.println(\u0026#34;优秀\u0026#34;); break; case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;良好\u0026#34;); case \u0026#39;C\u0026#39;: System.out.println(\u0026#34;及格\u0026#34;); case \u0026#39;D\u0026#39;: System.out.println(\u0026#34;不及格\u0026#34;); break; default: System.out.println(\u0026#34;未知等级\u0026#34;); } } }   循环结构 4.1 while循环   只要布尔表达式结果为true就会一直执行\n  用一个表达式失效的方式来结束循环\nwhile(布尔表达式){ //语句 }   4.2 do\u0026hellip;while循环   布尔表达式的值为false do\u0026hellip;while循环也会执行一次\n  do\u0026hellip;while循环至少会执行一次\ndo{ //语句 }while(布尔表达式);     while与do\u0026hellip;while的区别\n while先判断后执行；do\u0026hellip;while先执行后判断 do\u0026hellip;while总是保证循环体至少执行一次。  package com.heng.struct; public class WhileDemo01 { public static void main(String[] args) { int a= 0; while(a\u0026lt;0){ System.out.println(a); a++; } System.out.println(\u0026#34;====================\u0026#34;); do { System.out.println(a); a++; }while (a\u0026lt;0); } }   4.3 For循环   语法结构\nfor(初始化;布尔表达式;更新){ //代码语句 }   for循环数支持迭代的一种通用结构，是最有效的、最灵活的循环结构\n  用for循环打印九九乘法表\npackage com.heng.struct; public class ForDemo04 { public static void main(String[] args) { int sum = 0; for (int i = 1; i \u0026lt;= 9; i++) { for (int j = 1; j \u0026lt;= i; j++) { sum = i*j; System.out.print(j+\u0026#34;*\u0026#34;+i+\u0026#34;=\u0026#34;+sum+\u0026#34;\\t\u0026#34;); } System.out.println(); } } }   增强For循环\npackage com.heng.struct; public class ForDemo05 { public static void main(String[] args) { int [] number= {10,20,30,40,50}; //首先看基本的for循环遍历数组  for(int i=0;i\u0026lt;number.length;i++){ System.out.println(number[i]); } System.out.println(\u0026#34;===================\u0026#34;); //下面是增强型for循环遍历  for(int x:number){ System.out.println(x); } } }   break与continue 5.1 break   在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环不执行循环体的剩余语句\n  switch中的break可以避免case的穿透性\n  5.2 continue   continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定\n  java中可以使用标签（goto）\npackage com.heng.struct; public class LabelDemo { public static void main(String[] args) { //求101-150之间的质数  int count = 0; //outer为标签  outer:for (int i = 0; i \u0026lt; 101; i++) { for(int j = 2;j\u0026lt;(i/2);j++){ if(i %j==0){ continue outer;//continue直接跳出到最外面的循环  } } System.out.print(i+\u0026#34; \u0026#34;); } } }   练习   打印一个五行的三角形\npackage com.heng.struct; public class TestDemo01 { public static void main(String[] args) { //打印三角形  /* * 所打印的三角形就是用空格+“*”组成 * 所以一开始进入循环1 打印倒三角的空格 * 然后进入循环二，打印三角形的一半 * 最后进入循环三，将三角形补全 * */ for (int i = 1; i \u0026lt;= 5; i++) { for(int j=5;j\u0026gt;=i;j--){ System.out.print(\u0026#34; \u0026#34;);//循环1 打印倒三角的空格  } for (int j = 1; j \u0026lt;=i ; j++) { System.out.print(\u0026#34;*\u0026#34;);//循环2 打印了三角形的左半部分  } for (int j = 1; j \u0026lt;i ; j++) { System.out.print(\u0026#34;*\u0026#34;);//循环3 将三角形补全  } System.out.println(); } } }   ","date":"2021-04-06T16:22:25+08:00","image":"https://minster77.github.io/cover02.jpg","permalink":"https://minster77.github.io/p/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"Java流程控制"},{"content":"Java集合类(二)   Set接口和常用方法 HashSet全面说明  思考 HashSet底层解析 HashSet底层添加元素源码分析 HashSet扩容机制和转换红黑树机制源码解析 threshold补充说明   LinkedHashSet说明及源码分析  LinkedHashSet全面说明 LinkedHashSet底层机制示意图 LinkedHashSet底层源码分析     Set接口和常用方法   Set接口基本介绍\n 无序（添加和取出的顺序不一致），没有索引 不允许重复元素，所以最多包含一个null JDK API中Set接口常用的实现类有：HashSet、TreeSet等    Set接口的常用方法\n 和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。（详情见Java集合类(一)）    以Set接口的实现类HashSet来讲解Set接口的方法\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class SetMethod { public static void main(String[] args) { Set set = new HashSet(); set.add(\u0026#34;john\u0026#34;); set.add(\u0026#34;jack\u0026#34;); set.add(\u0026#34;tom\u0026#34;); set.add(\u0026#34;john\u0026#34;); set.add(null); set.add(null); System.out.println(\u0026#34;set = \u0026#34; + set); } } 运行结果：\n结论：\n set接口的实现类的对象（set接口对象），不能存放重复的元素，可以添加null set接口对象存放数据是无序（即添加的顺序和取出的顺序不一致） 取出的顺序虽然不是添加的属性，但是顺序是固定的！    Set接口的遍历方式\n同Collection的便利方式一样，因为Set接口是Collection接口的子接口。\n  使用迭代器\nSystem.out.println(\u0026#34;===迭代器遍历===\u0026#34;); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(\u0026#34;set = \u0026#34;+next); }   增强for\nSystem.out.println(\u0026#34;增强for遍历\u0026#34;); for (Object o: set) { System.out.println(\u0026#34;set = \u0026#34;+o); }   不能使用索引的方式来获取\n    HashSet全面说明   HashSet实现了Set接口\n  HashSet实际上是HashMap\npublic HashSet() { map = new HashMap\u0026lt;\u0026gt;(); }   可以存放null值，但是只能有一个\n  HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序与取出顺序一致）\n  不能有重复元素或对象\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class HashSet01 { public static void main(String[] args) { Set hashSet = new HashSet(); /*说明 * 1. 在执行add方法后，会返回一个Boolean值 * 2. 如果添加成功，返回true，否则返回false * 3. 可以通过remove指定删除哪个对象 * */ System.out.println(hashSet.add(\u0026#34;mary\u0026#34;));//T  System.out.println(hashSet.add(\u0026#34;mary\u0026#34;));//F  hashSet.add(\u0026#34;jack\u0026#34;);//可以添加  hashSet.add(\u0026#34;jack\u0026#34;);//添加失败  //由于下面每一次add都新建了一个Dog对象  //所以下面两个Dog对象都会添加成功  hashSet.add(new Dog(\u0026#34;tom\u0026#34;)); hashSet.add(new Dog(\u0026#34;tom\u0026#34;)); System.out.println(\u0026#34;HashSet = \u0026#34;+ hashSet); hashSet.remove(\u0026#34;mary\u0026#34;);//删除mary  System.out.println(\u0026#34;HashSet = \u0026#34;+ hashSet); } }   思考   下面两个String对象都会被添加到HashSet集合里面去吗？\nhashSet.add(new String(\u0026#34;czh\u0026#34;)); hashSet.add(new String(\u0026#34;czh\u0026#34;)); 运行的结果是仅有一个数据被添加，为什么呢？\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) 因为此时String类型重写的equals()方法是比较其字符串内容是否相同，所以此时添加的两个“czh”数据只有一个能被添加进去。\n而上述Dog对象的添加原理也是类似。\n下面我们通过解读HashSet的底层结构解决这个问题！\n  HashSet底层解析   因为HashSet的底层是HashMap，所以分析HashMap底层是（数组+链表+红黑树）即可\n为了更好理解HashMap的底层，下面模拟一个简单的数组+链表结构\n创建Node结点\n//结点Node，item存储数据，next指向下一个结点，可以形成链表 class Node{ Object item; Node next; public Node(Object item, Node next) { this.item = item; this.next = next; } } 创建HashSetStructure类\npackage com.conllection_.sets; public class HashSetStructure { public static void main(String[] args) { //1. 创建一个类型为Node的数组  Node[] nodes = new Node[16]; //2. 创建结点  Node john = new Node(\u0026#34;john\u0026#34;, null); nodes[2] = john; Node jack = new Node(\u0026#34;jack\u0026#34;, null); john.next = jack; Node mary = new Node(\u0026#34;mary\u0026#34;, null); jack.next = mary; Node lucy = new Node(\u0026#34;lucy\u0026#34;, null); nodes[3] = lucy; System.out.println(\u0026#34;node = \u0026#34;+nodes); } } 运行结果：\n  HashSet底层添加元素源码分析   分析HashSet添加元素的底层是如何实现的（hash()+equals()）\n HashSet底层就是HashMap 添加一个元素时，先通过hash()得到hash值，然后转换成索引值 找到存储数据表table，看这个索引位置是否已经存放了元素  如果没有，直接添加 如果有元素，调用equals比较，如果元素内容相同，就放弃添加，如果不相同，则添加到最后   在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。 当元素个数到达TREEIFY_THRESHOLD但table的大小小于MIN_TREEIFY_CAPACITY(默认64)时，系统会把table表填扩容到64，然后进行树化。    HashSet添加元素的源码解读\n创建HashSetSource类，用于debug\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class HashSetSource { public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\u0026#34;jack\u0026#34;); hashSet.add(\u0026#34;tom\u0026#34;); hashSet.add(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;set = \u0026#34; + hashSet); } }   执行构造器\npublic HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } 可以清晰地知道HashSet的底层就是HashMap\n  执行add()方法\npublic boolean add(E e) {//e=\u0026#34;jack\u0026#34;  return map.put(e, PRESENT)==null; } PRESENT是hashSet为了能使用hashMap而定义的一个常量（定值），无论添加了多少的元素它都不会变化\nprivate static final Object PRESENT = new Object();   执行put()方法\npublic V put(K key, V value) {//key = \u0026#34;jack\u0026#34;  return putVal(hash(key), key, value, false, true); } value为PRESENT,是共享的。\n  执行hash方法，计算key的hash值\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 如果key != null，程序会执行Object类中的hashCode()方法来获取key的值，并将它进行无符号右移16位（为了防止key的hashCode值发生冲突），最后得到的h为key对应的hash值。\nhash值并不是hashCode，因为(h = key.hashCode()) ^ (h \u0026raquo;\u0026gt; 16)\n  获取到hash值后，执行putVal方法（重要！）\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;//定义了辅助变量  if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 在此方法中，因为辅助变量tab的初始值为null，所以进入到resize()方法，给tab表赋予初始大小。\nif ((tab = table) == null || (n = tab.length) == 0){ n = (tab = resize()).length; } 上述代码中的table为hashMap的一个属性，类型为Node[]\n因为初始的table为null，所以执行resize()方法\n//下面代码为resize()方法的一些初始赋值 Node\u0026lt;K,V\u0026gt;[] oldTab = table;//结点oleTab表示原先的表 //oldCap表示初始表的容量大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldThr为当前表的一个临界值，当达到临界值时会扩容 int oldThr = threshold; int newCap, newThr = 0; 因为初始的table为null，所以oldCap为0，所以进入到下述语句\nelse { // zero initial threshold signifies using defaults  newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } DEFAULT_INITIAL_CAPACITY为hashMap定义的常量，大小为16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 所以newCap= 16，即第一次扩容大小为16\nnewThr为表的一个临界值，是使用负载因子DEFAULT_LOAD_FACTOR乘以初始大小等到的一个值。\n 默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\n 使用newThr是为了减少冲突，增加一个缓冲区，避免在多线程向表中增加数据时，表的内存不够而导致死锁。\n初始化tap的大小之后，会判断**(p = tab[i = (n - 1) \u0026amp; hash])**是否为null，(n - 1) \u0026amp; hash是位运算，详解见HashMap数学原理。计算出来的i为该key值在table表中的索引位置。\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 如果p=null，表示还没有存放元素，执行**tab[i] = newNode(hash, key, value, null);**创建一个Node（key=“jack\u0026quot;,value=PRESENT）把hash也放进Node是为了下次添加元素时比较。\n执行完毕，此时我们可以发现此时table表中已经在刚刚计算出来的索引值上添加了“jack”。\n到此为止，HashMap的第一次添加元素分析完毕。\n当我们向HashMap集合表再次添加数据时，系统会计算其hash值，然后通过\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 方法判断该hash值对应的索引位置上是否已经存在值，如果不存在，即把新增的key添加到表中的该索引位置上。\n此时可以发现，table表上多了一个数据\n如果该hash值对应的索引位置上已经存在值，程序会跳到下面语句\n//p为当前索引位置上对应的链表的第一个元素，即已经添加的值 //所以p.hash为已存在值得hash值，p.key为已存在值得key值 if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ e = p; } 如果当前索引位置上对应的链表的第一个元素的hash值与需要添加的key的hash值一样\n且满足以下两个条件之一：\n 准备添加的key值与p指向的Node结点的key是同一个对象 p指向的Node结点的key的equals()和准备假如的key比较后相同。  需要注意的是，此时equals()方法不能理解为只比较字符串内容是否相同，因为每一个类都会有其对应的equals()方法，所以equals()方法的比较内容可以由程序员所重写的方法来决定！\n此时说明新增加的key值已存在，所以该key值不会被添加到table中。\n若不满足上述条件，程序会继续往下走，执行下面语句。\nelse if (p instanceof TreeNode){ e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); } 上述语句会判断p是否为红黑树，如果是红黑树，就调用putTreeVal进行添加。\n如果p不是红黑树，执行以下代码\nelse { for (int binCount = 0; ; ++binCount) { //这是条件1  if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } //这是条件2  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } 因为在可以执行上述代码时，说明此时table表中是使用链表的方式来存储数据 。\n此时进入一个死循环，退出的条件：\n  条件1：在要加入的位置i = (n - 1) \u0026amp; hash处所形成的链表没有一个结点与要加入的结点相同时，退出循环，此时就加在最末尾。添加成功\n  条件2 :在要加入的位置i = (n - 1) \u0026amp; hash处所形成的链表有结点与要加入的结点相同，此时退出循环，添加失败\n  两个条件结合起来使用\n需要注意的是当我们把元素添加到聊表后，会进行以下判断\nif (binCount \u0026gt;= TREEIFY_THRESHOLD - 1){ // -1 for 1st \ttreeifyBin(tab, hash); } 判断链表是否已经达到8个结点（TREEIFY_THRESHOLD=8）。如果到达，则调用treeifyBin(tab, hash)方法对当前链表进行树化（转换成红黑树）。\n注意，在转换成红黑树时，treeifyBin(tab, hash)方法会进行判断\nif (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY){ resize(); } 判断table表大小是否\u0026lt;64，如果小于64，会先将table表进行扩容，再进行树化。\n    HashSet扩容机制和转换红黑树机制源码解析   HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）=16*负载因子（loadFactor）0.75 = 12\n  如果数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是 32 * 0.75 = 24，依次类推\n  在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），否则任然采用数组扩容机制\n创建测试类HashSetIncrement.java\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Objects; public class HashSetIncrement { public static void main(String[] args) { HashSet hashSet = new HashSet(); for (int i = 1; i \u0026lt;=12; i++) { hashSet.add(new A(i)); } System.out.println(\u0026#34;hashSet = \u0026#34;+ hashSet); } } Class A\nclass A { private int n ; public A(int n) { this.n = n; } @Override public int hashCode() { return 100; } } 在HashSetIncrement类中的for循环处加一个断点，debug。可以发现，当i=9时，即满足一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，此时触发转换红黑树机制。\n但是此时不满足table表大小\u0026gt;=64\nif (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY){ resize(); } 所以此时table表会进行扩容。\n继续执行，可以发现table再次扩容。\n再继续执行，可以发现此时链表已经发生树化（转换成红黑树）\n树化过程的源码\nelse if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } 详细解释见Jdk1.8集合框架之HashMap源码解析\n  threshold补充说明   在putVal方法中，有这么一行代码\n++modCount; if (++size \u0026gt; threshold){ resize(); } afterNodeInsertion(evict); modCount代表我们对table表修改的次数。\n其中size是每当我们加入一个结点Node(key,value,hash,next)，size++。\n所以当我们想table表中加入指定数量的Node结点是，也会触发扩容机制。\n代码演示HashSetIncrement类\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Objects; public class HashSetIncrement { public static void main(String[] args) { HashSet hashSet = new HashSet(); for (int i = 1; i \u0026lt;=7; i++) { hashSet.add(new A(i)); } for (int i = 1; i \u0026lt;=7; i++) { hashSet.add(new B(i)); } System.out.println(\u0026#34;hashSet = \u0026#34;+ hashSet); } } Class A 与 Class B\nclass B { private int n ; public B(int n) { this.n = n; } @Override public int hashCode() { return 200; } } class A { private int n ; public A(int n) { this.n = n; } @Override public int hashCode() { return 100; } } 运行调试，可以发现，虽然我们在一条链表上增加了7个元素，然后第二条链表增加到第五个元素时size=12，也触发了扩容机制\n所以触发扩容机制的前提是累积添加元素到达threshold。\n  ​\nLinkedHashSet说明及源码分析 LinkedHashSet全面说明  LinkedHashSet是HashSet的子类。 LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表。 LinkedHashSet根据元素的HashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是一插入顺序保存的。 LinkedHashSet不允许添加重复元素。  LinkedHashSet底层机制示意图   示意图\n  双向链表具体机制与LinkedList底层结构类似。\n  LinkedHashSet底层源码分析 说明\n  在LInkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n  每个节点有before和after属性，这样可以形成双向链表\n  在添加一个元素时，先求hash值，再求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加；原则跟hashset一样）\n  所以，我们遍历LinkedHash可以确定插入顺序和取出顺序一致\n创建LinkedHashSetSource类，用于分析源码\npackage com.conllection_.sets; import java.util.LinkedHashSet; import java.util.Set; public class LinkedHashSetSource { public static void main(String[] args) { Set set = new LinkedHashSet(); set.add(new String(\u0026#34;AA\u0026#34;)); set.add(456); set.add(456); set.add(123); set.add(\u0026#34;czh\u0026#34;); System.out.println(\u0026#34;LinkedHashSet = \u0026#34; + set); } } 可以知道，添加第一次时，系统会将数组table扩容到16，存放的结点类型是LinkedHashMap$Entry\n为什么数组时HashMap$Node[]类型，而存放的元素/数据却是LinkedHashMap$​​​​Entry呢？\n下面我们查看LinkedHashMap底层源码来解决这个问题。\nstatic class Entry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { Entry\u0026lt;K,V\u0026gt; before, after; Entry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } } 我们可以发现上面这个在LinkedHashMap源码中的静态内部类Entry继承了HashMap.Node。即数组的多态。双向链表实现的关键也是在这里。\n继续往下调试\n此时的map与hashSet的不一样，多了几个属性。其中head表示双向链表中的头结点，tail表示尾结点。\n而每一个结点又有before与after属性，指向上一个结点与下一个结点。\n所以LinkedHashSet可以实现按顺序插入及取出。\n进入add()方法\npublic boolean add(E e) { return map.put(e, PRESENT)==null; } 可以知道LinkedHashSet添加元素底层就是HashSet添加元素的底层（因为LinkedHashSet是HashSet的实现子类）\n  ","date":"2021-04-06T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/","title":"Java集合类（二）"},{"content":"Java集合类（一）    集合的概念\n  Collection接口和常用方法\n  List接口和常用方法\n  ArrayList底层源码即注意事项\n  Vector底层结构和源码解析\n  LinkedList底层结构和源码解析\n   集合的概念   由于前面保存多个数据使用的是数组，而数组保存数据会有一些不足的地方。\n 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型的元素 使用数组进行增加元素/删除会比较麻烦    若使用集合来处理数据的话，这类问题将会减少。集合的好处如下：\n 可以动态保存任意多个对象，使用比较方便！ 提供了一系列方便操作对象的方法：add、remove、set、get等 使用集合添加、删除新元素的代码更加简洁了    集合的框架体系\nCollection接口实现子类：\nMap接口实现子类：\n  集合主要有两种（单列集合，双列集合）\n  Collection接口有两个重要的子接口List、Set，他们的实现子类都是单列集合\nArrayList arrayList = new ArrayList(); arrayList.add(\u0026#34;jack\u0026#34;); arrayList.add(\u0026#34;tom\u0026#34;);   Map接口的实现子类是双列集合，即以K-V形式存放数据的\nHashMap hashMap = new HashMap(); hashMap.put(\u0026#34;No1\u0026#34;,\u0026#34;jack\u0026#34;); hashMap.put(\u0026#34;No2\u0026#34;,\u0026#34;tom\u0026#34;);     Collection接口和常用方法   Collection接口的特征\n  Collection实现子类可以存放多个元素，每个元素可以是Object\n  有些Collection的实现类，可以存放重复的元素，有些不可以\n  Collection实现类有些是有序的（List），有些不是有序的（Set）\n  Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的\n    Collection接口的常用方法\n add：添加单个元素 remove：删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：增加多个元素 containsAll：查找多个元素是否都存在 removeAll：删除多个元素  以Collection的实现子类演示上述方法\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class Collecyion_ { @SuppressWarnings({\u0026#34;all\u0026#34;}) public static void main(String[] args) { List List = new ArrayList(); //add：添加单个元素  List.add(10); List.add(\u0026#34;java\u0026#34;); List.add(true); System.out.println(\u0026#34;List=\u0026#34;+List); //remove：删除指定元素  List.remove(true); System.out.println(\u0026#34;List=\u0026#34;+List); //contains：查找元素是否存在  System.out.println(List.contains(10)); //size：获取元素个数  System.out.println(List.size()); //isEmpty：判断是否为空  System.out.println(List.isEmpty()); //clear：清空  List.clear(); System.out.println(\u0026#34;List=\u0026#34;+List); //addAll:增加多个元素  List List2 = new ArrayList(); List2.add(\u0026#34;红楼梦\u0026#34;); List2.add(\u0026#34;三国演义\u0026#34;); List2.add(\u0026#34;水浒传\u0026#34;); List.addAll(List2); System.out.println(\u0026#34;List=\u0026#34;+List); //containsAll：查找多个元素是否都存在  System.out.println(List.containsAll(List2)); //removeAll：删除多个元素  List.removeAll(List2); System.out.println(\u0026#34;List=\u0026#34;+List); } }   Collection接口使用Iterator(迭代器)遍历元素\n Iterator对象称为迭代器，主要用于遍历Collection集合中的元素 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器 Iterator仅用于遍历集合，Iterator本身并不存放对象 hasNext()：判断是否还有下一个元素 next()：将下移以后集合位置上的元素返回  代码演示：\nCollection_Book类\npackage com.conllection_; public class Collection_Book { private String name; private String author; private double price; public Collection_Book(String name, String author, double price) { this.name = name; this.author = author; this.price = price; } @Override public String toString() { return \u0026#34;Collection_Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, author=\u0026#39;\u0026#34; + author + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } Collection_Iterator类\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import com.conllection_.Collection_Book; public class Collection_Iterator { public static void main(String[] args) { Collection col =new ArrayList(); col.add(new Collection_Book(\u0026#34;三国演义\u0026#34;,\u0026#34;罗贯中\u0026#34;,10.1)); col.add(new Collection_Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,15.1)); col.add(new Collection_Book(\u0026#34;小李飞刀\u0026#34;,\u0026#34;古龙\u0026#34;,8.1)); //创建col对应的迭代器  Iterator iterator = col.iterator(); //使用while遍历循环  while (iterator.hasNext()){ //因为迭代器取到的数据可以是任意类型的，所以用Object  Object obj= iterator.next(); System.out.println(obj); } } } 运行结果\n hasNext()的返回值为Boolean，\nnext()的返回值可以为任意类型\n 注意：当退出while循环后，这是iterator迭代器指向最后一个元素，此时再使用iterator.next()系统会报错。\n如果要再次遍历，我们需要重置迭代器：\niterator = col.iterator();//重置迭代器   在IDEA中可以使用itit快捷生成\nwhile (iterator.hasNext()){ Object obj= iterator.next(); System.out.println(obj); }   ctrl+j可以看到所有快捷键\n  Collection接口使用增强for循环来遍历元素\n 增强for就是简化版的iterator，本质一样，只能用于遍历集合或素组  基本语法\nfor(Object object : col){ System.out.println(object); } 代码演示\nCollection_For类\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; public class Collection_For { public static void main(String[] args) { Collection col =new ArrayList(); col.add(new Collection_Book(\u0026#34;三国演义\u0026#34;,\u0026#34;罗贯中\u0026#34;,10.1)); col.add(new Collection_Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,15.1)); col.add(new Collection_Book(\u0026#34;小李飞刀\u0026#34;,\u0026#34;古龙\u0026#34;,8.1)); for(Object object : col){ System.out.println(object); } } } 运行结果与使用迭代器的一致。\n我们在**for(Object object : col)**这行代码加一个断点，通过Debug，可以发现增强for会依次调用迭代器的底层方法！\npublic Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } public boolean hasNext() { return cursor != size; } public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 所以，我们可以得知，增强for的底层仍然是迭代器！\n  List接口和常用方法 List接口是Collection接口的子接口\n  List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复\n  List集合中的每个元素都有其对应的顺序索引，即支持索引\n  List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n  List接口常用的实现类有:ArrayList、LinkedList、Vector\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class List_ { public static void main(String[] args) { List list = new ArrayList(); //1. List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复  list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;mary\u0026#34;); list.add(\u0026#34;heng\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;list=\u0026#34;+list); //2. List集合中的每个元素都有其对应的顺序索引，即支持索引  // 索引从0开始  System.out.println(list.get(3)); } }   List接口的常用方法\n  void add(int index,Object ele)：在index位置插入ele元素。\n  bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。\n  Object get(int index)：获取指定index位置的元素。\n  int indexOf(Object obj)：返回obj在集合中首次出现的位置。\n  int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。\n  Object remove(int index)：移除指定index位置的元素，并返回此元素。\n  Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。\n  List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。\n代码演示：\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class ListMethod { public static void main(String[] args) { List list1 = new ArrayList\u0026lt;\u0026gt;(); list1.add(\u0026#34;tom\u0026#34;); list1.add(\u0026#34;cat\u0026#34;); list1.add(\u0026#34;jack\u0026#34;); list1.add(\u0026#34;mary\u0026#34;); list1.add(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 1. void add(int index,Object ele)：在index位置插入ele元素。  list1.add(2,\u0026#34;nancy\u0026#34;); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 2. bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。  List list2 = new ArrayList(); list2.add(\u0026#34;heng\u0026#34;); list2.add(\u0026#34;minster\u0026#34;); System.out.println(\u0026#34;list2 = \u0026#34;+list2); list1.addAll(3,list2); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 3. Object get(int index)：获取指定index位置的元素。  System.out.println(list1.get(3)); // 4. int indexOf(Object obj)：返回obj在集合中首次出现的位置。  System.out.println(list1.indexOf(\u0026#34;tom\u0026#34;)); // 5. int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。  System.out.println(list1.lastIndexOf(\u0026#34;tom\u0026#34;)); // 6. Object remove(int index)：移除指定index位置的元素，并返回此元素。  System.out.println(list1.remove(0)); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 7. Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。  //index必须是存在的下标，越界会报错！  //返回被替换的值  System.out.println(list1.set(3,\u0026#34;rui\u0026#34;)); System.out.println(\u0026#34;list1 = \u0026#34;+ list1); // 8. List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。  //返回的子集合为前闭后开区间！ forIndex \u0026lt;= subList \u0026lt; toIndexE  System.out.println(list1.subList(2,4)); } }     List的三种遍历方式\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ListFor { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;成志恒\u0026#34;); list.add(1); System.out.println(\u0026#34;====迭代器遍历====\u0026#34;); // 1.迭代器遍历  Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(\u0026#34;obj = \u0026#34;+obj); } System.out.println(\u0026#34;====增强for遍历====\u0026#34;); // 2.增强For  for (Object o : list){ System.out.println(\u0026#34;obj = \u0026#34;+o); } System.out.println(\u0026#34;====普通For遍历====\u0026#34;); // 3.普通For  for (int i =0; i\u0026lt; list.size();i++){ System.out.println(\u0026#34;obj = \u0026#34;+list.get(i)); } } } List的其他实现子类（LinkedList、Vector）也可以使用上述三种方式进行遍历\n  练习：Book类：\npackage com.conllection_.lists; public class Book { private String name; private double price; private String author; public Book(String name, String author,double price) { this.name = name; this.author = author; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } @Override public String toString() { return \u0026#34;名称：\u0026#34;+name+\u0026#34;\\t\\t价格：\u0026#34;+price+\u0026#34;\\t\\t作者：\u0026#34;+author; } } ListExercise02类：\npackage com.conllection_.lists; import java.util.*; public class ListExercise02 { public static void main(String[] args) { List list = new Vector(); list.add(new Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,100)); list.add(new Book(\u0026#34;三国\u0026#34;,\u0026#34;罗贯中\u0026#34;,80)); list.add(new Book(\u0026#34;西游记\u0026#34;,\u0026#34;吴承恩\u0026#34;,90)); list.add(new Book(\u0026#34;水浒传\u0026#34;,\u0026#34;施耐庵\u0026#34;,9)); //list.add(new Book(\u0026#34;西游记\u0026#34;,\u0026#34;吴承恩\u0026#34;,90));  for (Object o : list){ System.out.println(o.toString()); } sort(list); System.out.println(\u0026#34;==排序后==\u0026#34;); for (Object o : list){ System.out.println(o.toString()); } } public static void sort(List list){ int listSize = list.size(); for (int i = 0; i \u0026lt;listSize-1 ; i++) { for (int j = 0; j \u0026lt; listSize-1-i; j++) { //取出对象Book  Book book1 = (Book) list.get(j); Book book2 = (Book) list.get(j+1); if(book1.getPrice() \u0026gt; book2.getPrice()){ list.set(j,book2); list.set(j+1,book1); } } } } } 运行结果：\n  ArrayList底层源码及注意事项   注意事项\n  ArrayList可以加入任意元素，包括null（或者是多个null）。\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class ArrayListDetail { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(null); arrayList.add(\u0026#34;jack\u0026#34;); arrayList.add(null); System.out.println(\u0026#34;list = \u0026#34; + arrayList); } }   ArrayList是由数组来实现数据存储的\n  ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList。\nArrayList.add() 源码：\n//ArrayList.add()的源码没有修饰词synchronized public boolean add(E e) { //Increments modCount!!  ensureCapacityInternal(size + 1); elementData[size++] = e; return true; } 由于该集合的方法没有用synchronized修饰，我们可以知道ArrayList是线程不安全的！下面可以跟Vector的源码进行比较\nVector.add() 源码：\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; }     ArrayList的底层源码分析（先说结论，再分析源码）\n  ArrayList中维护了一个Object类型的数组elementData。\n//transient 表示瞬间，短暂的，表示该属性不会被序列化 transient Object[] elementData;   当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍（即初始化数组elementData的大小为0，初次添加数据时扩容成10，等到添加的数据达到容量极限时，继续扩容为elementData的1.5倍）。\n  如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容则直接扩容elementData为1.5倍\n    扩容机制源码分析\n  创建ArrayListSource类。\npackage com.conllection_.lists; import java.util.ArrayList; public class ArrayListSource { public static void main(String[] args) { //利用无参构造创建了ArrayList  ArrayList arrayList = new ArrayList(); //利用有参构造创建了ArrayList  //ArrayList list = new ArrayList(8);  for (int i = 0; i \u0026lt; 10; i++) { arrayList.add(i); } for (int i = 11; i \u0026lt; 15 ; i++) { arrayList.add(i); } arrayList.add(100); arrayList.add(200); arrayList.add(null); } }   在ArrayList arrayList = new ArrayList();出添加断点，debug。\npublic ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组，其定义：\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 可以知道此时创建了一个空的elementData数组={}！\n  下一步 执行arrayList.add()。add源码如下\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; }   先确定是否需要扩容（ensureCapacityInternal） 然后再执行，赋值     进入ensureCapacityInternal方法。\nprivate void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity( calculateCapacity(elementData, minCapacity)); } 该方法调用了ensureExplicitCapacity与calculateCapacity方法。\ncalculateCapacity方法源码：\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { //DEFAULT_CAPACITY为常量，定义为10  //minCapacity为集合所需的最小容量  return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } ensureExplicitCapacity方法源码：\nprivate void ensureExplicitCapacity(int minCapacity) { // modCount为当前集合被修改的次数  //用来防止多个线程操作产生的异常。  modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } ensureCapacityInternal方法在这一步中首先调用了calculateCapacity方法来确定minCapacity(最小容量)然后把最小容量返回到ensureExplicitCapacity方法中，判断elementData的大小是够足够，如果不够会使用grow()方法去扩容。\n  然后通过调用grow方法 完成扩容。grow源码：\nprivate void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; //按原来大小的1.5倍扩容  int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //初始值扩容  if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; //判断容量是否超过数组最大容量  if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  // Arrays.copyOf可以把原先数组copy到新的elementData！  elementData = Arrays.copyOf(elementData, newCapacity); } 在这一步完成了：\n 实现扩容 使用扩容机制来确定要扩容到多大 第一次newCapacity = 10 第二次及其以后，按照1.5倍扩容 扩容使用的是Arrays.copyOf()实现，可以把原来elementData的数据copy到扩容后的elementData中 完成后把扩容后的数组逐层返回到add方法里面  扩容后的elementData：\n    当使用有参构造器创建与使用ArrayList时，扩容机制与上述基本一致。\npublic ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } this.elementData = new Object[initialCapacity]创建了指定大小的elementData数组。\ninitialCapacity为构造器传入的初始参数，即为elementData数组的初始大小。\n需要注意的是，有参构造器扩容时第一次扩容为elementData的1.5倍，并不是初始为10！\n 因为calculateCapacity方法中只有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时才会把常量DEFAULT_CAPACITY的值返回到ensureExplicitCapacity。而DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组。由于有参构造创建的elementData必不为空，所以初次扩容时的newCapaCity为elementData大小的1.5倍。\n if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } 扩容后的elementData：\n剩下的扩容步骤与无参的一样！\n    Vector底层结构和源码解析   Vector的定义：\npublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable   ector底层也是一个数组，protected Object[] elementData；\n  Vector是线程同步的，即线程安全，Vector类的操作方法都带有synchronize\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; }   Vector与ArrayList比较\n  Vector扩容的底层源码\n创建Vector_类，使用无参构造器来创建Vector。\npackage com.conllection_.lists; import java.util.Vector; public class Vector_ { public static void main(String[] args) { Vector vector = new Vector(); for (int i = 0; i \u0026lt; 10; i++) { vector.add(i); } vector.add(100); } } Vecto的无参创建初始化elementData大小为10\npublic Vector() { this(10); } 进入到add方法，通过ensureCapacityHelper判断是否需要扩容。\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } ensureCapacityHelper方法：\nprivate void ensureCapacityHelper(int minCapacity) { // overflow-conscious code  //如果最小容量大于数组的实际长度，则扩容  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } 如果minCapacity - elementData.length \u0026gt; 0满足，则通过grow方法扩容\nprivate void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 又因为capacityIncrement=0，所以newCapacity=oldCapacity+oldCapacity，即为原来的两倍！\n扩容后的Vector：\n  ​\nLinkedList底层结构和源码解析  LinkedList底层实现了双向链表和双端队列特点 可以添加任意元素（元素可以重复），包括null LinkedList也是线程不安全的，没有实现同步    LinkedList的底层操作机制\n  LinkedList底层维护了一个双向链表。\n  LinkedList中维护了两个属性first和last分别指向首节点和尾结点。\n  每个节点（Node对象），里面又包含prev、next、item三个属性，其中通过prev指向前一个节点，通过next指向后一个节点。最终实现双向链表。\n  所以LinkedList的元素添加和删除，不是通过数组完成的，相对来说效率较高。\n  LinkedList链表示意图：\n    双向链表的创建使用演示\n创建Note类\npackage com.conllection_.lists; //定义一个Note类，Note对象表示双向链表的一个节点。 public class Note { public Object item;//存放数据  public Note pre;//指向上一个节点  public Note next;//指向下一个节点  public Note(Object name){ this.item=name; } @Override public String toString() { return \u0026#34;Note{\u0026#34; + \u0026#34;name=\u0026#34; + item + \u0026#39;}\u0026#39;; } } 在LinkedList类中模拟建立一个双向链表\npackage com.conllection_.lists; public class LinkedList01 { public static void main(String[] args) { //模拟一个简单的双向链表  //首先创建三个结点 jack、mary、tom  Note jack = new Note(\u0026#34;jack\u0026#34;); Note mary = new Note(\u0026#34;mary\u0026#34;); Note tom = new Note(\u0026#34;tom\u0026#34;); //连接三个结点形成双向链表  //jack-\u0026gt;mary-\u0026gt;tom  jack.next = mary; mary.next = tom; //tom-\u0026gt;mary-\u0026gt;jack  tom.pre = mary; mary.pre = jack; //创建头结点与尾结点  //让first引用指向jack，就是双向链表的头结点  Note first = jack; //让last引用指向tom，就是双向链表的尾结点  Note last = tom; } } 利用头结点遍历，遍历链表\n//头结点遍历 System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 利用尾结点遍历，遍历链表\nSystem.out.println(\u0026#34;==尾结点遍历==\u0026#34;); while(true){ if(last == null){ break; } System.out.println(last); last = last.pre; } 在mary结点与tom结点之间增加一个smith结点\n//在mary与tom之间增加一个smith结点  Note smith = new Note(\u0026#34;smith\u0026#34;); smith.pre = mary; smith.next = tom; mary.next = smith; tom.pre = smith; first = jack; //头结点遍历  System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 删除smith结点\n//删除smith结点  System.out.println(); System.out.println(\u0026#34;删除smith结点\u0026#34;); mary.next = tom; tom.pre = mary; first = jack; //头结点遍历  System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 运行结果：\n  利用LinkedList的CRUD来查看其底层源码\nLinkedListCRUD.java\npackage com.conllection_.lists; import java.util.LinkedList; public class LinkedListCRUD { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); linkedList.add(100); linkedList.add(200); } } 在LinkedList linkedList = new LinkedList();处添加断点，debug。\n可以知道此时LinkedList只初始化了一个空的linkedList\npublic LinkedList() {} 此时linkedList的属性 first = null，last = null\n然后查看add方法的源码，我们可以发现add方法调用了方法linkLast\npublic boolean add(E e) { linkLast(e); return true; } 查看linkLast方法的源码，我们可以发现此时创建了一个newNode结点，并将其加入到双向链表的最后。\nvoid linkLast(E e) { //初始last为null，所以l=null  final Node\u0026lt;E\u0026gt; l = last; final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } 因为是第一个结点，所以newNode的next与last均为空。此时LinkedList的first与last均指向了newNode。此时链表的状态为：\n当我们再次往LinkedList集合中添加元素时，会再次进入到底层的linkLast方法。\nvoid linkLast(E e) { //l = last 即指向了第一个newNode  final Node\u0026lt;E\u0026gt; l = last; //此时新的newNode有prev = l 即新的newNode指向了第一个结点！  final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; //因为l = last 所以l不为null  if (l == null) first = newNode; else l.next = newNode; size++; //modCount记录集合修改的次数  modCount++; } 因为此时的last不再为空，所以结点l指向了last结点，即第一个newNode。此时链表的状态为：\n  上述代码为LinkedList集合添加元素时的源码展示，下面我们看一下LinkedList集合删除指定索引的元素时的源码：\nLinkedListCURD类\npackage com.conllection_.lists; import java.util.LinkedList; public class LinkedListCRUD { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); linkedList.add(100); linkedList.add(200); linkedList.add(300); System.out.println(\u0026#34;linkedList = \u0026#34; + linkedList); linkedList.remove(1); System.out.println(\u0026#34;linkedList = \u0026#34; + linkedList); } } 查看linkedList.remove(int index)方法。\npublic E remove(int index) { checkElementIndex(index); return unlink(node(index)); } 我们可以知道该方法首先通过checkElementIndex(index);检查索引是否合法，不合法会抛出异常。\ncheckElementIndex(index);方法源码：\nprivate void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 上述isElementIndex方法的作用用来判断元素的索引范围\nprivate boolean isElementIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; } 当索引在元素的合法范围时，进入到了node(int index)方法。该方法可以返回指定元素索引处的（非空）结点。\nNode\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); \t//如果index小于size的一半，从头到尾遍历  if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { //如果index大于size的一半，从尾到头遍历  Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } 然后再通过unlink(Node x)方法删除指定索引集合元素。\nE unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null;  //把要删除的元素数据赋值给element，以便删除后返回  final E element = x.item; //新建一个结点next指向x.next  final Node\u0026lt;E\u0026gt; next = x.next; //新建一个结点prev指向x.prev  final Node\u0026lt;E\u0026gt; prev = x.prev; //如果prev == null 说明x结点为头结点。  //此时把first指向next，即说明x的下一个结点为新的头结点  if (prev == null) { first = next; } else {//否则x的上一个节点的next值指向x的下一个结点  prev.next = next; //因为x已经删除，所以把prev置为null  x.prev = null; } //如果next == null 说明该节点为尾结点  //此时吧last指向prev，即说明x的上一个结点为新的尾结点  if (next == null) { last = prev; } else {//否则把x的下一个结点的prev指向x的上一个结点  next.prev = prev; //因为x已经删除，next  x.next = null; } x.item = null; //集合的大小减一  size--; //修改次数+1次  modCount++; //最后返回被删除的元素  return element; } 下面为删除two结点的图解\n删除后的链表状态为\n  ArrayList和LinkedList比较\n  如何选择ArrayList和LinkedList\n 如果我们改查的操作多，就选ArrayList 如果我们增删操作多，就选择LinkedList 一般来说，在程序中，80%—90%都是查询，因此大部分情况下会选择ArrayList 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另一个模块使用的是LinkedList    ","date":"2021-04-05T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/","title":"Java集合类（一）"},{"content":"多线程详解   进程与线程简介 创建线程 线程状态 线程同步 线程协作 线程池   进程与线程简介   进程（Process）：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——系统资源分配的最小单位。\n  线程（Thread）：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。\n  两者之间的区别见下图\n可以发现，进程是由（线程+内存+文件/网络句柄）等元素构成的\n  注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。\n  普通方法调用和多线程\n  核心概念\n 线程就是独立的执行路径 在程序执行时，即使没有自己创建1线程，后台也会有多个线程，如主线程，gc线程(垃圾回收线程)。 main()称之为主线程，为系统的入口，用于执行整个程序 在一个程序中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。 线程会带来额外的开销，如CPU调度时间；并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。    创建线程 三种创建方式\n  继承Thread创建线程\n 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程  创建TestThread01类，实现继承Thread类创建线程\npackage com.thread_; //创建线程类方式一：继承Thread类，重写run方法，在主线程调用start开启线程。 public class TestThread01 extends Thread{ //run方法线程体  @Override public void run() { for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;我在看代码！\u0026#34;+i); } } //主方法，main线程  public static void main(String[] args) { //创建一个线程对象  TestThread01 testThread01 = new TestThread01(); //调用start开启线程  testThread01.start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;我在学习线程\u0026#34;+i); } } } 运行结果：\n需要注意的是，线程开启不一定立即执行，由CPU的调度执行\n  实现多线程进行网络图片下载\n首先我们需要引入commons-io包，并且把它导入到项目下的lib包中\n再创建下载器WebDownLoader类用于下载网络图片\nclass WebDownLoader{ //下载方法  public void downLoader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\u0026#34;DownLoader方法出现异常\u0026#34;); } } } 创建线程类TestThread02\npackage com.thread_; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; public class TestThread02 extends Thread{ //创建属性url与name，用于接收网络图片地址和保存文件名  private String url; private String name; //创建TestThread02的构造器  public TestThread02(String url,String name){ this.url = url; this.name = name; } //重写run方法，下载图片的线程执行体  @Override public void run() { WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downLoader(url,name); System.out.println(\u0026#34;DownLoader Image \u0026#34; + name); } public static void main(String[] args) { TestThread02 t1 = new TestThread02(\u0026#34;https://github.com/minster77/minster77.github.io/blob/master/JavaBase.jpg\u0026#34;,\u0026#34;1.jpg\u0026#34;); TestThread02 t2 = new TestThread02(\u0026#34;https://github.com/minster77/minster77.github.io/blob/master/JavaCollection.jpg\u0026#34;,\u0026#34;2.jpg\u0026#34;); TestThread02 t3 = new TestThread02(\u0026#34;https://github.com/minster77/minster77.github.io/blob/master/JavaThink.jpg\u0026#34;,\u0026#34;3.jpg\u0026#34;); t1.start(); t2.start(); t3.start(); } } 主目录下我们可以发现图片以及下载完成\n而控制台也输出了以下结果\n我们可以发现，三个图片并没有按照我们调用start方法的顺序下载完成。这就是我们所说的多线程执行了。\n  实现Runnable接口创建线程\n 定义一个实现类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程  package com.thread_; public class TestThread03 implements Runnable{ //run方法线程体  @Override public void run() { for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;我在看代码！\u0026#34;+i); } } //主方法，main线程  public static void main(String[] args) { TestThread03 testThread03 = new TestThread03(); //下面两句等价于 new Thread(testThread03).start();  Thread thread = new Thread(testThread03); thread.start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;我在学习线程\u0026#34;+i); } } }  其实实现Runnable接口创建线程与继承Thread类创建线程的方法步骤是一样的，但是由于继承Thread类创建是单继承，具有局限性。所以开始时推荐选择实现Runnable接口创建多线程\n   小结\n继承Thread类\n 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用继承Thread类创建线程，因为面向对象单继承具有局限性  实现Runnable接口\n 实现Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用Runnable接口创建线程，因为可以避免单继承局限性，灵活方便，方便同时一个对象被多个线程使用。    实现Callable接口创建线程\n 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行：Futureresult1 = ser.submit(t1)； 获取结果：boolean r1 = result.get() 关闭服务：ser.shutdownNow()；    Callable的好处\n 可以定义返回值 可以返回异常    线程状态   线程具有五个状态，分别是创建状态、就绪状态、阻塞状态、运行状态、死亡状态。\n关系图如下\n线程状态转换细节\n线程方法\n setPriority(int newPriority)：更改线程的优先级 static void sleep(long millis)：在指定的毫秒数内让当前正在执行的线程体休眠 void join()：等待该线程终止 static void yield()：暂停当前正在执行的线程对象，并执行其他线程 void interrupt()：中断线程。不建议使用！ boolean isAlive()：测试线程是否处于活动状态   不建议使用JDK提供的stop()、destory()方法[已废弃！]。\n推荐让线程自己停下来。\n或者使用一个标志位进行终止变量，当flag=false时，则终止线程运行。\n 设置标志位让线程停止的代码演示：\npackage com.lambda; public class TestStop implements Runnable{ //1.设置一个标志位  private boolean flag = true; @Override public void run() { int i = 0; while (flag){ System.out.println(\u0026#34;run Thread...\u0026#34;+i++); } } //2.设置一个对外提供的方法停止线程，转换标志位  private void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;main = \u0026#34;+i); if (i==900){ //调用stop方法切换标志位，让线程停止；  testStop.stop(); System.out.println(\u0026#34;线程停止了！\u0026#34;); } } } }   线程休眠\n sleep(time)指定当前线程阻塞的毫秒数； sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等。 每一个对象都有一个锁，sleep不会释放锁   模拟网络延时：可以放大问题的发生性。\n 模拟倒计时\npackage com.lambda; import java.text.SimpleDateFormat; import java.util.Date; public class TestSleep { public static void main(String[] args) throws InterruptedException { timeDown(); } public static void timeDown() { int n = 10; while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(n--); if (n\u0026lt;=0){ break; } } } } 打印出当前系统时间\npackage com.lambda; import java.text.SimpleDateFormat; import java.util.Date; public class TestSleep { public static void main(String[] args) throws InterruptedException { //获取系统当前时间  Date startDate = new Date(System.currentTimeMillis()); while (true){ Thread.sleep(1000); System.out.println(new SimpleDateFormat(\u0026#34;HH:mm:ss\u0026#34;).format(startDate)); startDate = new Date(System.currentTimeMillis()); } } }   线程礼让\n 线程礼让，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态，让CPU重新调度，礼让不一定成功！看CPU心情  创建测试类TestYield\npackage com.lambda; public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\u0026#34;a\u0026#34;).start(); new Thread(myYield,\u0026#34;b\u0026#34;).start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\u0026#34;线程开始了\u0026#34;); Thread.yield(); System.out.println(Thread.currentThread().getName()+\u0026#34;线程停止了\u0026#34;); } } 礼让成功：\n礼让失败：\n  Join方法：Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞。（就是强制插队，不建议使用！）\npackage com.lambda; public class TestJoin implements Runnable{ public static void main(String[] args) throws InterruptedException { TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); for (int i = 0; i \u0026lt; 1000; i++) { if(i == 200){ thread.join(); } System.out.println(\u0026#34;main = \u0026#34; + i); } } @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;我来插队了！\u0026#34;); } } }   观察测试线程的状态\npackage com.lambda; public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 5; i++) { try { //调用sleep方法，进入阻塞状态  Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;///////\u0026#34;); }); //调用getState方法，观察线程状态  Thread.State state = thread.getState(); System.out.println(state);//NEW  thread.start(); state = thread.getState(); System.out.println(state);//RUNNABLE  //只要线程不终止，就一直输出  while (state != Thread.State.TERMINATED){ Thread.sleep(100); state = thread.getState();//更新线程状态  System.out.println(state); } } } 运行结果：\n  线程优先级   Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。\n  线程的优先级用数字表示，范围从1~10\n Thread.MIN_PRIORITY = 1; Thread.MAX_PRIORITY = 10; Thread.NORM_PRIORITY = 5;    使用以下方式可以改变或获取优先级\n getPriority()，setPriority(int xxx);  代码演示\npackage com.thread_; public class TestPriority { public static void main(String[] args) { //main线程的默认优先级为5  System.out.println(Thread.currentThread().getName() + \u0026#34;--\u0026gt;\u0026#34; + Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); //优先级设定在start()调度前  //默认是5  t1.start(); t2.setPriority(3); t2.start(); t3.setPriority(6); t3.start(); t4.setPriority(Thread.MAX_PRIORITY);//MAX_PRIORITY = 10;  t4.start(); t5.setPriority(Thread.NORM_PRIORITY); t5.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + \u0026#34;--\u0026gt;\u0026#34; + Thread.currentThread().getPriority()); } } 运行结果：\n可以发现，优先级高的线程不一定先执行。\n   优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了；这都是看CPU的调度的。（性能倒置）\n 守护线程   线程分为用户线程和守护线程\n  虚拟机必须确保用户线程执行完毕\n  虚拟机不用等待守护线程执行完毕\n  常见的守护现场有：后台记录操作日志，监控内存，垃圾回收等等\u0026hellip;\n  测试守护线程\npackage com.thread_; public class TestDaemon { public static void main(String[] args) { God god = new God(); People people = new People(); Thread thread = new Thread(god); //默认false表示是用户线程，正常线程都是用户线程  //设置为true表示该线程为守护线程  thread.setDaemon(true); //启动守护线程  thread.start(); new Thread(people).start(); } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(\u0026#34;上帝守护着你！\u0026#34;); } } } class People implements Runnable{ @Override public void run() { for (int i = 0; i \u0026lt; 36500; i++) { System.out.println(\u0026#34;你开心的活着\u0026#34;); } System.out.println(\u0026#34;GoodBye world\u0026#34;); } }   线程同步 并发问题的引出\n  并发：同一个对象被多个线程同时操作\n  当我们使用多线程操作一个对象时，容易发生并发问题，下面我们举一个买火车票的例子来引出并发问题\npackage com.thread_.syn; public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,\u0026#34;jack\u0026#34;).start(); new Thread(buyTicket,\u0026#34;tom\u0026#34;).start(); new Thread(buyTicket,\u0026#34;mary\u0026#34;).start(); } } class BuyTicket implements Runnable{ private int ticketNum = 10; private boolean flag =true; @Override public void run() { while (flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } public void buy() throws InterruptedException { if(ticketNum\u0026lt;=0){ flag = false; return; } Thread.sleep(100); System.out.println(Thread.currentThread().getName() + \u0026#34;抢到了第\u0026#34; + ticketNum-- + \u0026#34;票\u0026#34;); } } 运行结果：\n我们可以发现，有一些票被重复拿了！多个线程操作一个资源的情况下，线程不安全，数据紊乱。这就是我们所说的线程并发问题。\n利用线程的同步可以解决上述的问题！\n  线程同步介绍\n ​\t由于统一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制-synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待；使用后释放锁即可。\n 使用锁会存在以下问题\n 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。（性能倒置问题）    同步方法\n  由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制1就是synchronized关键字。它包括两种用法：synchronized方法和synchronized块\n//同步方法 public synchronized void method(int args){ }   synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行\n 缺陷：若将一个大的方法申明为synchronized将会影响效率\n   方法里需要修改的内容才需要锁，锁太多了会浪费资源。\n  所以在上面买火车票的案例中，我们只需要对buy方法加上修饰符synchronized即可以解决并发问题！\npublic synchronized void buy() throws InterruptedException { if(ticketNum\u0026lt;=0){ flag = false; return; } Thread.sleep(100); System.out.println(Thread.currentThread().getName() + \u0026#34;买到了第\u0026#34; + ticketNum-- + \u0026#34;票\u0026#34;); } 运行结果：\n  同步块\nsynchronized(Obj){ } Obj称之为同步监视器\n Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身。或者是class[反射中讲解]  同步监视器的执行过程\n 第一个线程访问，锁定同步监视器，执行其中代码。（第一个人上厕所，把厕所门关上） 第二个线程访问，发现同步监视器被锁定，无法访问。（第二个人去上厕所，发现有人在厕所里面，进不去，就走了） 第一个线程访问完毕，解锁同步监视器。（第一个人上完厕所，打开门） 第二个线程访问，发现同步监视器没有锁，然后锁定并访问。（第二个人又来上厕所，发现没人，便进去了且关上厕所门）     注意：synchronized方法默认锁的是当前对象（加了修饰符的类 即this），而synchronized(Obj){}同步块是可以指定对象锁定的（锁的对象便是变化的量，需要增删改的对象）\n   完成银行取款案例，利用同步块确保线程安全性\npackage com.thread_.syn; public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100, \u0026#34;银行卡\u0026#34;); Drawing drawing1 = new Drawing(account,50,\u0026#34;jack\u0026#34;); Drawing drawing2 = new Drawing(account,100,\u0026#34;mary\u0026#34;); drawing1.start(); drawing2.start(); } } class Account{ int money; String name; public Account(int money, String name) { this.money = money; this.name = name; } } class Drawing extends Thread{ Account account; int drawingMoney; int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱  @Override public void run() { synchronized (account){ if(account.money-drawingMoney\u0026lt;0){ System.out.println(Thread.currentThread().getName()+\u0026#34;取钱，余额不足\u0026#34;); return; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额  account.money = account.money - drawingMoney; nowMoney = nowMoney + drawingMoney; System.out.println(account.name + \u0026#34;余额为：\u0026#34;+ account.money); System.out.println(this.getName() + \u0026#34;手里的余额为\u0026#34; + nowMoney); } } }   死锁\n​\t多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一同步块同时拥有“两个以上对象的锁时”，就可能会发生死锁的问题\n 死锁：多个线程互相抱着对方需要的资源，然后形成僵持\n   产生死锁的四个必要条件：\n 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系   上面列出了死锁的四个必要条件，我们只需要破坏其中的任意一个或多个条件即可避免死锁发生。例如：银行家算法避免死锁\n   Lock(锁)\n 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁  利用ReentrantLock解决买票的并发问题\npackage com.thread_.lock; import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNum = 10; //定义Lock锁  ReentrantLock lock = new ReentrantLock(); @Override public void run() { try { //加锁  lock.lock(); while (true){ if (ticketNum \u0026gt; 0 ){ System.out.println(ticketNum--); }else { break; } } }finally { //解锁  lock.unlock(); } } }   synchronized与Lock的对比\n Lock是显式锁（手动开启和关闭锁，一定要关闭锁！）；synchronized是隐式锁，出了作用域便会自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（Lock锁提供更多的子类） 优先使用顺序  Lock\u0026gt;同步代码块\u0026gt;同步方法      线程协作   生产者和消费者模式（问题）\n  分析\n这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。 在生产者消费者问题中，仅有synchronized是不够的！  synchronized可阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（线程通信）    Java提供了几个方法来解决线程之间的通信问题\n wait()：表示线程会一直等待，直到其他线程通知，与sleep不同，该方法会释放锁 wait(long timeout)：指定等待的毫秒数 notify()：唤醒一个处于等待状态的线程 notifyAll()：唤醒同一个对象上所以调度wait()方法的线程，优先级别高的线程优先调度   注意！上述方法均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常\n   利用管程法解决生产者消费者问题\n  生产者：负责生产数据的模块（可能是方法，对象，线程，进程）；\n  消费者：负责处理数据的模块（可能是方法，对象，线程，进程）；\n  缓冲区：消费者不能直接使用生产者的数据，他们之间有一个缓冲区；生产者将生产好的数据放入缓冲区，消费者从缓冲区中拿出数据\n  package com.thread_.lock; //管程法解决生产者消费者问题 //需要的对象：生产者，消费者，缓冲区，产品 public class TestPC { public static void main(String[] args) { SynContainer synContainer = new SynContainer(); Producer producer = new Producer(synContainer); Customer customer = new Customer(synContainer); new Thread(producer).start(); new Thread(customer).start(); } } //产品 class Chicken { int id; public Chicken(int id) { this.id = id; } } //生产者 class Producer extends Thread{ SynContainer synContainer; public Producer(SynContainer synContainer){ this.synContainer = synContainer; } @Override public void run() { for (int i = 1; i \u0026lt; 50; i++) { try { synContainer.push(new Chicken(i)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产了第\u0026#34;+i+\u0026#34;只鸡\u0026#34;); } } } //消费者 class Customer extends Thread{ SynContainer synContainer; public Customer(SynContainer synContainer){ this.synContainer = synContainer; } @Override public void run() { for (int i = 1; i \u0026lt; 50; i++) { try { System.out.println(\u0026#34;消费了第\u0026#34; + synContainer.pop().id+\u0026#34;只鸡\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } } } } //缓冲区 class SynContainer{ //规定容器的容量  Chicken[] chickens = new Chicken[10]; private int count; //生产者把产品放入到缓冲区  public synchronized void push(Chicken chicken) throws InterruptedException { //如果容器满了，等待消费者消费，停止生产  if (count == chickens.length){ //线程阻塞，等待消费者通知  this.wait(); System.out.println(\u0026#34;缓冲区满了，消费者消费\u0026#34;); } //如果没有满，就需要丢入产品  chickens[count] = chicken; count++; //有产品了，通知消费者消费  this.notify(); } //消费者消费产品  public synchronized Chicken pop() throws InterruptedException { //判断能否消费  if (count == 0){ //没产品了，等待生产者生产  this.wait(); } //如果可以消费  count--; Chicken chicken = chickens[count]; //通知生产者拿走了鸡  this.notify(); return chicken; } }   利用信号灯法解决生产者消费者问题\npackage com.thread_.lock; import javafx.stage.Stage; //信号灯法：利用标志位解决 public class TestPC2 { public static void main(String[] args) { StageShow stageShow = new StageShow(); Player player = new Player(stageShow); Watcher watcher = new Watcher(stageShow); new Thread(player).start(); new Thread(watcher).start(); } } //生产者 -\u0026gt;演员 class Player extends Thread { StageShow stage; public Player(StageShow stage) { this.stage = stage; } @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { if(i%2 ==0){ try { this.stage.Play(\u0026#34;海贼王\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } }else { try { this.stage.Play(\u0026#34;火影忍者\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } } } } } //消费者 -\u0026gt;观众 class Watcher extends Thread { StageShow stage; public Watcher(StageShow stage) { this.stage = stage; } @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { stage.Watch(); } } } //缓冲区 -\u0026gt;舞台 class StageShow { String voice; boolean flag = true; //演员表演，观众等待  public synchronized void Play(String voice) throws InterruptedException { if (flag != true) { this.wait(); } System.out.println(\u0026#34;演员表演了：\u0026#34; + voice); this.voice = voice; this.flag = !this.flag; //表演完成，唤醒观众  this.notifyAll(); } public synchronized void Watch() { if (flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;观众观看了：\u0026#34; + voice); this.flag = !this.flag; //观看完成，唤醒演员  this.notifyAll(); } }   线程池 ​\t如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。\n  思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完毕后放回池中，可以避免频繁的创建销毁、实现重复利用。类似于生活中的交通工具\n  好处：\n 提高了响应速度（减少创建新线程的时间） 降低资源的消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理  corePoolSize：管理核心池（线程池）的大小 maximumPoolSize：管理最大线程数 keepAliveTime：管理线程没有任务时最多保持多少时间后悔终止      JDK5.0起提供了线程池相关API：ExecutorService和Executors\n  ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor\n void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable Future submit (Callabletask)：执行任务/命令，有返回值，一般用来执行Callable void shundown()：关闭连接池    Executors：工具类、线程池工厂类，用于创建并返回不同类型的线程池\n  线程池创建的演示\npackage com.thread_.lock; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; public class TestPool { public static void main(String[] args) { //1.创建服务，创建指定大小的线程池  ExecutorService service = Executors.newFixedThreadPool(10); //2.执行  service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //3.关闭线程池  service.shutdownNow(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } }    总结：ExecutorService通过Executors方法创建线程池，然后执行execute方法或submit 方法来执行服务。\n ","date":"2020-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/javathread/","title":"JavaThread"},{"content":"Java 基础面试题 Java概述 Java语言有哪些特点？   面向对象（封装，继承，多态）；\n  平台无关性，平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。\n  可靠性、安全性；\n  支持多线程。C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；\n  支持网络编程并且很方便。Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便；\n  编译与解释并存；\n  Java和C++有什么关系，它们有什么区别？  都是面向对象的语言，都支持封装、继承和多态； C++ 支持指针，而 Java 没有指针的概念； C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口； Java 是完全面向对象的语言，并且还取消了 C/C++ 中的结构和联合，使编译程序更加简洁； Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而 C++ 中必须由程序释放内存资源，这就增加了程序员的负担。 Java 不支持操作符重载，操作符重载则被认为是 C++ 的突出特征； Java 允许预处理，但不支持预处理器功能，所以为了实现预处理，它提供了引入语句（import），但它与 C++ 预处理器的功能类似； Java 不支持缺省参数函数，而 C++ 支持； C 和 C++ 不支持字符串变量，在 C 和 C++ 程序中使用“Null”终止符代表字符串的结束。在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的； goto 语句是 C 和 C++ 的“遗物”，Java 不提供 goto 语句，虽然 Java 指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读； Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。  JVM、JRE和JDK的关系是什么？ JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。\nJRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。\nJDK包含JRE，JRE包含JVM。\n什么是字节码?  这个问题，面试官可以扩展提问，Java 是编译执行的语言，还是解释执行的语言?\n Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。因此，也可以看出字节码对于Java生态的重要性。\n之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图所示。\n采用字节码的好处是什么? Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\nOracle JDK 和 OpenJDK 的区别是什么？ 可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。\n Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次； OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是OpenJDK 的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题； 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能； Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPLv2 许可获得许可。  基础语法 Java有哪些数据类型？ Java 语言的数据类型分为两种：基本数据类型和引用数据类型。\n1.基本数据类型包括 boolean（布尔型）、float（单精度浮点型）、char（字符型）、byte（字节型）、short（短整型）、int（整型）、long（长整型）和 double （双精度浮点型）共 8 种，如下表所示。\n   基本类型 位数 字节 默认值     int 32 4 0   short 16 2 0   long 64 8 0L   byte 8 1 0   char 16 2 \u0026lsquo;u0000\u0026rsquo;   float 32 4 0f   double 64 8 0d   boolean 1  false    对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。\nJava虚拟机规范讲到：在JVM中并没有提供boolean专用的字节码指令，而boolean类型数据在经过编译后在JVM中会通过int类型来表示，此时boolean数据4字节32位，而boolean数组将会被编码成Java虚拟机的byte数组，此时每个boolean数据1字节占8bit。\n注意：\n Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析： char a = 'h'char :单引号，String a = \u0026quot;hello\u0026quot; :双引号  2.引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++中的指针类型、结构类型、联合类型和枚举类型。\nswitch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？ Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。\n从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。\n从 Java 7 开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。\n访问修饰符public、private、protected、以及不写（默认）时的区别？ Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。  break ,continue ,return 的区别及作用？   break 跳出总上一层循环，不再执行循环(结束当前的循环体)\n  continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)\n  return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)\n  关键字 final、finally、finalize的区别？ final 用于修饰变量、方法和类。\n final 变量：被修饰的变量不可变，不可变分为引用不可变和对象不可变，final 指的是引用不可变，final 修饰的变量必须初始化，通常称被修饰的变量为常量。 final 方法：被修饰的方法不允许任何子类重写，子类可以使用该方法。 final 类：被修饰的类不能被继承，所有方法不能被重写。  finally 作为异常处理的一部分，它只能在 try/catch 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，System.exit (0) 可以阻断 finally 执行。\nfinalize 是在 java.lang.Object 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 gc 启动，该对象被回收的时候被调用。\n一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。\n为什么要用static关键字？ 通常来说，用new创建类的对象时，数据存储空间才被分配，方法才供外界调用。但有时我们只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法。在这两种情况下，static关键字，满足了我们的需求。\n”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。\nJava中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。\n是否可以在static环境中访问非static变量？ static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。\nstatic静态方法能不能引用非静态资源？ 不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。\nstatic静态方法里面能不能引用静态资源？ 可以，因为都是类初始化的时候加载的，大家相互都认识。\n非静态方法里面能不能引用静态资源？ 可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。\njava静态变量、代码块、和静态方法的执行顺序是什么？ 基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块\n代码块执行顺序静态代码块——\u0026gt; 构造代码块 ——\u0026gt; 构造函数——\u0026gt; 普通代码块 继承中代码块执行顺序：父类静态块——\u0026gt;子类静态块——\u0026gt;父类代码块——\u0026gt;父类构造器——\u0026gt;子类代码块——\u0026gt;子类构造器\n想要深入了解，可以参考这篇文章 ：https://juejin.cn/post/6844903986475040781\n面向对象 面向对象和面向过程的区别？ 面向过程：\n  优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\n  缺点：没有面向对象易维护、易复用、易扩展。\n  面向对象：\n  优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。\n  缺点：性能比面向过程低。\n  讲讲面向对象三大特性  封装。封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。 多态性。它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。  Java语言是如何实现多态的？ 本质上多态分两种：\n 1、编译时多态（又称静态多态）\n2、运行时多态（又称动态多态）\n 重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。\n**我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**这也是为什么有时候多态方法又被称为延迟方法的原因。\nJava实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。\n 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。  Java多态的实现原理可看这篇文章：https://my.oschina.net/u/4432600/blog/4535042\n重载（Overload）和重写（Override）的区别是什么？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n 重写发生在子类与父类之间, 重写方法返回值和形参都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。即外壳不变，核心重写！ 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。  重载的方法能否根据返回值类型进行区分？ 不能根据返回值类型来区分重载的方法。因为调用时不指定类型信息，编译器不知道你要调用哪个函数。\nfloat max(int a, int b); int max(int a, int b); 当调用max（1,2）;时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。\n构造器（constructor）是否可被重写（override）？ 构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。\n抽象类和接口的区别是什么？ 语法层面上的区别：\n 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。  设计层面上的区别：\n 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。  想要深入了解，可以参考这篇文章 ：https://www.cnblogs.com/dolphin0520/p/3811437.html\n抽象类能使用 final 修饰吗？ 不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类\njava 创建对象有哪几种方式？ java中提供了以下四种创建对象的方式:\n new创建新对象 通过反射机制 采用clone机制 通过序列化机制  前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。\n什么是不可变对象?好处是什么? 不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象,如 String、Integer及其它包装类.不可变对象最大的好处是线程安全.\n能否创建一个包含可变对象的不可变对象? 当然可以,比如final Person[] persons = new Persion[]{}. persons是不可变对象的引用,但其数组中的Person实例却是可变的.这种情况下需要特别谨慎,不要共享可变对象的引用.这种情况下,如果数据需要变化时,就返回原对象的一个拷贝.\n值传递和引用传递的区别的什么？为什么说Java中只有值传递？ 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\n基本类型作为参数被传递时肯定是值传递；引用类型作为参数被传递时也是值传递，只不过“值”为对应的引用。\n想要深入了解，可以参考这篇文章 ：http://www.itwanger.com/java/2019/11/26/java-yinyong-value.html\n对象相等判断 == 和 equals 区别是什么？ ==常用于相同的基本数据类型之间的比较，也可用于相同类型的对象之间的比较；\n 如果==比较的是基本数据类型，那么比较的是两个基本数据类型的值是否相等； 如果==是比较的两个对象，那么比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域；  equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象\n看一看Object类中equals方法的源码：\npublic boolean equals(Object obj) { return (this == obj); } 它的作用也是判断两个对象是否相等，般有两种使用情况：\n 情况1、，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。  java语言规范要求equals方法具有以下特性：\n 自反性。对于任意不为null的引用值x，x.equals(x)一定是true。 对称性）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。  介绍下hashCode()？ hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n为什么要有 hashCode? 以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。\n但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\nhashCode(),equals()两种方法是什么关系? 要弄清楚这两种方法的关系，就需要对哈希表有一个基本的认识。其基本的结构如下：\n对于hashcode方法，会返回一个哈希值，哈希值对数组的长度取余后会确定一个存储的下标位置，如图中用数组括起来的第一列。\n不同的哈希值取余之后的结果可能是相同的，用equals方法判断是否为相同的对象，不同则在链表中插入。\n则有hashCode()与equals()的相关规定：\n 如果两个对象相等，则hashcode一定也是相同的； 两个对象相等，对两个对象分别调用equals方法都返回true； 两个对象有相同的hashcode值，它们也不一定是相等的；  为什么重写 equals 方法必须重写 hashcode 方法 ﻿？ 断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。\n在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。\nString,StringBuffer, StringBuilder 的区别是什么？ 1.可变与不可变。String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.\nString类利用了final修饰的char类型数组存储字符，源码如下:\nprivate final char value[];\nStringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的。\n源码如下:\nchar[] value;\n2.是否多线程安全。\nString中的对象是不可变的，也就可以理解为常量，显然线程安全。\nStringBuilder是非线程安全的。\nStringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。\n源码如下:\n@Override public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 3.性能\n每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\nString为什么要设计成不可变的？ 1.便于实现字符串池（String pool）\n在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。\nString a = \u0026quot;Hello world!\u0026quot;;\rString b = \u0026quot;Hello world!\u0026quot;;\r如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！\n2.使多线程安全\n在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。\n3.避免安全问题\n在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。\n4.加快字符串处理速度\n由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。\n总体来说，String不可变的原因要包括 设计考虑，效率优化，以及安全性这三大方面。\n参考 https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html\nhttp://c.biancheng.net/view/769.html\nhttp://www.51gjie.com/java/81.html\nhttp://www.justdojava.com/2019/03/21/Java-and-equals/\nhttps://blog.csdn.net/qq_28051453/article/details/52701171\nhttps://www.cnblogs.com/wkfvawl/p/11693260.html\n","date":"2020-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A/","title":"Java基础面试题上"},{"content":" String相关  字符型常量和字符串常量的区别？ 什么是字符串常量池？ String str=\u0026ldquo;aaa\u0026quot;与 String str=new String(\u0026ldquo;aaa\u0026rdquo;)一样吗？new String(“aaa”);创建了几个字符串对象? String 是最基本的数据类型吗? String有哪些特性? 在使用 HashMap 的时候，用 String 做 key 有什么好处？   包装类型  包装类型是什么？基本类型和包装类型有什么区别？ 解释一下自动装箱和自动拆箱？ int 和 Integer 有什么区别? 两个new生成的Integer变量的对比 Integer变量和int变量的对比 非new生成的Integer变量和new Integer()生成变量的对比 两个非new生成的Integer对象的对比   反射  什么是反射？ 反射机制的优缺点有哪些？ 如何获取反射中的Class对象？ Java反射API有几类？ 反射使用的步骤？ 为什么引入反射概念？反射机制的应用有哪些？ 反射机制的原理是什么？   泛型  Java中的泛型是什么 ? 使用泛型的好处是什么? Java泛型的原理是什么 ? 什么是类型擦除 ? 什么是泛型中的限定通配符和非限定通配符 ? List\u0026lt;? extends T\u0026gt;和List \u0026lt;? super T\u0026gt;之间有什么区别 ? 可以把List\u0026lt;String\u0026gt;传递给一个接受List\u0026lt;Object\u0026gt;参数的方法吗？ Array中可以用泛型吗? 判断ArrayList\u0026lt;String\u0026gt;与ArrayList\u0026lt;Integer\u0026gt;是否相等？   序列化  Java序列化与反序列化是什么？ 为什么需要序列化与反序列化？ 序列化实现的方式有哪些？  Serializable接口 Externalizable接口 两种序列化的对比   什么是serialVersionUID？ 为什么还要显示指定serialVersionUID的值? serialVersionUID什么时候修改？ Java 序列化中如果有些字段不想进行序列化，怎么办？ 静态变量会被序列化吗?   异常  Error 和 Exception 区别是什么？ 非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？ throw 和 throws 的区别是什么？ NoClassDefFoundError 和 ClassNotFoundException 区别？ Java常见异常有哪些？ try-catch-finally 中哪个部分可以省略？ try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ JVM 是如何处理异常的？   IO  Java的IO 流分为几种？ 字节流如何转为字符流？ 字符流与字节流的区别？ BIO、NIO、AIO的区别？ Java IO都有哪些设计模式？   参考  String相关 字符型常量和字符串常量的区别？   形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；\n  含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；\n  占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。\n  什么是字符串常量池？ java中常量池的概念主要有三个：全局字符串常量池，class文件常量池，运行时常量池。我们现在所说的就是全局字符串常量池，对这个想弄明白的同学可以看这篇Java中几种常量池的区分。\njvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。\n字符串常量池的位置也是随着jdk版本的不同而位置不同。在jdk6中，常量池的位置在永久代（方法区）中，此时常量池中存储的是对象。在jdk7中，常量池的位置在堆中，此时，常量池存储的就是引用了。在jdk8中，永久代（方法区）被元空间取代了。\nString str=\u0026ldquo;aaa\u0026quot;与 String str=new String(\u0026ldquo;aaa\u0026rdquo;)一样吗？new String(“aaa”);创建了几个字符串对象?  使用String a = “aaa” ;，程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。 使用String b = new String(\u0026ldquo;aaa\u0026rdquo;);`，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。  具体分析，见以下代码：\n@Test public void test(){ String s = new String(\u0026#34;2\u0026#34;); s.intern(); String s2 = \u0026#34;2\u0026#34;; System.out.println(s == s2); String s3 = new String(\u0026#34;3\u0026#34;) + new String(\u0026#34;3\u0026#34;); s3.intern(); String s4 = \u0026#34;33\u0026#34;; System.out.println(s3 == s4); } 运行结果：\njdk6 false false jdk7 false true 这段代码在jdk6中输出是false false，但是在jdk7中输出的是false true。我们通过图来一行行解释。\n先来认识下intern()函数：\n　intern函数的作用是将对应的符号常量进入特殊处理，在JDK1.6以前 和 JDK1.7以后有不同的处理；\n　在JDK1.6中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，则将该字符串常量加入到字符串常量区，也就是在字符串常量区建立该常量；\n　在JDK1.7中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，说明该字符串常量在堆中，则处理是把堆区该对象的引用加入到字符串常量池中，以后别人拿到的是该字符串常量的引用，实际存在堆中\nJDK1.6\nString s = new String(\u0026quot;2\u0026quot;);创建了两个对象，一个在堆中的StringObject对象，一个是在常量池中的“2”对象。 s.intern();在常量池中寻找与s变量内容相同的对象，发现已经存在内容相同对象“2”，返回对象2的地址。 String s2 = \u0026quot;2\u0026quot;;使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回对象\u0026quot;2\u0026quot;的地址。 System.out.println(s == s2);从上面可以分析出，s变量和s2变量地址指向的是不同的对象，所以返回false\nString s3 = new String(\u0026quot;3\u0026quot;) + new String(\u0026quot;3\u0026quot;);创建了两个对象，一个在堆中的StringObject对象，一个是在常量池中的“3”对象。中间还有2个匿名的new String(\u0026ldquo;3\u0026rdquo;)我们不去讨论它们。 s3.intern();在常量池中寻找与s3变量内容相同的对象，没有发现“33”对象，在常量池中创建“33”对象，返回“33”对象的地址。 String s4 = \u0026quot;33\u0026quot;;使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回对象\u0026quot;33\u0026quot;的地址。 System.out.println(s3 == s4);从上面可以分析出，s3变量和s4变量地址指向的是不同的对象，所以返回false\nJDK1.7\nString s = new String(\u0026quot;2\u0026quot;);创建了两个对象，一个在堆中的StringObject对象，一个是在堆中的“2”对象，并在常量池中保存“2”对象的引用地址。 s.intern();在常量池中寻找与s变量内容相同的对象，发现已经存在内容相同对象“2”，返回对象“2”的引用地址。 String s2 = \u0026quot;2\u0026quot;;使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回对象“2”的引用地址。 System.out.println(s == s2);从上面可以分析出，s变量和s2变量地址指向的是不同的对象，所以返回false\nString s3 = new String(\u0026quot;3\u0026quot;) + new String(\u0026quot;3\u0026quot;);创建了两个对象，一个在堆中的StringObject对象，一个是在堆中的“3”对象，并在常量池中保存“3”对象的引用地址。中间还有2个匿名的new String(\u0026ldquo;3\u0026rdquo;)我们不去讨论它们。 s3.intern();在常量池中寻找与s3变量内容相同的对象，没有发现“33”对象，将s3对应的StringObject对象的地址保存到常量池中，返回StringObject对象的地址。 String s4 = \u0026quot;33\u0026quot;;使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回其地址，也就是StringObject对象的引用地址。 System.out.println(s3 == s4);从上面可以分析出，s3变量和s4变量地址指向的是相同的对象，所以返回true。\nString 是最基本的数据类型吗? 不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。\nString有哪些特性?   不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性；\n  常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用；\n  final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。\n  在使用 HashMap 的时候，用 String 做 key 有什么好处？ HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。\n包装类型 包装类型是什么？基本类型和包装类型有什么区别？ Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，把基本类型转换成包装类型的过程叫做装箱（boxing）；反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing），使得二者可以相互转换。\nJava 为每个原始类型提供了包装类型：\n原始类型: boolean，char，byte，short，int，long，float，double\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n基本类型和包装类型的区别主要有以下 几点：\n  包装类型可以为 null，而基本类型不可以。它使得包装类型可以应用于 POJO 中，而基本类型则不行。那为什么 POJO 的属性必须要用包装类型呢？《阿里巴巴 Java 开发手册》上有详细的说明， 数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。\n  包装类型可用于泛型，而基本类型不可以。泛型不能使用基本类型，因为使用基本类型时会编译出错。\nList\u0026lt;int\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 提示 Syntax error, insert \u0026#34;Dimensions\u0026#34; to complete ReferenceType List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。\n  基本类型比包装类型更高效。基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。 很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。\n  解释一下自动装箱和自动拆箱？ 自动装箱：将基本数据类型重新转化为对象\npublic class Test { public static void main(String[] args) { // 声明一个Integer对象，用到了自动的装箱：解析为:Integer num = Integer.valueOf(9); \tInteger num = 9; } } 9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。但jdk1.5 开始引入了自动装箱/拆箱机制，就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。\n自动拆箱：将对象重新转化为基本数据类型\npublic class Test { public static void main(String[] args) { / /声明一个Integer对象 Integer num = 9; // 进行计算时隐含的有自动拆箱 \tSystem.out.print(num--); } } 因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。\nint 和 Integer 有什么区别?  Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。  两个new生成的Integer变量的对比 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。\nInteger i = new Integer(10000); Integer j = new Integer(10000); System.out.print(i == j); //false Integer变量和int变量的对比 Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）\nint a = 10000; Integer b = new Integer(10000); Integer c=10000; System.out.println(a == b); // true  System.out.println(a == c); // true 非new生成的Integer变量和new Integer()生成变量的对比 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）\nInteger b = new Integer(10000); Integer c=10000; System.out.println(b == c); // false 两个非new生成的Integer对象的对比 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false\nInteger i = 100; Integer j = 100; System.out.print(i == j); //true  Integer i = 128; Integer j = 128; System.out.print(i == j); //false 当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。\n给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，源码如下：\npublic static Integer valueOf(String s, int radix) throws NumberFormatException { return Integer.valueOf(parseInt(s,radix)); } /** * （1）在-128~127之内：静态常量池中cache数组是static final类型，cache数组对象会被存储于静态常量池中。 * cache数组里面的元素却不是static final类型，而是cache[k] = new Integer(j++)， * 那么这些元素是存储于堆中，只是cache数组对象存储的是指向了堆中的Integer对象（引用地址） * * （2）在-128~127 之外：新建一个 Integer对象，并返回。 */ public static Integer valueOf(int i) { assert IntegerCache.high \u0026gt;= 127; if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) { return IntegerCache.cache[i + (-IntegerCache.low)]; } return new Integer(i); } IntegerCache是Integer的内部类，源码如下：\n/** * 缓存支持自动装箱的对象标识语义 -128和127（含）。 * 缓存在第一次使用时初始化。 缓存的大小可以由-XX：AutoBoxCacheMax = \u0026lt;size\u0026gt;选项控制。 * 在VM初始化期间，java.lang.Integer.IntegerCache.high属性可以设置并保存在私有系统属性中 */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property  int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE  h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k \u0026lt; cache.length; k++) { cache[k] = new Integer(j++); // 创建一个对象  } } private IntegerCache() {} } 反射 什么是反射？ 反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n反射机制的优缺点有哪些？ 优点：能够运行时动态获取类的实例，提高灵活性；可与动态编译结合Class.forName('com.mysql.jdbc.Driver.class');，加载MySQL的驱动类。\n缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时，有缓存会快很多；ReflflectASM工具类，通过字节码生成的方式加快反射速度。\n如何获取反射中的Class对象？   Class.forName(“类的路径”)；当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。\nClass clz = Class.forName(\u0026#34;java.lang.String\u0026#34;);   类名.class。这种方法只适合在编译前就知道操作的 Class。\nClass clz = String.class;   对象名.getClass()。\nString str = new String(\u0026#34;Hello\u0026#34;); Class clz = str.getClass();   如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。\n  Java反射API有几类？ 反射 API 用来生成 JVM 中的类、接口或则对象的信息。\n  Class 类：反射的核心类，可以获取类的属性，方法等信息。\n  Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。\n  Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。\n  Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。\n  反射使用的步骤？   获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。\n  调用 Class 类中的方法，既就是反射的使用阶段。\n  使用反射 API 来操作这些信息。\n  具体可以看下面的例子：\npublic class Apple { private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws Exception{ //正常的调用  Apple apple = new Apple(); apple.setPrice(5); System.out.println(\u0026#34;Apple Price:\u0026#34; + apple.getPrice()); //使用反射调用  Class clz = Class.forName(\u0026#34;com.chenshuyi.api.Apple\u0026#34;); Method setPriceMethod = clz.getMethod(\u0026#34;setPrice\u0026#34;, int.class); Constructor appleConstructor = clz.getConstructor(); Object appleObj = appleConstructor.newInstance(); setPriceMethod.invoke(appleObj, 14); Method getPriceMethod = clz.getMethod(\u0026#34;getPrice\u0026#34;); System.out.println(\u0026#34;Apple Price:\u0026#34; + getPriceMethod.invoke(appleObj)); } } 从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：\nApple Price:5 Apple Price:14 从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：\n 获取类的 Class 对象实例  Class clz = Class.forName(\u0026quot;com.zhenai.api.Apple\u0026quot;);  根据 Class 对象实例获取 Constructor 对象  Constructor appleConstructor = clz.getConstructor();  使用 Constructor 对象的 newInstance 方法获取反射类对象  Object appleObj = appleConstructor.newInstance(); 而如果要调用某一个方法，则需要经过下面的步骤：\n 获取方法的 Method 对象  Method setPriceMethod = clz.getMethod(\u0026quot;setPrice\u0026quot;, int.class);  利用 invoke 方法调用方法  setPriceMethod.invoke(appleObj, 14); 为什么引入反射概念？反射机制的应用有哪些？ 我们来看一下 Oracle 官方文档中对反射的描述：\n从 Oracle 官方文档中可以看出，反射主要应用在以下几方面：\n 反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。 反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。 测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。  也就是说，Oracle 希望开发者将反射作为一个工具，用来帮助程序员实现本不可能实现的功能。\n举两个最常见使用反射的例子，来说明反射机制的强大之处：\n第一种：JDBC 的数据库的连接\n在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成\n 通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）； 通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码； 通过Connection 接口接收连接。  public class ConnectionJDBC { /** * @param args */ //驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中  public static final String DBDRIVER = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; //连接地址是由各个数据库生产商单独提供的，所以需要单独记住  public static final String DBURL = \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;; //连接数据库的用户名  public static final String DBUSER = \u0026#34;root\u0026#34;; //连接数据库的密码  public static final String DBPASS = \u0026#34;\u0026#34;; public static void main(String[] args) throws Exception { Connection con = null; //表示数据库的连接对象  Class.forName(DBDRIVER); //1、使用CLASS 类加载驱动程序 ,反射机制的体现  con = DriverManager.getConnection(DBURL,DBUSER,DBPASS); //2、连接数据库  System.out.println(con); con.close(); // 3、关闭数据库  } 第二种：Spring 框架的使用，最经典的就是xml的配置模式。\nSpring 通过 XML 配置模式装载 Bean 的过程：\n 将程序内所有 XML 或 Properties 配置文件加载入内存中； Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息； 使用反射机制，根据这个字符串获得某个类的Class实例； 动态配置实例的属性。  Spring这样做的好处是：\n 不用每一次都要在代码里面去new或者做其他的事情； 以后要改的话直接改配置文件，代码维护起来就很方便了； 有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。  模拟 Spring 加载 XML 配置文件：\npublic class BeanFactory { private Map\u0026lt;String, Object\u0026gt; beanMap = new HashMap\u0026lt;String, Object\u0026gt;(); /** * bean工厂的初始化. * @param xml xml配置文件 */ public void init(String xml) { try { //读取指定的配置文件  SAXReader reader = new SAXReader(); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); //从class目录下获取指定的xml文件  InputStream ins = classLoader.getResourceAsStream(xml); Document doc = reader.read(ins); Element root = doc.getRootElement(); Element foo; //遍历bean  for (Iterator i = root.elementIterator(\u0026#34;bean\u0026#34;); i.hasNext();) { foo = (Element) i.next(); //获取bean的属性id和class  Attribute id = foo.attribute(\u0026#34;id\u0026#34;); Attribute cls = foo.attribute(\u0026#34;class\u0026#34;); //利用Java反射机制，通过class的名称获取Class对象  Class bean = Class.forName(cls.getText()); //获取对应class的信息  java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(bean); //获取其属性描述  java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); //设置值的方法  Method mSet = null; //创建一个对象  Object obj = bean.newInstance(); //遍历该bean的property属性  for (Iterator ite = foo.elementIterator(\u0026#34;property\u0026#34;); ite.hasNext();) { Element foo2 = (Element) ite.next(); //获取该property的name属性  Attribute name = foo2.attribute(\u0026#34;name\u0026#34;); String value = null; //获取该property的子元素value的值  for(Iterator ite1 = foo2.elementIterator(\u0026#34;value\u0026#34;); ite1.hasNext();) { Element node = (Element) ite1.next(); value = node.getText(); break; } for (int k = 0; k \u0026lt; pd.length; k++) { if (pd[k].getName().equalsIgnoreCase(name.getText())) { mSet = pd[k].getWriteMethod(); //利用Java的反射极致调用对象的某个set方法，并将值设置进去  mSet.invoke(obj, value); } } } //将对象放入beanMap中，其中key为id值，value为对象  beanMap.put(id.getText(), obj); } } catch (Exception e) { System.out.println(e.toString()); } } //other codes } 反射机制的原理是什么？ Class actionClass=Class.forName(“MyClass”); Object action=actionClass.newInstance(); Method method = actionClass.getMethod(“myMethod”,null); method.invoke(action,null); 上面就是最常见的反射使用的例子，前两行实现了类的装载、链接和初始化（newInstance方法实际上也是使用反射调用了方法），后两行实现了从class对象中获取到method对象然后执行反射调用。\n因反射原理较复杂，下面简要描述下流程，想要详细了解的小伙伴，可以看这篇文章：https://www.cnblogs.com/yougewe/p/10125073.html\n 反射获取类实例 Class.forName()，并没有将实现留给了java,而是交给了jvm去加载！主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader。最后，jvm又会回调 ClassLoader 进类加载！ newInstance() 主要做了三件事：   权限检测，如果不通过直接抛出异常； 查找无参构造器，并将其缓存起来； 调用具体方法的无参构造方法，生成实例并返回。   获取Method对象，\n  上面的Class对象是在加载类时由JVM构造的，JVM为每个类管理一个独一无二的Class对象，这份Class对象里维护着该类的所有Method，Field，Constructor的cache，这份cache也可以被称作根对象。\n每次getMethod获取到的Method对象都持有对根对象的引用，因为一些重量级的Method的成员变量（主要是MethodAccessor），我们不希望每次创建Method对象都要重新初始化，于是所有代表同一个方法的Method对象都共享着根对象的MethodAccessor，每一次创建都会调用根对象的copy方法复制一份：\nMethod copy() { Method res = new Method(clazz, name, parameterTypes, returnType, exceptionTypes, modifiers, slot, signature, annotations, parameterAnnotations, annotationDefault); res.root = this; res.methodAccessor = methodAccessor; return res; }  调用invoke()方法。调用invoke方法的流程如下：\n  调用Method.invoke之后，会直接去调MethodAccessor.invoke。MethodAccessor就是上面提到的所有同名method共享的一个实例，由ReflectionFactory创建。\n创建机制采用了一种名为inflation的方式（JDK1.4之后）：如果该方法的累计调用次数\u0026lt;=15，会创建出NativeMethodAccessorImpl，它的实现就是直接调用native方法实现反射；如果该方法的累计调用次数\u0026gt;15，会由java代码创建出字节码组装而成的MethodAccessorImpl。（是否采用inflation和15这个数字都可以在jvm参数中调整） 以调用MyClass.myMethod(String s)为例，生成出的MethodAccessorImpl字节码翻译成Java代码大致如下：\npublic class GeneratedMethodAccessor1 extends MethodAccessorImpl { public Object invoke(Object obj, Object[] args) throws Exception { try { MyClass target = (MyClass) obj; String arg0 = (String) args[0]; target.myMethod(arg0); } catch (Throwable t) { throw new InvocationTargetException(t); } } } 泛型 Java中的泛型是什么 ? 泛型是 JDK1.5 的一个新特性，**泛型就是将类型参数化，其在编译时才确定具体的参数。**这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。\n使用泛型的好处是什么? 远在 JDK 1.4 版本的时候，那时候是没有泛型的概念的，如果使用 Object 来实现通用、不同类型的处理，有这么两个缺点：\n 每次使用时都需要强制转换成想要的类型 在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全。  如这个例子：\nList list = new ArrayList(); list.add(\u0026#34;www.cnblogs.com\u0026#34;); list.add(23); String name = (String)list.get(0); String number = (String)list.get(1);\t//ClassCastException 上面的代码在运行时会发生强制类型转换异常。这是因为我们在存入的时候，第二个是一个 Integer 类型，但是取出来的时候却将其强制转换为 String 类型了。Sun 公司为了使 Java 语言更加安全，减少运行时异常的发生。于是在 JDK 1.5 之后推出了泛型的概念。\n根据《Java 编程思想》中的描述，泛型出现的动机在于：有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。\n使用泛型的好处有以下几点：\n  类型安全\n 泛型的主要目标是提高 Java 程序的类型安全 编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常 符合越早出错代价越小原则    消除强制类型转换\n 泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换 所得即所需，这使得代码更加可读，并且减少了出错机会    潜在的性能收益\n 由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改 所有工作都在编译器中完成 编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已    Java泛型的原理是什么 ? 什么是类型擦除 ? 泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：**泛型只存在于编译阶段，而不存在于运行阶段。**在编译后的 class 文件中，是没有泛型这个概念的。\n类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。\n例如：\npublic class Caculate\u0026lt;T\u0026gt; { private T num; } 　我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。反编译一下这个 Caculate 类：\npublic class Caculate{ public Caculate(){} private Object num; } 　发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。\n　那么是不是所有的泛型类型都以 Object 进行擦除呢？大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：\npublic class Caculate\u0026lt;T extends String\u0026gt; { private T num; } 　这种情况的泛型类型，num 会被替换为 String 而不再是 Object。这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。\n　实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。\n　实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换。这一个过程就叫做『泛型翻译』。\n什么是泛型中的限定通配符和非限定通配符 ? 限定通配符对类型进行了限制。有两种限定通配符，一种是\u0026lt;? extends T\u0026gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是\u0026lt;? super T\u0026gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。\n非限定通配符 ？,可以用任意类型来替代。如List\u0026lt;?\u0026gt; 的意思是这个集合是一个可以持有任意类型的集合，它可以是List\u0026lt;A\u0026gt;，也可以是List\u0026lt;B\u0026gt;,或者List\u0026lt;C\u0026gt;等等。\nList\u0026lt;? extends T\u0026gt;和List \u0026lt;? super T\u0026gt;之间有什么区别 ? 这两个List的声明都是限定通配符的例子，List\u0026lt;? extends T\u0026gt;可以接受任何继承自T的类型的List，而List\u0026lt;? super T\u0026gt;可以接受任何T的父类构成的List。例如List\u0026lt;? extends Number\u0026gt;可以接受List或List。\n可以把List\u0026lt;String\u0026gt;传递给一个接受List\u0026lt;Object\u0026gt;参数的方法吗？ 不可以。真这样做的话会导致编译错误。因为List可以存储任何类型的对象包括String, Integer等等，而List却只能用来存储String。　List\u0026lt;Object\u0026gt; objectList; List\u0026lt;String\u0026gt; stringList; objectList = stringList; //compilation error incompatible types Array中可以用泛型吗? 不可以。这也是为什么 Joshua Bloch 在 《Effective Java》一书中建议使用 List 来代替 Array，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。\n判断ArrayList\u0026lt;String\u0026gt;与ArrayList\u0026lt;Integer\u0026gt;是否相等？ ArrayList\u0026lt;String\u0026gt; a = new ArrayList\u0026lt;String\u0026gt;(); ArrayList\u0026lt;Integer\u0026gt; b = new ArrayList\u0026lt;Integer\u0026gt;(); Class c1 = a.getClass(); Class c2 = b.getClass(); System.out.println(c1 == c2); 输出的结果是 true。因为无论对于 ArrayList 还是 ArrayList，它们的 Class 类型都是一直的，都是 ArrayList.class。\n那它们声明时指定的 String 和 Integer 到底体现在哪里呢？\n**答案是体现在类编译的时候。**当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String 类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。\n序列化 Java序列化与反序列化是什么？ Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：\n  **序列化：**序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。\n而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。\n  **反序列化：**客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。\n  为什么需要序列化与反序列化？ 简要描述：对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化\n深入描述：\n 对象序列化可以实现分布式对象。  主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。\njava对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。  可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的\u0026quot;深复制\u0026rdquo;，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。\n序列化可以将内存中的类写入文件或数据库中。  比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。\n总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。\n对象、文件、数据，有许多不同的格式，很难统一传输和保存。  序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。\n序列化实现的方式有哪些？ 实现Serializable接口或者Externalizable接口。\nSerializable接口 类通过实现 java.io.Serializable 接口以启用其序列化功能。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。\n如以下例子：\nimport java.io.Serializable; public class User implements Serializable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;}\u0026#39;; } } 通过下面的代码进行序列化及反序列化：\npublic class SerializableDemo { public static void main(String[] args) { //Initializes The Object  User user = new User(); user.setName(\u0026#34;cosen\u0026#34;); System.out.println(user); //Write Obj to File  try (FileOutputStream fos = new FileOutputStream(\u0026#34;tempFile\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream( fos)) { oos.writeObject(user); } catch (IOException e) { e.printStackTrace(); } //Read Obj from File  File file = new File(\u0026#34;tempFile\u0026#34;); try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) { User newUser = (User)ois.readObject(); System.out.println(newUser); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } //OutPut: //User{name=\u0026#39;cosen\u0026#39;} //User{name=\u0026#39;cosen\u0026#39;} Externalizable接口 Externalizable继承自Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。\n当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。否则所有变量的值都会变成默认值。\npublic class User implements Externalizable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(name); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { name = (String) in.readObject(); } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;}\u0026#39;; } } 通过下面的代码进行序列化及反序列化：\npublic class ExternalizableDemo1 { public static void main(String[] args) { //Write Obj to file  User user = new User(); user.setName(\u0026#34;cosen\u0026#34;); try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;tempFile\u0026#34;))){ oos.writeObject(user); } catch (IOException e) { e.printStackTrace(); } //Read Obj from file  File file = new File(\u0026#34;tempFile\u0026#34;); try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))){ User newInstance = (User) ois.readObject(); //output  System.out.println(newInstance); } catch (IOException | ClassNotFoundException e ) { e.printStackTrace(); } } } //OutPut: //User{name=\u0026#39;cosen\u0026#39;} 两种序列化的对比    实现Serializable接口 实现Externalizable接口     系统自动存储必要的信息 程序员决定存储哪些信息   Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持 必须实现接口内的两个方法   性能略差 性能略好    什么是serialVersionUID？ serialVersionUID 用来表明类的不同版本间的兼容性\nJava的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。\n为什么还要显示指定serialVersionUID的值? 如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID, 然后与属性一起序列化, 再进行持久化或网络传输. 在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID, 然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较, 如果相同则反序列化成功, 否则报错.\n如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.\n在实际开发中, 不显示指定serialVersionUID的情况会导致什么问题? 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, 一旦类被修改了, 那旧对象反序列化就会报错. 所以在实际开发中, 我们都会显示指定一个serialVersionUID, 值是多少无所谓, 只要不变就行。\nserialVersionUID什么时候修改？ 《阿里巴巴Java开发手册》中有以下规定：\n想要深入了解的小伙伴，可以看这篇文章：https://juejin.cn/post/6844903746682486791\nJava 序列化中如果有些字段不想进行序列化，怎么办？ 对于不想进行序列化的变量，使用 transient 关键字修饰。\ntransient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量，不能修饰类和方法。\n静态变量会被序列化吗? 不会。因为序列化是针对对象而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化.\n看到这个结论, 是不是有人会问, serialVersionUID也被static修饰, 为什么serialVersionUID会被序列化? 其实serialVersionUID属性并没有被序列化, JVM在序列化对象时会自动生成一个serialVersionUID, 然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。\n异常 Error 和 Exception 区别是什么？ Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。\nException 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。\n Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。Exception 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。 Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。  非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？ 非受检查异常：包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如：NullPointException(空指针)、NumberFormatException（字符串转换为数字）、IndexOutOfBoundsException(数组越界)、ClassCastException(类转换异常)、ArrayStoreException(数据存储异常，操作数组时类型不一致)等。\n受检查异常：是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException等。\n非受检查异常和受检查异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。\nthrow 和 throws 的区别是什么？ Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。\nthrows 关键字和 throw 关键字在使用上的几点区别如下：\n throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。  举例如下：\nthrow 关键字：\npublic static void main(String[] args) { String s = \u0026#34;abc\u0026#34;; if(s.equals(\u0026#34;abc\u0026#34;)) { throw new NumberFormatException(); } else { System.out.println(s); } //function(); } throws 关键字：\npublic static void function() throws NumberFormatException{ String s = \u0026#34;abc\u0026#34;; System.out.println(Double.parseDouble(s)); } public static void main(String[] args) { try { function(); } catch (NumberFormatException e) { System.err.println(\u0026#34;非数据类型不能转换。\u0026#34;); //e.printStackTrace(); \t} } NoClassDefFoundError 和 ClassNotFoundException 区别？ NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致。\nClassNotFoundException 是一个受检查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。\nJava常见异常有哪些？  java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。 java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。 java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。  try-catch-finally 中哪个部分可以省略？ catch 可以省略。更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。\n理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。\n至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。\ntry-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ 会执行，在 return 前执行。\n在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。 代码示例1：\npublic static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; } return a; } //执行结果：30 代码示例2：\npublic static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; } finally { a = 40; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40  return a; } } // 执行结果：40 JVM 是如何处理异常的？ 在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。\nJVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 想要深入了解的小伙伴可以看这篇文章：https://www.cnblogs.com/qdhxhz/p/10765839.html\nIO Java的IO 流分为几种？  按照流的方向：输入流（inputStream）和输出流（outputStream）； 按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）； 按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。  字节流如何转为字符流？ 字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。\n字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。\n字符流与字节流的区别？  读写的时候字节流是按字节读写，字符流按字符读写。 字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。 在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 只是读写文件，和文件内容无关时，一般选择字节流。  BIO、NIO、AIO的区别？  BIO：同步并阻塞，在服务器中实现的模式为一个连接一个线程。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO一般适用于连接数目小且固定的架构，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。 NIO：同步并非阻塞，在服务器中实现的模式为一个请求一个线程，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。 AIO：异步并非阻塞，在服务器中实现的模式为一个有效请求一个线程，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。  Java IO都有哪些设计模式？ 使用了适配器模式和装饰器模式\n适配器模式：\nReader reader = new INputStreamReader(inputStream); 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作\n 类适配器：Adapter类（适配器）继承Adaptee类（源角色）实现Target接口（目标角色） 对象适配器：Adapter类（适配器）持有Adaptee类（源角色）对象实例，实现Target接口（目标角色）   装饰器模式：\nnew BufferedInputStream(new FileInputStream(inputStream)); 一种动态地往一个类中添加新的行为的设计模式。就功能而言，装饰器模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。\n ConcreteComponent（具体对象）和Decorator（抽象装饰器）实现相同的Conponent（接口）并且Decorator（抽象装饰器）里面持有Conponent（接口）对象，可以传递请求。 ConcreteComponent（具体装饰器）覆盖Decorator（抽象装饰器）的方法并用super进行调用，传递请求。  参考 https://juejin.cn/post/6844903741032759310\nhttps://blog.csdn.net/chenliguan/article/details/53888018\nhttps://segmentfault.com/a/1190000010162647\nhttps://juejin.cn/post/6856664924203663367\nhttp://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/\nhttps://www.cnblogs.com/lixuwu/p/10829368.html\nhttps://juejin.cn/post/6844903848167866375\nhttps://blog.csdn.net/lanzhupi/article/details/109809836\nhttps://juejin.cn/post/6844903746682486791\nhttps://blog.csdn.net/ThinkWon/article/details/101681073\nhttps://simplesnippets.tech/exception-handling-in-java-part-1/\nhttps://www.cnblogs.com/xingyunblog/p/8688859.html\nhttps://mp.weixin.qq.com/s/p5qM2UJ1uIWyongfVpRbCg\nhttps://juejin.cn/post/6844903520856965128\n","date":"2020-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8B/","title":"Java基础面试题下"},{"content":"List list = new ArrayList();与ArrayList list = new ArrayList()\n​\tList是一个接口，而ArrayList是一个类ArrayList继承并实现了List。\n​\tList list = new ArrayList();这句话创建了一个ArrayList的对象后上溯到了List。此时它是一个List对象了，有一些ArrayList有但是List没有的属性和方法，它就不能再用了。而ArrayList alist = new ArrayList();创建了一对象则保留了ArrayList的所有属性。\n为什么一般都使用List list= new ArrayList()，而不是后者呢\n​\t问题在于List有多个实现类，如常用的LinkedList或者Vector等等，现在你用的是ArrayList，也许哪一天你需要换成其他的实现类的时候，你只需要改变：List list = new ArrayList()；这一行就可以了，其他使用了List接口的代码根本不需要改动。\n​\t假如你开始使用了ArrayList alist = new ArrayList()；你要换成其他实现类的时候，你需要把全部实现了ArrayList的代码模块都进行修改，尤其是使用了ArrayList特有的方法和属性时！\n​\t所以如果没有特别需求的话，最好使用List list = newArrayList()；这样可以便于程序代码的重构，这就是面向接口编程的好处。\n","date":"2020-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%B8%80/","title":"Java编程思想集合篇（一）"},{"content":"Java基础语法   注释、标识符、关键字 数据类型 类型转换 变量常量 运算符 包机制、JavaDoc   注释、标识符、关键字 1.注释（注释不会被执行）\n 单行注释：用\u0026quot;//\u0026ldquo;表示 多行注释：”/* */“表示 JavaDoc文档注释：用/** */表示  2.标识符\n 标识符以字母、美元符($)、下划线(_)开头 首字符之后可以是字母、美元符($)、下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或方法名 标识符是大小写敏感的 String不是关键字，是一个类  Java数据类型   整数类型\n Byte占1个字节范围-128-127 short占2个字节范围 int占四个字节范围 long占8个字节范围（Long类型要在数字后面加个L）    浮点类型\n float占4个字节范围（float类型要在数字后面加个F） double占8个字节    字符类型：char占2个字节\n  Boolean类型：占一位 其真值只有true和Flase两个\n  浮点数拓展\nfloat a1 = 0.1f;//0.1  double a2 = 1.0/10;//0.1  System.out.println(a1==a2);//此处输出为false  System.out.println(a1); System.out.println(a2); float a3 = 2121213121212f; float a4 = a3+1; System.out.println(a3==a4);//此处输出为true 因为float的有限性、离散性、舍入误差，所以以上代码比较结果如下\n    避免使用浮点数进行比较\n  字符拓展\n//字符拓展  char a1 = \u0026#39;a\u0026#39;; char a2 = \u0026#39;中\u0026#39;; System.out.println(a1); System.out.println((int)a1);//强制转换  System.out.println(a2); System.out.println((int)a2);//强制转换   输出结果为\n  所有字符的本质都是数字，所有所有字符都有对应的Unicode编码\n  Unicode的编码方式：\nchar a3 = \u0026#39;\\u0061\u0026#39;; System.out.println(a3);   类型转换   Java是强类型转换语言，所以在进行运算时，需要把不同类型的数据转换成同一类型再进行运算\n  类型优先级\n  int i = 128; double d = i;//自动转换  byte b = (byte)i;//强制转换，注意数据溢出  System.out.println(i); System.out.println(d); System.out.println(b); /** * 注意点： * 不能对布尔型进行转换 * 不能把对象类型转换为不相干的类型 * 在把高容量转换成低容量的时候，强制转换 * 转换的时候可能存在内存1溢出，或者是精度问题*/ 输出结果：\n! 因为Byte类型取值范围为-128-127所以数据溢出了。 \u0026ldquo;强制转换\u0026quot;时需要注意数据溢出； 转换方式: (类型)变量名 优先级高\u0026ndash;低时使用 自动转换：优先级低\u0026ndash;高时自动使用  数据溢出问题：\n//操作比较大的数据时 注意溢出问题  //JDK7新特性 数字之间可以用下划线_分割  int money = 10_0000_0000;//新特性  int years = 20; int total1 = money*years;//-1474836480,计算的时候已经溢出  System.out.println(money); System.out.println(years); System.out.println(total1); long total2 = money*years;//先计算再赋值，所以数据转换前已经溢出了  System.out.println(total2); long total3 = money*((long)years);//先把一个数转换成long 计算后的结果的类型即为long类型  System.out.println(total3); 输出结果：\n变量、常量、作用域   类变量\n  静态代码块（static）\n 静态代码块只会被执行一次 静态类可以被局部对象调用 静态变量可以被执行多次  public class demo5 { static int i=1; static { System.out.println(\u0026#34;a\u0026#34;); i++; } public demo5(){ System.out.println(\u0026#34;b\u0026#34;); i++; } //在此之前i已被调用两次，i的值为2  public static void main(String[] args) { demo5 d1 = new demo5();//i在次被调用，i+1，此时i=3  System.out.println(d1.i); demo5 d2 = new demo5();//i在次被调用，i+1，此时i=4  System.out.println(d2.i); } } 输出结果：\n  实例变量：从属于对象，如果不自动化初始化，这个类型的默认值为0/0.0\n  布尔值：默认是false\n  除了基本类型，其余的默认值都是null；\n    常量\n 常量定义通过final实现 一般使用大写字母表示 修饰符不存在先后顺序    变量命名规则\n  基本运算符  Java语言支持如下运算符    当java进行除法运算时，需要进行类型强转换\npackage JavaSEbase; public class demo6 { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b);//结果为0.5  System.out.println(a/(double)b); } } 显然加了强转double的表达式输出了正确的结果\n  在整数的运算过程中，有long类型则结果为long类型，其余都为int类型\npackage JavaSEbase; public class demo7 { public static void main(String[] args) { long a = 123132132132132L; int b = 123; short c = 10; byte d =8; System.out.println(a+b+c+d);//long  System.out.println(b+c+d);//int  System.out.println(c+d);//int  } }   一元运算符：自增与自减\npackage JavaSEbase; public class demo8 { public static void main(String[] args) { int a = 3; int b = a++;//先把a赋值给b再自增  //a=a+1  System.out.println(a);//此时a=4  //a=a+1  int c = ++a;//先自增再把a赋值给c  System.out.println(a);//此时a=5  System.out.println(b); System.out.println(c); } }   逻辑运算符\n  逻辑与\u0026amp;\u0026amp;：有假就假，全真才真\n  逻辑或||：有真就真，全假才假\n  逻辑与的短路运算\npackage JavaSEbase; public class demo9 { public static void main(String[] args) { //短路运算：即使用逻辑与运算时，假设前面的值为假，则运算符后面的运算不会执行  int c = 5; boolean d = (c\u0026lt;4)\u0026amp;\u0026amp;(c++\u0026lt;4);//因为c\u0026lt;4为假，所以后面c++不会被执行  System.out.println(d); System.out.println(c); } }     位运算：针对二进制数据进行的运算\n \u0026amp;：同位比较，全1才1，有0则0 |：同位比较，全0才0，有1则1 ^：同位比较，相同为0，不同位1 ~：取反符号。  package JavaSEbase; public class demo10 { public static void main(String[] args) { /* * A = 0011 1100 * B = 0000 1101 * ----------------------- * A\u0026amp;B = 0000 1100 * A|B = 0011 1101 * A^B = 0011 0001 * ~B = 1111 0010 * ----------------------- * */ } }   三元运算符\npackage JavaSEbase; public class demo11 { public static void main(String[] args) { //x ? y : z  //如果x为真，则结果为y，否则结果为z  int score = 50; String type = score \u0026lt; 60 ? \u0026#34;不及格\u0026#34;:\u0026#34;及格\u0026#34;; } }   +号运算符的特殊之处（运算符）\npackage JavaSEbase; public class demo10 { public static void main(String[] args) { int a = 10; int b = 20; a+=b;//相当于a = a+b  a-=b;//相当于a = a-b  System.out.println(a); //当+号前面有String 则自动把后面的运算也转换成String、  System.out.println(\u0026#34;\u0026#34;+a+b); System.out.println(a+b+\u0026#34;\u0026#34;); } }   包机制  命名规范  JavaDoc  https://blog.csdn.net/vbirdbest/article/details/80296136  ","date":"2020-03-28T16:22:25+08:00","image":"https://minster77.github.io/cover.jpg","permalink":"https://minster77.github.io/p/javase01/","title":"JavaSE01"},{"content":"JVM   概述 ​\t对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要想C/C++程序开发程序员那样为每一个new操作去写对于的delete/free操作，不容易出现内存泄漏和内存溢出问题。正是因为Java程序员把内存控制权力交给Java虚拟机，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那么排查错误将是一个非常艰巨的任务。\n运行时数据区域 Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK1.8和之前的版本若有不同。\nJDK1.8之前：\nJDK1.8：\n JDK1.8把线程共享的内存中的方法区移到了本地内存，变成了元空间\n 线程是共享的：\n **方法区：**存储虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态常量，即时编译后的代码等数据，也可能会抛出OutOfMemoryError异常。 **堆：**java虚拟机最大的内存区域，存放对象实例，也是垃圾收集器管理的主要区域，分为新生代（由Eden 与Survivor Space 组成）和老生代，可能会抛出OutOfMemoryError异常 直接内存（非运行时数据区的一部分）：jdk1.4中增加了NIO，可以分配堆外内存（系统内存替代用户内存），提高了性能。  线程是私有的：\n 程序计数器：程序计数器(处于线程独)占区是一个非常小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器 **虚拟机栈：**虚拟机栈描述的是Java方法执行的动态内存模型 **本地方法栈：**本地方法栈为虚拟机执行native方法服务  程序计数器 ​\t程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时可以通过改变这个程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成\n​\t另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有“的内存\n通过上面的介绍，我们可以知道程序计数器的两个作用：\n 字节码编译器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现了对程序流程的控制。如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了。  注意：程序计数器是唯一一个不会出现OutOfMemoryError（内存溢出异常）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\nJava虚拟机栈 ​\t与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描写的是Java方法执行的内存模型，每次方法调用数据都是通过栈传递的。\n​\tJava内存可以粗糙的分为堆内存和栈内存，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\n**栈帧：**每个方法执行时都要创建一个栈帧，方法执行完毕，栈帧销毁。栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等。\n局部变量表：局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），局部变量表的大小在编译期便已经可以确定，在运行时期不会发生改变。\nJava 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。\n StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常  Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。\n扩展：那么方法/函数如何调用？\nJava 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。\nJava 方法有两种返回方式：\n return 语句。 抛出异常。  不管哪种返回方式都会导致栈帧被弹出。\n本地方法栈 ​\t和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n​\t本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n​\t方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\n堆 ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""},{"content":"MyBatis(一) MyBatis概括   什么是MyBatis\n MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3    什么是持久化\n持久化就是将程序数据在持久状态和瞬时状态间转化的机制。\n 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。    为什么需要持久化服务呢？\n那是由于内存本身的缺陷引起的\n 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。    什么是持久层？\n持久层：完成持久化工作的代码块 . \u0026mdash;-\u0026gt; dao层 【DAO (Data Access Object) 数据访问对象】\n 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过**这里有一个字需要特别强调，也就是所谓的“层”。**对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】    为什么需要Mybatis\n  Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .\n  传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等\u0026hellip; , 通过框架可以减少重复代码,提高开发效率 .\n  MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) \u0026ndash;\u0026gt;对象关系映射\n  所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别\n  MyBatis的优点\n   简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。      第一个MyBatis程序   示例代码\n  搭建实验数据库\nCREATEDATABASE`mybatis`;USE`mybatis`;DROPTABLEIFEXISTS`user`;CREATETABLE`user`(`id`int(20)NOTNULL,`name`varchar(30)DEFAULTNULL,`pwd`varchar(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=utf8;insertinto`user`(`id`,`name`,`pwd`)values(1,\u0026#39;狂神\u0026#39;,\u0026#39;123456\u0026#39;),(2,\u0026#39;张三\u0026#39;,\u0026#39;abcdef\u0026#39;),(3,\u0026#39;李四\u0026#39;,\u0026#39;987654\u0026#39;);  导入MyBatis相关jar包\n\u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写MyBatis核心配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;777777\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/heng/dao/Mapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 注意\u0026lt;mapper resource=\u0026quot;com/heng/dao/Mapper.xml\u0026quot;/\u0026gt;的路径\n  编写MyBatis的工具类\npackage com.heng.utils; import org.apache.ibatis.session.Configuration; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; /** * @Author: minster * @Date: 2021/10/26 10:24 */ //SqlSessionFactory 工厂--生产-\u0026gt;产品 SqlSession，即该方法可以用来生成sqlSession public class MybatisUtils { public static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取sqlSessionFactory对象（建议使用类路径下的资源文件配置）  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了sqlSessionFactory,顾名思义，我们就可以从中获得sqlSession的实例了  //SqlSession完全包含了面向数据库执行SQL命令所需的所有方法  public static SqlSession getSession(){ return sqlSessionFactory.openSession(); } } 什么是SqlSession？\n  简单理解SqlSession，就是一次操作数据库的会话过程，通过它可以与数据库进行交\n  使用Mybatis执行数据库操作，首先要获取SqlSession，通过它进一步获取Mapper接口代理对象，最后通过代理对象发起数据库操作\n  通过构建DataSource、TransactionFactory、Environment、Configuration并将它们组装在一起获得SqlSessionFactory，此后就可以通过它获取SqlSession\n  从try-with-resource里的openSession方法，在这里可以看到获取SqlSession时Mybatis会创建事务工厂TransactionFactory、执行器Executor结合在启动Mybatis时创建的Configuration返回一个DefaultSqlSession\n  其中Mybatis利用执行器Executor执行数据库操作。\n  Mybatis获取SqlSession的过程结束，通过它为当前的数据库操作创建一个专属的执行器Executor和事务工厂TransactionFactory，令当前线程的数据库操作处于一个会话状态\n https://www.jianshu.com/p/48dfeb0b79b6\n     创建实体类\npublic class User { private int id; //id  private String name; //姓名  private String pwd; //密码  //构造,有参,无参  //set/get  //toString()  }   编写Mapper接口类\npackage com.heng.dao; import com.heng.pojo.User; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:33 */ public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); }   编写Mapper.xml配置文件\n namespace非常重要！！不能写错\n \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace绑定一个对应的Dao/Mapper接口 --\u0026gt; \u0026lt;!-- 配置文件和UserMapper接口绑定起来了 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   编写测试类\nimport com.heng.dao.UserMapper; import com.heng.pojo.User; import com.heng.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:34 */ public class MyTest { 方法1 @Test public void selectUser1(){ SqlSession session = MybatisUtils.getSession(); List\u0026lt;User\u0026gt; users = session.selectList(\u0026#34;com.heng.dao.UserMapper.selectUser\u0026#34;); for (User user : users) { System.out.println(user); } session.close(); } //方法2  @Test public void selectUser2(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } } }   编译，测试，出现Maven静态资源过滤问题，在pom.xml文件上添加下面配置\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;     MyBatis核心对象 MyBatis 有三个基本要素：\n 核心接口和类 MyBatis核心配置文件（mybatis-config.xml） SQL映射文件（mapper.xml）  下面首先介绍 MyBatis 的核心接口和类，如下所示。\n每个 MyBatis 应用程序都以一个 SqlSessionFactory 对象的实例为核心。\n首先获取SqlSessionBuilder对象，可以根据XML配置文件或者Configuration类的实例构建该对象\n然后获取SqlSessionFactory对象，该对象实例可以通过SqlSessionBuilder对象来获取\n有了SqlSessionFactory对象后，就可以进而获取SqlSession实例。SqlSession对象中完全包含数据库为背景的所有执行SQL操作的方法，用该实例可以直接执行已映射的SQL语句。\n  SqlSessionFactoryBuidler\nSqlSessionFactoryBuidler会根据配置信息或者代码生成SqlSessionFactory，并且提供了多个build()方法重载，如图\n通过源码分析，可以发现以上方法都是在调用同一签名方法，即\npublic SqlSessionFactory build(Reader reader, String environment, Properties properties) { //... } 由于参数environment和properties都可以为null，所以我们可以去除重复的方法，真正的重载其实只有以下三种：\n build(InputStream inputStream, String environment, Properties properties) build(Reader reader, String environment, Properties properties) build(Configuration config)  通过以上分析，我们可以发现配置信息可以以三种形式给SqlSessionFactoryBuilder的build()方法，分别是InputStream(字节流)、Reader(字符流)、Configuration(类)。\n由于字节流和字符流都属于读取配置文件的方式，所以就很容易想到构建一个SqlSessionFactory有两种方式：即读取XML配置文件和编写代码。常用的是采取XML配置文件的方式来构造SqlSessionFactory，这样一方面可以避免硬编码，另一方面方便日后配置人员修改，避免重复编译代码\n  SqlSessionFactoryBuilder的生命周期和作用域\nSqlSessionFactoryBuilder的最大特点是用过即丢。创建SqlSessionFactory对象之后，这个类就不存在了，因此SqlSessionFactoryBuilder的最佳作用范围就是存在于方法体内，也就是局部变量\n观察下面代码便可理解\nstatic { try { //使用Mybatis第一步：获取sqlSessionFactory对象（建议使用类路径下的资源文件配置）  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } }   SqlSessionFactory SqlSessionFactory 是工厂接口而不是现实类，他的任务就是创建 SqlSession。\n所有的MyBatis应用都以SqlSessionFactory实例为中心，SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder对象来获取。有了它之后，顾名思义，就可以通过SqlSession提供的openSession()方法来获取SqlSession实例，源码如下：\npackage org.apache.ibatis.session; import java.sql.Connection; public interface SqlSessionFactory { SqlSession openSession(); SqlSession openSession(boolean var1); SqlSession openSession(Connection var1); SqlSession openSession(TransactionIsolationLevel var1); SqlSession openSession(ExecutorType var1); SqlSession openSession(ExecutorType var1, boolean var2); SqlSession openSession(ExecutorType var1, TransactionIsolationLevel var2); SqlSession openSession(ExecutorType var1, Connection var2); Configuration getConfiguration(); }   SqlSessionFactory的生命周期和作用域\nSqlSessionFactory对象一旦创建，就会在整个应用程序过程中始终存在。没有理由去销毁或再创建它，并且在应用程序运行中也不建议多次创建SqlSessionFactory。因此SqlSessionFactory的最佳作用域是Application，即随着应用程序的生命周期一直存在。这种“存在于整个应用运行期间，并且只有一个对象实例”的模式就是所谓的单例模式（指在运行期间有且仅有一个实例）\n  SqlSession\nSqlSession是用于执行持久化操作的对象，类似于JDBC中的Connection。它提供了面向数据库执行SQL命令所需要的的所有方法，可以通过SqlSession实例直接运行已映射的SQL语句。\nSqlSession的用途主要有两种：\n 获取映射器。让映射器通过命名空间和方法名称找到对应的SQL，并发送给数据库，执行返回结果。 直接通过“命名空间(namespace)+SQL id”的方式执行SQL，不需要获取映射器。这是iBatis版本留下的方式。例如《第一个MyBatis程序》一节的实例就是用这种方法执行的SQL语句。    SqlSession的生命周期和作用域\nSqlSession对应一次数据库会话。由于数据库会话不是永久的，因此SqlSession的生命周期也不是永久的，每次访问数据库时都需要创建SqlSession对象。\n需要注意的是：每个线程都有自己的SqlSession实例，SqlSession实例是不能被共享的，也不是线程安全的。因此SqlSession的作用域范围是request作用域或方法体作用域内。\n  MyBatis详细的执行流程\nMyBatis Mapper(映射器) 映射器是MyBatis中最重要的文件，文件包含一组SQL语句（例如查询、添加、删除、修改），这些语句称为映射语句或映射SQL语句。\n映射器由Java接口和XML文件（或注解）共同组成，它的作用如下：\n 定义参数类型 配置缓存 提供SQL语句和动态SQL 定义查询结果和POJO的映射关系1  映射器有一下两种实现方式：\n 通过XML文件方式实现，比如我们在mybatis-config.xml文件中描述的XML文件，可以用来生成mapper。 通过注解的方式实现，使用Configuration对象注册mapper接口  如果SQL语句存在动态SQL或者比较复杂，使用注解写在Java文件里可读性差，且增加了维护成本。所以一般建议使用XML文件配置的方式，可以避免重复编写SQL语句。\n  XML实现映射器\nXML定义映射器分为两个部分：接口和XML。下面定义接口UserMapper\npackage com.heng.dao; import com.heng.pojo.User; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:33 */ public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); } UserMapper.xml代码如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace绑定一个对应的Dao/Mapper接口 --\u0026gt; \u0026lt;!-- 配置文件和UserMapper接口绑定起来了 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.heng.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 下面对上述 XML 文件进行讲解。\n namespace 用来定义命名空间，该命名空间和定义接口的全限定名一致。 \u0026lt;select\u0026gt; 元素表明这是一条查询语句，属性 id 用来标识这条 SQL。resultType 表示返回的是一个 User类型的值。  在MyBatis配置文件中添加以下代码：\n\u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/heng/dao/userMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 该语句用来引入XML文件，MyBatis会读取userMapper.xml文件，生成映射器。\n  注解实现映射器\n使用注解的方式实现映射器，只需要在接口中使用Java注解，注入SQL即可。如下所示：\npackage com.heng.dao; import com.heng.pojo.User; import java.util.List; /** * @Author: minster * @Date: 2021/10/26 10:33 */ public interface UserMapper { @Select(value = \u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; selectUser(); } 这里我们使用了@Select注解，并且注入了和XML中相同的SQL语句。\n 如果同时使用了注解和XML文件两种方式实现映射器，那么XML方式将覆盖掉注解方式。\n 虽然XML看起来比注解复杂很多，但是现实中我们遇到的SQL会比上述例子的SQL语句复杂很多。如果SQL语句中有多个表的关联、多个查询条件、级联、条件分支等，显然这条SQL就会复杂很多，所以并不建议使用注解的这种方式实现。\n此外，XML 可以相互引入，而注解是不可以的，所以在一些比较复杂的场景下，使用 XML 方式会更加灵活和方便。因此大部分的企业都以 XML 为主，本教程也会保持一致，以 XML 方式来创建映射器。当然在一些简单的表和应用中使用注解方式也会比较简单。\n  MyBatis映射器的主要元素\n  mapper：映射文件的根节点，只有namescape一个属性。\nnamescape作用如下：\n 用于区分不同的 mapper，全局唯一 绑定DAO接口，即面向接口编程。当 namescape 绑定某一接口后，可以不用写该接口的实现类，MyBatis 会通过接口的完整限定名查找到对应的 mapper 配置来执行 SQL 语句。因此 namescape 的命名必须要跟接口同名。    select：查询语句，最常用、最复杂的元素之一。可以自定义参数，返回结果集等\n  insert：插入语句。执行后返回一个整数，代表插入的条数\n  update：更新语句。执行后返回一个整数，代表更新的条数\n  delete：删除语句。执行后返回一个整数，代表删除的条数\n  parameterMap：定义参数映射关系，即被删除的元素，不建议使用\n  sql：允许定义一部分的 SQL，然后在各个地方引用它\n  resultMap：用来描述数据库结果集与对象的对应关系，它是最复杂、最强大的元素\n  cache：配置给定命名空间的缓存\n  cache-ref：其他命名空间缓存配置的引用\n    MyBatis实现CURD   查询语句\n  elect标签是mybatis中最常用的标签之一\n  select语句有很多属性可以详细配置每一条SQL语句\n   SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id：对应的namespace的方法名 resultType：Sql语句执行的返回值 parameterType：参数类型！    需求：根据id查询用户\n  在userMapper中添加对应方法\npublic interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); User selectUserById(int id); }   在UserMapper.xml中添加Select语句\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt;   测试类测试\n@Test public void selectUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } }   需求：根据密码和名字查询用户\n方法一：直接在方法中传递参数\n  在接口方法的参数前加@Param属性\n  Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\nUserMapper接口增加方法\nUser selectUserByNP1(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); 在Mapper.xml配置文件增加查询语句\n\u0026lt;select id=\u0026#34;selectUserByNP1\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; 编写测试类\npublic void selectUserByNP01(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User jack = mapper.selectUserByNP1(\u0026#34;jack\u0026#34;, \u0026#34;123456\u0026#34;); System.out.println(jack); session.close(); } 测试，程序成功输出\n  方法二：使用万能的Map集合\n  实体类或数据库中的表字段或参数过多，应当考虑Map！（企业常用）\n  不需要知道用户表里有什么也能增删改查\n  Map传递参数，直接在SQL中取出key即可！\n在UserMapper接口中增加方法\nUser selectUserByNP2(Map\u0026lt;String, Object\u0026gt; map); 在Mapper.xml编写SQL语句时，需要传递参数类型，类型为map\n\u0026lt;select id=\u0026#34;selectUserByNP2\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; 编写测试代码时，只需要填写key为sql中取的值即可（即key对应sql语句的字段）\n@Test public void selectUserByNP02(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); map.put(\u0026#34;username\u0026#34;,\u0026#34;张三\u0026#34;); map.put(\u0026#34;pwd\u0026#34;,\u0026#34;abcdef\u0026#34;); User user = mapper.selectUserByNP2(map); System.out.println(user); session.close(); } 查询结果\n    增、删、改语句\n insert标签：进行插入操作 delete标签：进行删除操作 update标签：进行更新操作  代码实现增、删、改\n  编写接口方法\npublic interface UserMapper { int addUser(User user); int updateUser(User user); int deleteUser(int Id); }   在Mapper.xml编写SQL语句\n\u0026lt;!--增加一个用户--\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) value (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--修改用户信息--\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; update user set name = #{name},pwd = #{pwd} where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;!--删除一个用户--\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; delete from user where id = #{id} \u0026lt;/delete\u0026gt;   编写测试类\n增加一个用户\n@Test public void addUser(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User tom = new User(4, \u0026#34;tom\u0026#34;, \u0026#34;777777\u0026#34;); int i = mapper.addUser(tom); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } session.commit(); session.close(); } 修改一个用户的信息\n@Test public void updateUser(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User mary = new User(4, \u0026#34;mary\u0026#34;, \u0026#34;777776\u0026#34;); int i = mapper.updateUser(mary); User user = mapper.selectUserById(4); System.out.println(user); session.commit(); session.close(); } 删除一个用户\n@Test public void deleteUser(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(4); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user : users) { System.out.println(user); } session.commit(); session.close(); }   切记：进行增删改操作时，一定要提交事务session.commit();\n如果把工具类MybatisUtils的openSession()的参数设置为true，程序会自动提交事务！\npublic static SqlSession getSession(){ return sqlSessionFactory.openSession(true); }   小结：\n 所有增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map集合传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType参数都写上！    模糊查询like语句该怎么写？\n  第一种：在Java代码中添加SQL通配符。\n//UserMapper接口增加方法 List\u0026lt;User\u0026gt; selectLikeByName(@Param(\u0026#34;username\u0026#34;) String username); //测试方法 @Test public void selectLikeByName(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); //增加SQL通配符  List\u0026lt;User\u0026gt; user = mapper.selectLikeByName(\u0026#34;%a%\u0026#34;); System.out.println(user); session.close(); } xml文件\n\u0026lt;select id=\u0026#34;selectLikeByName\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name like #{username} \u0026lt;/select\u0026gt;   第二种：在sql语句中拼接通配符（不建议使用，会引起SQL注入问题！）\n\u0026lt;select id=\u0026#34;selectLikeByName\u0026#34; resultType=\u0026#34;com.heng.pojo.User\u0026#34;\u0026gt; select * from user where name like \u0026#34;%\u0026#34;#{username}\u0026#34;%\u0026#34; \u0026lt;/select\u0026gt;     MyBatis核心配置文件解析   mybatis-config.xml 系统核心配置文件\n  MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n  能配置的内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt;\u0026lt;!-- 配置 --\u0026gt; \u0026lt;properties /\u0026gt;\u0026lt;!-- 属性 --\u0026gt; \u0026lt;settings /\u0026gt;\u0026lt;!-- 设置 --\u0026gt; \u0026lt;typeAliases /\u0026gt;\u0026lt;!-- 类型命名 --\u0026gt; \u0026lt;typeHandlers /\u0026gt;\u0026lt;!-- 类型处理器 --\u0026gt; \u0026lt;objectFactory /\u0026gt;\u0026lt;!-- 对象工厂 --\u0026gt; \u0026lt;plugins /\u0026gt;\u0026lt;!-- 插件 --\u0026gt; \u0026lt;environments\u0026gt;\u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment\u0026gt;\u0026lt;!-- 环境变量 --\u0026gt; \u0026lt;transactionManager /\u0026gt;\u0026lt;!-- 事务管理器 --\u0026gt; \u0026lt;dataSource /\u0026gt;\u0026lt;!-- 数据源 --\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;databaseIdProvider /\u0026gt;\u0026lt;!-- 数据库厂商标识 --\u0026gt; \u0026lt;mappers /\u0026gt;\u0026lt;!-- 映射器 --\u0026gt; \u0026lt;/configuration\u0026gt; ​\t我们可以阅读 mybatis-config.xml 上面的dtd的头文件！\n  environments标签\n\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;...\u0026#34; value=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; 在 environments 标签中，可以配置 MyBatis 的多套运行环境，将 SQL 映射到多个不同的数据库上。\nenvironment 是 environments 的子标签，用来配置 MyBatis 的一套运行环境，需指定运行环境 ID、事务管理、数据源配置等相关信息。\n我们可以通过配置多个 environment 标签来连接多个数据库，需要注意的是必须指定其中一个为默认运行环境（通过default指定）。\nenvironment 标签提供了两个子标签，即 transactionManager 和 dataSource。\n  transactionManager标签\nMyBatis 支持两个事务管理器，即 JDBC 和 MANAGED。\n如果使用 JDBC 类型的事务管理器，则应用程序服务器负责事务管理操作，例如提交、回滚等。如果使用 MANAGED 类型的事务管理器，则应用程序服务器负责管理连接生命周期。\n  dataSource标签\n用于配置数据库的连接属性，例如要连接的数据库的驱动程序名称、URL、用户名和密码等。\ndataSource 中的 type 属性用于指定数据源类型，有以下 3 种类型。\n\u0026lt;dataSource type = \u0026#34;[UNPOOLED|POOLED|JNDI]\u0026#34;\u0026gt;\u0026lt;/dataSource\u0026gt;   UNPOOLED\nUNPOOLED 没有数据库连接池，效率低下。MyBatis 需要打开和关闭每个数据库操作的连接，它有点慢，通常应用于简单的应用程序。\n  POOLED\n对于 POOLED 数据源类型，MyBatis 将维护一个数据库连接池。并且对于每个数据库的操作，MyBatis 都会使用连接池中的连接，并在操作完成后将它们返回到池中。减少了创建新连接所需的初始连接和身份验证时间。\n  JNDI\n对于 JNDI 的数据源类型，MyBatis 将从 JNDI 数据源中获取连接。\n  dataSource的示例代码如下：\n\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!-- MySQL数据库驱动 --\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34; /\u0026gt; \u0026lt;!-- 连接数据库的URL --\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test?characterEncoding=utf8\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt; \u0026lt;/dataSource\u0026gt;     Mappers标签\nmappers 标签用于指定 MyBatis SQL 映射文件的路径。\nmapper 是 mappers 的子标签，mapper 中的 resource 属性用于指定 SQL 映射文件的路径（类资源路径）\n例如，SQL 映射文件的名称是 Student.xml，它位于名为 net.biancheng.mapper 的包中，那么您可以这样配置：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource = \u0026#34;net/biancheng/mapper/Student.xml\u0026#34;\u0026gt;\u0026lt;/mapper\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用完全限定资源定位符（URL） --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper url=\u0026#34;file:///net/biancheng/mapper/Student.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;net.biancheng.mapper.Student\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;net.biancheng.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   Properties标签\nroperties 标签可以通过 resource 属性指定外部 properties 文件（database.properties），也可以通过 properties 子元素配置。\n现在，我们优化一下我们的配置文件\n  在资源目录下新建一个db.properties文件\ndriver=com.mysql.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/mybatis?userSSL=true\u0026amp;userUnicode=true\u0026amp;characterEncoding=utf8\rusername=root\rpassword=777777\r  将文件导入到properties标签下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/heng/dao/Mapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;     typeAliases标签\n为了不在任何地方都指定类的全限定名，我们可以使用 typeAliases 标签定义一个别名。\n例如，在 com.heng.pojo包中有一个 User类，则该类的全限定名称为 com.heng.pojo.User。使用 typeAliases 标签定义别名，这样就不用每次都书写类的全限定名称了，代码如下。\n\u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias type=\u0026#34;com.heng.pojo.User\u0026#34; alias=\u0026#34;user\u0026#34;\u0026gt;\u0026lt;/typeAlias\u0026gt; \u0026lt;/typeAliases 当这样配置时，User可以用在任何使用com.heng.pojo.User的地方。\n也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如\n\u0026lt;typeAliases\u0026gt; \u0026lt;package name =\u0026#34;com.heng.pojo\u0026#34;\u0026gt; \u0026lt;/typeAliases\u0026gt; 每一个在包 com.heng.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。\\例如 Student 别名为 student，User 别名为 user。\n若有注解，则别名为其注解值。见下面的例子：\n//别名为user @Alias(\u0026#34;user\u0026#34;) public class User { ... }   settings标签\nsettings 标签用于配置 MyBatis 的运行时行为，它能深刻的影响 MyBatis 的底层运行，一般不需要大量配置，大部分情况下使用其默认值即可。\nsettings 的配置项很多，但是真正用到的不会太多，我们把常用的配置项研究清楚就可以了。settings 配置项说明如下表所示（表中红色字体的配置项为常用配置项）。\n   配置项 作用 配置选项 默认值     cacheEnabled 该配置影响所有映射器中配置缓存的全局开关 true|false true   lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态 true|false false   aggressiveLazyLoading 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载 true|false 版本3.4.1 （不包含） 之前默认值为 true，之后为 false   multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要兼容驱动） true|false true   useColumnLabel 使用列标签代替列名。不同的驱动会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果 true|false true   useGeneratedKeys 允许JDBC 支持自动生成主键，需要驱动兼容。如果设置为 true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby） true|false false   autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射。 PARTIAL 表示只会自动映射，没有定义嵌套结果集和映射结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套） NONE、PARTIAL、FULL PARTIAL   autoMappingUnkno wnColumnBehavior 指定自动映射当中未知列（或未知属性类型）时的行为。 默认是不处理，只有当日志级别达到 WARN 级别或者以下，才会显示相关日志，如果处理失败会抛出 SqlSessionException 异常 NONE、WARNING、FAILING NONE   defaultExecutorType 配置默认的执行器。SIMPLE 是普通的执行器；REUSE 会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新 SIMPLE、REUSE、BATCH SIMPLE   defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 任何正整数 Not Set (null)   defaultFetchSize 设置数据库驱动程序默认返回的条数限制，此参数可以重新设置 任何正整数 Not Set (null)   safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许，设置 false true|false false   safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许，设置false true|false true   mapUnderscoreToCamelCase 是否开启自动驼峰命名规则映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 true|false false   localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速联复嵌套査询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlScssion 的不同调用将不会共享数据 SESSION|STATEMENT SESSION   jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER NULL、VARCHAR、OTHER OTHER   lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载 — equals、clone、hashCode、toString   defaultScriptingLanguage 指定动态 SQL 生成的默认语言 — org.apache.ibatis .script.ing.xmltags .XMLDynamicLanguageDriver   callSettersOnNulls 指定当结果集中值为 null 时，是否调用映射对象的 setter（map 对象时为 put）方法，这对于 Map.kcySet() 依赖或 null 值初始化时是有用的。注意，基本类型（int、boolean 等）不能设置成 null true|false false   logPrefix 指定 MyBatis 增加到日志名称的前缀 任何字符串 Not set   loglmpl 指定 MyBatis 所用日志的具体实现，未指定时将自动査找 SLF4J|LOG4J|LOG4J2|JDK_LOGGING |COMMONS_LOGGING |ST DOUT_LOGGING|NO_LOGGING Not set   proxyFactory 指定 MyBatis 创建具有延迟加栽能力的对象所用到的代理工具 CGLIB|JAVASSIST JAVASSIST （MyBatis 版本为 3.3 及以上的）   vfsImpl 指定 VFS 的实现类 提供 VFS 类的全限定名，如果存在多个，可以使用逗号分隔 Not set   useActualParamName 允许用方法参数中声明的实际名称引用参数。要使用此功能，项目必须被编译为 Java 8 参数的选择。（从版本 3.4.1 开始可以使用） true|false true    下面给出一个全量的配置样例，如下所示。\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;multipleResultSetsEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;useColumnLabel\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;useGeneratedKeys\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;autoMappingBehavior\u0026#34; value=\u0026#34;PARTIAL\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;autoMappingUnknownColumnBehavior\u0026#34; value=\u0026#34;WARNING\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultExecutorType\u0026#34; value=\u0026#34;SIMPLE\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultStatementTimeout\u0026#34; value=\u0026#34;25\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultFetchSize\u0026#34; value=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;safeRowBoundsEnabled\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;localCacheScope\u0026#34; value=\u0026#34;SESSION\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;jdbcTypeForNull\u0026#34; value=\u0026#34;OTHER\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadTriggerMethods\u0026#34; value=\u0026#34;equals,clone,hashCode,toString\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   类型处理器\n 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】    对象工厂\n MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】    ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""},{"content":"Spring MVC（二） HttpMessageConverter HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文\nHttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity\n  @RequestBody\n@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n@RequestMapping(\u0026#34;/testRequestBody\u0026#34;) public String testRequestBody(@RequestBody String requestBody){ System.out.println(\u0026#34;requestBody:\u0026#34;+requestBody); return \u0026#34;success\u0026#34;; } index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;TestRequestBody\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form th:action=\u0026#34;@{/testRequestEntity}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; username:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;userName\u0026#34;\u0026gt; password:\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 输出结果：requestBody:userName=111\u0026amp;password=111\n  RequestEntity\nRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n@RequestMapping(\u0026#34;/testRequestEntity\u0026#34;) public String testRequestEntity(RequestEntity\u0026lt;String\u0026gt; requestEntity){ System.out.println(\u0026#34;requestHeader:\u0026#34;+requestEntity.getHeaders()); System.out.println(\u0026#34;requestBody:\u0026#34;+requestEntity.getBody()); return \u0026#34;success\u0026#34;; } 会在控制台返回一个报文的报头与报体\n  @ResponseBody\n@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n@RequestMapping(\u0026#34;/testResponseBody\u0026#34;) @ResponseBody public String testResponseBody(){ return \u0026#34;Test ResponseBody\u0026#34;; }   @RestController\n@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解\n  当我们需要响应一个对象的信息给浏览器时，我们可以使用json格式\nJson交互处理 什么是Json\n Json（JavaScript Object Notation，JS标记对象）是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得Json成为理想的数据交换语言 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率  在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：\n 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组  JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 \u0026quot;\u0026quot; 包裹，使用冒号 : 分隔，然后紧接着值：\n{\u0026#34;name\u0026#34;: \u0026#34;QinJiang\u0026#34;} {\u0026#34;age\u0026#34;: \u0026#34;3\u0026#34;} {\u0026#34;sex\u0026#34;: \u0026#34;男\u0026#34;} JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\n要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\nvar obj = JSON.parse(\u0026#39;{\u0026#34;a\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;World\u0026#34;}\u0026#39;); //结果是 {a: \u0026#39;Hello\u0026#39;, b: \u0026#39;World\u0026#39;} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：\nvar json = JSON.stringify({a: \u0026#39;Hello\u0026#39;, b: \u0026#39;World\u0026#39;}); //结果是 \u0026#39;{\u0026#34;a\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;World\u0026#34;}\u0026#39; 代码测试\n  新建项目，导入依赖，配置项目\n新加的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写web.xml配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!--springmvc提供的过滤器，解决乱码问题--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   编写springmvc配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.heng.controller\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   编写实体类user\npackage com.heng.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @Author: minster * @Date: 2021/11/11 21:33 */ @Data @NoArgsConstructor @AllArgsConstructor public class User { private int id; private String name; private int age; } 这里使用了lombok自动配置属性的get/set方法及构造器\n  编写Controller\npackage com.heng.controller; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.heng.pojo.User; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @Author: minster * @Date: 2021/11/11 21:33 */ @Controller public class UserController { @RequestMapping(\u0026#34;json1\u0026#34;) @ResponseBody public String jsonTestOne() throws JsonProcessingException { //创建一个Jackson的对象映射，用来解析数据  ObjectMapper Mapper = new ObjectMapper(); //创建一个对象  User user = new User(1,\u0026#34;jack1\u0026#34;,10); //将我们的对象解析为json格式  String str = Mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } }   编写json-1.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JSON_Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //编写一个js的对象  var user = { name:\u0026#34;jack\u0026#34;, age:3, sex:\u0026#34;男\u0026#34; }; //将js对象转换成json字符串  var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象  var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   运行，测试，成功在前端返回数据\n  注意：如果仍出现乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；\n通过@RequestMaping的produces属性来实现，修改下代码\n//produces:指定响应体返回类型和编码 @RequestMapping(value = \u0026#34;/json1\u0026#34;,produces = \u0026#34;application/json;charset=utf-8\u0026#34;) 乱码统一解决\n上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！\n我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 然后在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\npackage com.heng.controller; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.heng.pojo.User; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; /** * @Author: minster * @Date: 2021/11/11 21:33 */ @RestController public class UserController { @RequestMapping(\u0026#34;json1\u0026#34;) public String jsonTestOne() throws JsonProcessingException { //创建一个Jackson的对象映射，用来解析数据  ObjectMapper Mapper = new ObjectMapper(); //创建一个对象  User user = new User(1,\u0026#34;jack1\u0026#34;,10); //将我们的对象解析为json格式  String str = Mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } } 测试集合输出\n@RequestMapping(\u0026#34;/json2\u0026#34;) public String json2() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); User jack = new User(1, \u0026#34;jack\u0026#34;, 21); User mary = new User(2, \u0026#34;mary\u0026#34;, 20); User tom = new User(3, \u0026#34;tom\u0026#34;, 20); User smith = new User(4, \u0026#34;smith\u0026#34;, 20); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(jack); list.add(mary); list.add(tom); list.add(smith); String str = mapper.writeValueAsString(list); return str; } 测试输出时间\n@RequestMapping(\u0026#34;/json3\u0026#34;) public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); Date date = new Date(); String s = mapper.writeValueAsString(date); return s; } 运行结果：\n 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式  自定义时间格式可以解决上述问题\n@RequestMapping(\u0026#34;/json3\u0026#34;) public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //设置mapper不使用时间戳的方式输出时间  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); //自定义日期格式对象  SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); //指定日期格式  mapper.setDateFormat(sdf); Date date = new Date(); String s = mapper.writeValueAsString(date); return s; } @RequestMapping(\u0026#34;/json3\u0026#34;) public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //设置mapper不使用时间戳的方式输出时间  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); //自定义日期格式对象  SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); //指定日期格式  mapper.setDateFormat(sdf); Date date = new Date(); String s = mapper.writeValueAsString(date); return s; } 新的问题出现了：如果我们使用上述方法，解决时间戳问题，那就每一个类都需要加上那几行配置的代码，复用性大大降低，所以我们可以把设置日期格式的代码封装成一个工具类，这样就可以大大提高代码的复用率了！\npackage com.heng.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; /** * @Author: minster * @Date: 2021/11/12 9:11 */ public class JsonUtils { public String getJson(Object object){ return getJson(object,\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public String getJson(Object object,String dateFormat){ ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 在Controller中，如果我们需要输出时间，就可以直接调用工具类的方法了！非常简洁方便\n@RequestMapping(\u0026#34;/json3\u0026#34;) public String json3() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } FastJson\n fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。\n 添加依赖\n\u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.78\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; fastjson 三个主要的类：\n  JSONObject 代表 json 对象\n JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\u0026quot;键：值\u0026quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。    JSONArray 代表 json 对象数组\n 内部是有List接口中的方法来完成操作的。    JSON代表 JSONObject和JSONArray的转化\n JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。  package com.heng.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象  User user1 = new User(1,\u0026#34;jack\u0026#34;,3); User user2 = new User(2,\u0026#34;tom\u0026#34;,3); User user3 = new User(3,\u0026#34;mary\u0026#34;,3); User user4 = new User(4,\u0026#34;smith\u0026#34;,3); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\u0026#34;*******Java对象 转 JSON字符串*******\u0026#34;); String str1 = JSON.toJSONString(list); System.out.println(\u0026#34;JSON.toJSONString(list)==\u0026gt;\u0026#34;+str1); String str2 = JSON.toJSONString(user1); System.out.println(\u0026#34;JSON.toJSONString(user1)==\u0026gt;\u0026#34;+str2); System.out.println(\u0026#34;\\n****** JSON字符串 转 Java对象*******\u0026#34;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\u0026#34;JSON.parseObject(str2,User.class)==\u0026gt;\u0026#34;+jp_user1); System.out.println(\u0026#34;\\n****** Java对象 转 JSON对象 ******\u0026#34;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\u0026#34;(JSONObject) JSON.toJSON(user2)==\u0026gt;\u0026#34;+jsonObject1.getString(\u0026#34;name\u0026#34;)); System.out.println(\u0026#34;\\n****** JSON对象 转 Java对象 ******\u0026#34;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\u0026#34;JSON.toJavaObject(jsonObject1, User.class)==\u0026gt;\u0026#34;+to_java_user); } }   ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""},{"content":"Spring MVC（一） Spring MVC概括   什么是MVC\n  MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。\n  MVC主要作用是降低了视图与业务逻辑间的双向偶合。\n  MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异\n  Model(模型)：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或者JavaBean组件（包括数据和行为），不过现在一般分离开来：Value Object(数据Dao) 和服务层(行为Service)。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView(视图)：负责进行模型的展示，一般就是我们见到的用户界面，用户想看到的东西。\nConttroller(控制器)：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责\t展示、也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP+Servlet+JavaBean\n  Model1\n在Web开发早期通常采用Model1模式进行开发。\n在Model1模式下，整个Web应用几乎全部用JSP页面组成，只用少量的JavaBean来处理数据库连接、访问等操作\n这个模式下JSP即使控制层（Controller）又是视图层（View）。这明显不符合Java的单一职责原则。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。\n  ​\tModel1优点：架构简单，适合小型项目开发；\n​\tModel1缺点：JSP职责不单一，，职责过重，不便于维护\n Model2\nModel2就是上面所述的Java Bean+JSP+Servlet这种开发模式，这就是早期的JavaWeb MVC开发模式。\n Model：系统涉及的数据，也就是dao与bean View：展示模型中的数据，只是用来展示 controller：处理用户请求发送给Model，然后Model返回数据的处理结果给JSP并展示给用户  职责分析：\nController：控制器\n 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型\n 业务逻辑 保存数据的状态  View：视图\n 显示页面   Model2模式下还存在着很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地重复造轮子，这就大大降低了程序的可维护性和复用性。\n于是，很多JavaWeb开发相关的MVC框架应运而生，比如Stuts2，但是Struts2比较笨重。\n   Spring MVC时代\n随着Spring轻量级开发框架1的流行，Spring生态圈出现了Spring MVC框架，Spring MVC框架是当前最优秀的MVC框架。相比于Struts2，Spring MVC使用更加啊简单和方便，开发效率更高，并且Spring MVC运行速度更快。\nMVC是一种设计模式，Spring MVC是一款很优秀的MVC框架。Spring MVC可以帮我们更简洁Web层的开发，并且它天生与Spring框架集成。Spring MVC下我们一般把后端项目分为Service层（处理业务）、dao层（数据库操作）、Entity层（实体类）、Controller层（控制层）\n  Spring MVC工作原理 Spring MVC的原理如下图所示：\n 流程说明：  客户端（浏览器）发送请求，直接请求到DispatcherServlet。 DispatcherServlet根据请求信息调用HandlerMapper，解析请求对应的Handler。 解析到对应的Handler（也就是Controller控制器）后，开始由HandlerAdapter适配器处理。 HandlerAdapter会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View。 ViewResolver会根据逻辑View查找实际的View。 DispaterServlet把返回的Model传给View（视图渲染）。 把View返回给请求者（浏览器）。    第一个Spring MVC程序 使用配置实现   创建并部署项目springmvc-02-hello；导入依赖\n  配置web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--注册dispatchServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个1spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别 1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/-匹配所有请求：不包括.jsp--\u0026gt; \u0026lt;!--/*-匹配所有请求：包括.jsp--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   编写SpringMVC的配置文件：springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--添加处理映射器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--添加处理适配器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--添加视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.heng.controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   编写操作业务的Controller控制器，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图。\npackage com.heng.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @Author: minster * @Date: 2021/11/10 9:38 */ public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //ModelAndView模型和视图  ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model  mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;HelloSpringMVC!\u0026#34;); //封装要跳转的视图，放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); return mv; } }   在spring中注册上面的类\n\u0026lt;/bean\u0026gt; \u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.heng.controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;   编写jsp文件\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;HelloSpringMVC\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r${msg}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  测试\n  使用注解实现   新建一个Moudle，springmvc-03-annotation。添加web支持，导入依赖\n  由于Maven可能存在资源过滤问题，我们将其配置完善\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   配置web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--注册servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联springmvc的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--设置启动顺序--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--所有请求都会被springmvc拦截--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;  / 和 /* 的区别：\n\u0026lt; url-pattern \u0026gt; / \u0026lt;/ url-pattern \u0026gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。\n\u0026lt; url-pattern \u0026gt; /* \u0026lt;/ url-pattern \u0026gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。\n   添加Spring MVC的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--自动扫描包，让指定包下的注解生效，由IOC统一管理--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.heng.controller\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!--让SpringMVC不处理静态资源--\u0026gt; \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; \u0026lt;!--支持mvc注解驱动--\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  **\u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;**作用：\n在spring中一般采用@RequestMapping注解来完成映射关系要想使@RequestMapping注解生效必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter实例\n这两个实例分别在类级别和方法级别处理。而annotation-driven配置帮助我们自动完成上述两个实例的注入。\n   创建Controller\npackage com.heng.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; /** * @Author: minster * @Date: 2021/11/10 15:16 */ @Controller @RequestMapping(\u0026#34;/HelloController\u0026#34;) public class HelloController { //真实访问地址 : 项目名/HelloController/hello  @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;helloSpringMVCAnnotation\u0026#34;); return \u0026#34;hello\u0026#34;; } }  @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。    创建视图层\n在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；\n可以通过EL表示取出Model中存放的值，或者对象；\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r${msg}\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  测试运行\n  小结\n使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\n@Controller与@RequestMappping   控制器Controller\n 控制器复杂提供访问应用程序的行为1，通常通过接口定义或注解定义两种方式实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种  实现Controller接口来配置Controller\nController接口\npackage org.springframework.web.servlet.mvc; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.lang.Nullable; import org.springframework.web.servlet.ModelAndView; @FunctionalInterface public interface Controller { @Nullable ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception; } 观察上面代码我们可以知道，当我们使用Controller接口来配置Controller时，我们只需要实现一个返回ModelAndView的方法即可。\npackage com.heng.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @Author: minster * @Date: 2021/11/10 9:38 */ public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //ModelAndView模型和视图  ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model  mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;HelloSpringMVC!\u0026#34;); //封装要跳转的视图，放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); return mv; } } 使用该方法还需要去Spring MVC的配置文件springmvc-servlet.xml中注册一个Bean\n\u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.heng.controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 使用@Controller注解来配置Controller\n@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；\nSpring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描\n\u0026lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang.controller\u0026#34;/\u0026gt; 使用@Controller注解\npackage com.heng.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; /** * @Author: minster * @Date: 2021/11/10 15:16 */ @Controller //映射访问路径 @RequestMapping(\u0026#34;/HelloController\u0026#34;) public class HelloController { //映射访问路径，真实访问路径为localhost:8080/HelloController/hello  @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值  model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;helloSpringMVCAnnotation\u0026#34;); return \u0026#34;hello\u0026#34;; } } 测试结果\n  @RequestMapping\n从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。\nSpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n@RequestMapping可以在标注一个方法或者一个类\n @RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息  @Controller @RequestMapping(\u0026#34;/HelloController\u0026#34;) public class HelloController { //此时请求映射所映射的请求的请求路径为：/HelloController/hello  @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;helloSpringMVCAnnotation\u0026#34;); return \u0026#34;hello\u0026#34;; } }   RestFul风格 REST：Representational State Transfer，表现层资源状态转移\n概念\nRestFul就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更安全，更易于实现缓存等机制。\n  资源\n资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。\n互联网所有的事物都可以被抽象为资源\n  状态转移\n状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n  RestFul的实现\n具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n   操作 传统方式 REST风格     查询操作 getUserById?id=1 user/1\u0026ndash;\u0026gt;get请求方式   保存操作 saveUser user\u0026ndash;\u0026gt;post请求方式   删除操作 deleteUser?id=1 user/1\u0026ndash;\u0026gt;delete请求方式   更新操作 updateUser user\u0026ndash;\u0026gt;put请求方式    测试案例\n  创建Controller\npackage com.heng.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; /** * @Author: minster * @Date: 2021/11/11 9:15 */ @Controller public class RestFulController { @RequestMapping(\u0026#34;/restFul/{p1}/{p2}\u0026#34;) public String restFul(@PathVariable int p1,@PathVariable int p2, Model model){ int res = p1+p2; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为 \u0026#34;+res); return \u0026#34;test\u0026#34;; } }   测试\n  注意：\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/restFul/1/a，则路径与方法不匹配，而不会是参数转换失败。\n  使用method属性可以指定请求类型\n@RequestMapping中的method属性可以用于约束请求的类型，可以收窄请求范围。\n把上面的restFul方法改为\n@Controller public class RestFulController { @RequestMapping(value = \u0026#34;/restFul/{p1}/{p2}\u0026#34;,method = RequestMethod.POST) public String restFul(@PathVariable int p1,@PathVariable int p2, Model model){ int res = p1+p2; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为 \u0026#34;+res); return \u0026#34;test\u0026#34;; } } 我们再去浏览器请求\n可以发现网页报了405的错误；因为我们浏览器地址栏进行访问默认是Get请求！！！！\n如果把POST改为GET就可以正常访问了！\n@Controller public class RestFulController { @RequestMapping(value = \u0026#34;/restFul/{p1}/{p2}\u0026#34;,method = RequestMethod.GET) public String restFul(@PathVariable int p1,@PathVariable int p2, Model model){ int res = p1+p2; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为 \u0026#34;+res); return \u0026#34;test\u0026#34;; } } 小结：\nSpring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\n所有的地址栏请求默认都会是 HTTP GET 类型的。\n方法级别的注解变体有如下几个：组合注解\n@GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！\n它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。\n数据处理及跳转 数据处理 处理提交的数据\n  提交的域名城和处理方法的参数名一致\n提交数据：http://localhost:8080/commit?name=minster\n处理方法：\n@Controller public class TestController1 { @RequestMapping(\u0026#34;/commit\u0026#34;) public String commitName(String name, Model model){ model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Name = \u0026#34;+name); System.out.println(name); return \u0026#34;test\u0026#34;; } } 后台输出minster\n前端显示页面\n  提交的域名称和处理方法的参数名不一致\n提交数据：http://localhost:8080/commit?username=minster\n处理方法：\n@Controller public class TestController1 { @RequestMapping(\u0026#34;/commit\u0026#34;) public String commitName(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Name = \u0026#34;+name); System.out.println(name); return \u0026#34;test\u0026#34;; } } 后台输出minster\n前端显示：\n如果此时我们提交的数据为 name=minster，服务器会报错\n因为我们使用@RequestParam会约束请求提交的参数名！\n  提交一个对象\n要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n创建实体类User\npackage com.heng.pojo; /** * @Author: minster * @Date: 2021/11/11 12:31 */ public class User { private int id; private String name; private int age; } 提交数据：http://localhost:8080/user?id=1\u0026amp;name=minster\u0026amp;age=21\n处理方法：\n@RequestMapping(\u0026#34;/user\u0026#34;) public String commitUser(User user){ System.out.println(user); return \u0026#34;test\u0026#34;; } 后台成功输出User{id=1, name=\u0026lsquo;minster\u0026rsquo;, age=21}\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n  数据显示到前端\n  ModelAndView\npublic class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } }   ModelMap\n@RequestMapping(\u0026#34;/commit\u0026#34;) public String commitName(@RequestParam(\u0026#34;username\u0026#34;) String name, ModelMap map){ map.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Name = \u0026#34;+name); System.out.println(name); return \u0026#34;test\u0026#34;; }   Model\n@RequestMapping(\u0026#34;/ct2/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;msg\u0026#34;,name); System.out.println(name); return \u0026#34;test\u0026#34;; }   对比：\n Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；\nModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；\nModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。\n 页面跳转   **转发：**由服务器端进行的页面跳转;\n  **重定向(Redirect)：**由浏览器端进行的页面跳转;\n重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。\n  ModelAndView\n设置ModelAndView对象，根据View的名称和视图解析器可以跳转到指定的页面\n 页面 = {视图解析器前缀} + ViewName + {视图解析器后缀}\n \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 对应的Controller类\n@Controller @RequestMapping(\u0026#34;/HelloController\u0026#34;) public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;helloSpringMVCAnnotation\u0026#34;); return \u0026#34;hello\u0026#34;; } }  访问的url为 localhost:8080/HelloController/hello\n ServletAPI\n通过设置ServletAPI , 不需要视图解析器 .\n1、通过HttpServletResponse进行输出\n2、通过HttpServletResponse实现重定向\n3、通过HttpServletResponse实现转发\n@Controller public class ResultGo { @RequestMapping(\u0026#34;/result/t1\u0026#34;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(\u0026#34;Hello,Spring BY servlet API\u0026#34;); } @RequestMapping(\u0026#34;/result/t2\u0026#34;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { //重定向  rsp.sendRedirect(\u0026#34;/index.jsp\u0026#34;); } @RequestMapping(\u0026#34;/result/t3\u0026#34;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发  req.setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;/result/t3\u0026#34;); req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/test.jsp\u0026#34;).forward(req,rsp); } } SpringMVC\n通过SpringMVC来实现转发和重定向 - 无需视图解析器；\n测试前，需要将视图解析器注释掉\n@Controller public class ResultSpringMVC { @RequestMapping(\u0026#34;/rsm/t1\u0026#34;) public String test1(){ //转发  return \u0026#34;/index.jsp\u0026#34;; } @RequestMapping(\u0026#34;/rsm/t2\u0026#34;) public String test2(){ //转发二  return \u0026#34;forward:/index.jsp\u0026#34;; } @RequestMapping(\u0026#34;/rsm/t3\u0026#34;) public String test3(){ //重定向  return \u0026#34;redirect:/index.jsp\u0026#34;; } } 通过SpringMVC来实现转发和重定向 - 有视图解析器；\n重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.\n可以重定向到另外一个请求实现 .\n@Controller public class ResultSpringMVC2 { @RequestMapping(\u0026#34;/rsm2/t1\u0026#34;) public String test1(){ //转发  return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/rsm2/t2\u0026#34;) public String test2(){ //重定向  return \u0026#34;redirect:/index.jsp\u0026#34;; //return \u0026#34;redirect:hello.do\u0026#34;; //hello.do为另一个请求/  } } 乱码问题 案例演示\n  我们在首页编写一个提交的表单\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;乱码问题\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;form action=\u0026quot;/commitForm\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  后台编写对应的处理方法\n@RequestMapping(\u0026#34;/commitForm\u0026#34;) public String commitForm(Model model , String name){ model.addAttribute(\u0026#34;msg\u0026#34;,name); return \u0026#34;test\u0026#34;; }   测试\n输出结果，发现乱码\n以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .\n修改了xml文件需要重启服务器！\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 运行\n问题解决！\n  如果我们使用上述过滤器还不能解决乱码问题的话，我们可以自定义一个强大的过滤器！（网上一个大佬写的过滤器，基本所有乱码问题都能解决！）\npackage com.heng.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ @SuppressWarnings({\u0026#34;all\u0026#34;}) public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码  HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); // 转型为与协议相关对象  HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强  HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } @SuppressWarnings({\u0026#34;all\u0026#34;}) //自定义request对象，HttpServletRequest的包装类 class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记  private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰  public MyRequest(HttpServletRequest request) { super(request);// super必须写  this.request = request; } // 对需要增强方法 进行覆盖  @Override public Map getParameterMap() { // 先获得请求方式  String method = request.getMethod(); if (method.equalsIgnoreCase(\u0026#34;post\u0026#34;)) { // post请求  try { // 处理post乱码  request.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\u0026#34;get\u0026#34;)) { // get请求  Map\u0026lt;String, String[]\u0026gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次  for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i \u0026lt; values.length; i++) { try { // 处理get乱码  values[i] = new String(values[i] .getBytes(\u0026#34;ISO-8859-1\u0026#34;), \u0026#34;utf-8\u0026#34;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值  @Override public String getParameter(String name) { Map\u0026lt;String, String[]\u0026gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值  } //取所有值  @Override public String[] getParameterValues(String name) { Map\u0026lt;String, String[]\u0026gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 然后再web.xml中配置一下即可！\n","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""},{"content":"开发中用到的配置汇总   Log4j配置\nmybatis-config.xml中开启LOG4J日志配置\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 新建一个log4j.properties的配置文件\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\rlog4j.rootLogger=DEBUG,console,file\r#控制台输出的相关设置\rlog4j.appender.console = org.apache.log4j.ConsoleAppender\rlog4j.appender.console.Target = System.out\rlog4j.appender.console.Threshold=DEBUG\rlog4j.appender.console.layout = org.apache.log4j.PatternLayout\rlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\r#文件输出的相关设置\rlog4j.appender.file = org.apache.log4j.RollingFileAppender\rlog4j.appender.file.File=./log/heng.log\rlog4j.appender.file.MaxFileSize=10mb\rlog4j.appender.file.Threshold=DEBUG\rlog4j.appender.file.layout=org.apache.log4j.PatternLayout\rlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\r#日志输出级别\rlog4j.logger.org.mybatis=DEBUG\rlog4j.logger.java.sql=DEBUG\rlog4j.logger.java.sql.Statement=DEBUG\rlog4j.logger.java.sql.ResultSet=DEBUG\rlog4j.logger.java.sql.PreparedStatement=DEBUG\r  Maven静态资源过滤问题\n在Pom文件中加入下面内容即可解决\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""},{"content":"网络编程   概述   计算机网络：计算机网络是指将地理位置不同的具有独立功能的多态计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。\n​\t计算机网络是指两台或更多的计算机组成的网络，在一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。\n​\t那什么是互联网呢？互联网互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。\n​\t对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。\n​\tTCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。\n  网络通信中的要素   IP地址\n​\t在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。\n​\tIP地址分为IPv4（4个字节组成）和IPv6（8个无符号整数）两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。\n  域名\n​\t因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。\n 有一个特殊的本机域名localhost，它对应的IP地址总是本机地址127.0.0.1\n   网络模型\n​\t由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：\n 应用层，提供应用程序之间的通信； 表示层：处理数据格式，加解密等等； 会话层：负责建立和维护会话； 传输层：负责提供端到端的可靠传输； 网络层：负责根据目标地址选择路由来传输数据； 链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等    TCP协议和UDP协议\n TCP是专门设计用于在因特网上提供可靠的端到端的字节流通信的协议。它是一种面向连接的协议。TCP连接是字节流而非报文流（如银行转账系统）。 UDP是向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接（如语音、视频、游戏）。    ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""}]