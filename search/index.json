[{"content":"反射   反射机制 class类 类加载 反射获取类的结构信息 通过反射创建对象 练习   反射机制   引出反射\n  根据配置文件re.properties指定信息，创建Cat对象并调用方法hi\nproperties配置文件如下\nclassPath=com.reflection_.Cat\rmethod=hi\rCat类\npackage com.reflection_; public class Cat { private String name = \u0026#34;jack\u0026#34;; public void hi(){ System.out.println(\u0026#34;hi \u0026#34;+name); } } 实现类ReflectionQuestion\npackage com.reflection_.question; import com.reflection_.Cat; public class ReflectionQuestion { public static void main(String[] args) { //1.使用传统方法实现，通过new一个对象，调用方法来实现  Cat cat = new Cat(); cat.hi(); } } 我们使用传统的方式，能实现上述需求，但如果我们Cat类需要增加功能或者换一种实现时，我们就需要去修改源码了！\n所以我们可以尝试使用反射来实现上述需求\npackage com.reflection_.question; import com.reflection_.Cat; import java.io.FileInputStream; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; @SuppressWarnings({\u0026#34;all\u0026#34;}) public class ReflectionQuestion { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.使用properties类，读写配置文件  Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(\u0026#34;classfullpath = \u0026#34; + classfullpath); System.out.println(\u0026#34;methodName = \u0026#34; + methodName); //2.创建对象，发现new的是一个String 错误！！  // new classfullpath();  //3.此时就需要使用反射机制来解决了  //3.1 加载类，返回class类型的对象cls  Class cls = Class.forName(classfullpath); //3.2 通过cls得到你加载的类 com.reflection_.Cat 的对象实例  Object o = cls.newInstance(); System.out.println(\u0026#34;o的运行类型 = \u0026#34; + o.getClass());//运行类型  //3.3 通过cls得到你加载的类 com.reflection_.Cat 的 methodName 的方法对象  // 在反射中，可以把方法视为对象（万物皆对象！）  Method method1 = cls.getMethod(methodName); //3.4 通过method1 调用方法：即通过方法对象调用方法！  method1.invoke(o); } } 我们可以发现，使用传统方法时：对象.方法()，反射机制：方法.invoke(对象)\n 这样的需求在学习框架是特别多，即通过外部文件配置，在不修改源码的情况下，来控制程序，也符合设计模式的OCP原则（开闭原则：不修改源码，扩容功能）。\n     反射机制\n 反射机制允许程序在执行期借助于Reflection API取得任何类的内部消息（比如成员变量，构造器，成员方法等等），并且能操作对象的属性及方法。反射在设计模式和框架底层都会用到 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射  反射机制原理图\n  Java反射机制可以完成\n 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时得到任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 生产动态代理    反射相关的主要类：\n java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象 java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法 java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量 java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示某个类的构造器  代码演示:\npackage com.reflection_; import java.io.FileInputStream; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; /** * @author minster */ public class Reflection01 { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //1.使用properties类，读写配置文件  Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(\u0026#34;classfullpath = \u0026#34; + classfullpath); System.out.println(\u0026#34;methodName = \u0026#34; + methodName); //3.此时就需要使用反射机制来解决了  //3.1 加载类，返回class类型的对象cls  Class cls = Class.forName(classfullpath); //3.2 通过cls得到你加载的类 com.reflection_.Cat 的对象实例  Object o = cls.newInstance(); //运行类型  System.out.println(\u0026#34;o的运行类型 = \u0026#34; + o.getClass()); //3.3 通过cls得到你加载的类 com.reflection_.Cat 的 methodName 的方法对象  // 在反射中，可以把方法视为对象（万物皆对象！）  Method method1 = cls.getMethod(methodName); //3.4 通过method1 调用方法：即通过方法对象调用方法！  method1.invoke(o); //获取Cat类中的某个字段（成员变量），getField不能获取私有属性  Field age = cls.getField(\u0026#34;age\u0026#34;); System.out.println(age); //()中能指定构造器参数类型，下面返回无参构造器  Constructor constructor01 = cls.getConstructor(); System.out.println(constructor01); //这里传入的String.class 就是String类的Class对象  Constructor constructor02 = cls.getConstructor(String.class); System.out.println(constructor02); } }     反射的优点和缺点\n 优点：可以动态的创建和使用对象（也是框架的底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑 缺点：使用反射基本是解释执行，对执行速度有影响  package com.reflection_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author minster */ public class Reflection02 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { m1(); } public static void m1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.reflection_.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); for (int i = 0; i \u0026lt; 900000000; i++) { hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;耗时：\u0026#34; + (end-start)); } }   反射调用优化-关闭访问检查\n Method和Field、Constructor对象都有setAccessible()方法 setAccessible作用是启动和禁用访问安全检查的开关 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查。  优化代码\npackage com.reflection_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author minster */ public class Reflection02 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { m1(); } public static void m1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.reflection_.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); //关闭反射的访问检测  hi.setAccessible(true); for (int i = 0; i \u0026lt; 900000000; i++) { hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;耗时：\u0026#34; + (end-start)); } }   Class类   基本介绍：\n  Class类也是类，因此也继承Object类\n  Class类对象不是new出来的，而是系统创建的。\n//追源码可以发现是通过ClassLoader类来加载Cat类的Class对象 public Class\u0026lt;?\u0026gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); }   对于某个类的Class类对象，在内存中只有一份，因此类只加载一次\n  每个类的实例都会记得自己是由哪个Class实例所生成\n  通过Class可以完整地得到一个类的完整结构，通过一系列API\npackage com.reflection_.class_; import com.reflection_.Car; import java.lang.reflect.Field; /** * @Author: minster * @Date: 2021/9/22 8:41 */ public class Class02 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { String classPath = \u0026#34;com.reflection_.Car\u0026#34;; Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); //显示cls对象，是哪个类的Class对象 com.reflection_.cat  System.out.println(cls); //输出cls的运行类型 java.lang.Class  System.out.println(cls.getClass()); //创建Class对象的实例,即通过反射获取对象  Car car = (Car)cls.newInstance(); System.out.println(car); //通过反射获取对象的属性  Field brand = cls.getField(\u0026#34;brand\u0026#34;); System.out.println(brand.get(car)); //通过反射获取的字段进行赋值  brand.set(car,\u0026#34;奔驰\u0026#34;); System.out.println(brand.get(car)); //获取所有属性  Field[] fields = cls.getFields(); for (Field f : fields) { System.out.println(f.get(car)); } } }   Class对象时存放在堆的\n  类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）\n    获取类对象的6种方式\n  已知一个类的全类名，且在该类的路径下，可以通过Class类的对象的静态方法forName()获取，可能抛出ClassNotFoundException。多用于读取配置文件，读取类全路径，加载类阶段\n  若已知具体的类，通过类的class来获取，该方式最为安全可靠，程序性能最高。多用于参数传递，比如通过反射得到对应构造器对象。\n  若已知某个类的实例，调用该实例的getClass()方法获取Class对象。用于通过创建好的对象，获取Class对象。\n  使用类的加载器来获取类的对象\n  基本数据类型可以通过class cls = int.class获取Class对象\n  基本数据类型对应的包装类，可以通过type获取Class对象\n  代码演示：\npackage com.reflection_.class_; import com.reflection_.Car; /** * @Author: minster * @Date: 2021/9/22 9:30 */ public class GetClass { public static void main(String[] args) throws ClassNotFoundException { String classPath = \u0026#34;com.reflection_.Car\u0026#34;; //1. 通过Class类的对象的静态方法forName()获取  Class\u0026lt;?\u0026gt; cls1 = Class.forName(classPath); System.out.println(cls1.getName()); //2. 通过类的class来获取  Class cls2 = Car.class; System.out.println(cls2.getName()); //3. 调用该实例的getClass()方法获取Class对象  Car car = new Car(); Class\u0026lt;? extends Car\u0026gt; cls3 = car.getClass(); System.out.println(cls3.getName()); //4. 使用类的加载器来获取类的对象  //先得到类的加载器  ClassLoader classLoader = car.getClass().getClassLoader(); //再通过类的加载器得到Class对象  Class\u0026lt;?\u0026gt; cls4 = classLoader.loadClass(classPath); System.out.println(cls4); //通过hashCode可以看出来他们都是同一个类的对象  System.out.println(\u0026#34;cls1HashCode = \u0026#34;+cls1.hashCode()); System.out.println(\u0026#34;cls2HashCode = \u0026#34;+cls2.hashCode()); System.out.println(\u0026#34;cls3HashCode = \u0026#34;+cls3.hashCode()); System.out.println(\u0026#34;cls4HashCode = \u0026#34;+cls4.hashCode()); //5. 通过`class cls = int.class`获取Class对象  Class\u0026lt;Integer\u0026gt; integerClass = int.class; System.out.println(integerClass); //6. 通过type获取Class对象  Class\u0026lt;Integer\u0026gt; type = Integer.TYPE; System.out.println(type); System.out.println(\u0026#34;intHashCode = \u0026#34;+integerClass.hashCode()); System.out.println(\u0026#34;IntegerHashCode = \u0026#34;+type.hashCode()); } } 运行结果：\n  在Java中出了基本数据类型有Class对象之外，下面的类型也有Class对象\n  类加载   基本说明\n反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。\n 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性  代码演示\npackage com.reflection_.class_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Scanner; /** * @Author: minster * @Date: 2021/9/22 10:04 */ public class Class03 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;input key\u0026#34;); String key = scanner.nextLine(); switch (key){ case\u0026#34;1\u0026#34;: Dog dog = new Dog(); dog.cry(); System.out.println(\u0026#34;1\u0026#34;); break; case \u0026#34;2\u0026#34; : System.out.println(\u0026#34;ok\u0026#34;); break; case \u0026#34;3\u0026#34; : System.out.println(\u0026#34;ok\u0026#34;); default: System.out.println(\u0026#34;not do\u0026#34;); } scanner.close(); } } 使用cmd进行编译，可以发现即使我们还没传key进去，程序也会报错，因为Dog类是静态加载，因此必须编写Dog类才可以！\n此时我们把case 1处的代码注释，使用反射加载类Person\npackage com.reflection_.class_; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Scanner; /** * @Author: minster * @Date: 2021/9/22 10:04 */ public class Class03 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;input key\u0026#34;); String key = scanner.nextLine(); switch (key){ case\u0026#34;1\u0026#34;: /* Dog dog = new Dog; dog.cry();*/ System.out.println(\u0026#34;1\u0026#34;); break; case \u0026#34;2\u0026#34; : Class\u0026lt;?\u0026gt; person = Class.forName(\u0026#34;Person\u0026#34;); Object o = person.newInstance(); Method m = person.getMethod(\u0026#34;hi\u0026#34;); m.invoke(o); break; case \u0026#34;3\u0026#34; : System.out.println(\u0026#34;ok\u0026#34;); default: System.out.println(\u0026#34;not do\u0026#34;); } scanner.close(); } } 输出1，可以发现程序能正常执行\n输入2，程序抛出异常！这就是所谓的动态加载，当运行时执行到该类的代码时才会使程序异常！\n  类加载时机\n 当创建对象时（new）——静态加载 当子类被加载时——静态加载 调用类中的静态成员时——静态加载 通过反射——动态加载    类加载过程图\n在类加载的三个阶段中，各个阶段会分别完成以下任务\n  加载（Loading）阶段：JVM在该阶段主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络）转换为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象。\n  连接（Linking）阶段：该阶段包含验证、准备、解析三个阶段\n  验证阶段：\n 确保被加载的类的正确性，确保你加载的字节码文件没有被恶意地修改过，而且一切都是符合JVM对于字节码格式的要求 在字节码语言层面，Java代码无法做到的事情都是可以实现的，至少语义上可以表达出来的，虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作 包括：文件格式验证、元数据验证、字节码验证和符号引用验证    准备阶段：为类变量赋初值，不给实例变量赋值，这儿的初值指的是零值。例如public static int value = 123;\nvalue在准备阶段过后的初始值为0而不是123；\n//在准备阶段，属性会如何处理？ //1. n1是实例属性，不是静态变量，因此在准备阶段，是不会分配内存的！ //2. n2是静态变量，分配内存；n2是默认初始化0，而不是20 //3. n3是static final常量，它和静态变量不一样，因为一旦赋值就不会改变，所以n3 = 30； public int n1 = 10; public static int n2 = 20; public static final int n3 = 30;   解析阶段：将常量池的符号引用转化为直接引用，主要针对接口或类，字段。接口方法，类方法的符号引用。\n    初始化（initialization）阶段：为类的静态变量赋予正确的初始值，即程序员显式地赋予的初始值\n  到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行\u0026lt;clinit\u0026gt;()方法的过程。\n  \u0026lt;clinit\u0026gt;()方法由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。\n  JVM会保证一个类的\u0026lt;clinit\u0026gt;()方法在多线程环境中被正确加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\u0026lt;clinit\u0026gt;()方法，其他线程都需要阻塞等待，知道活动现场执行\u0026lt;clinit\u0026gt;()方法完毕！\nprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //省略  } } 我们在创建一个对象时，追源码进去，可以看到在加载类时会有一个方法使用了synchronized锁。正因如此，才能保证某个类在内存中只有一份Class对象。\n  如果直接使用类的静态属性，也会导致类的加载\n 类加载阶段的深入理解见JVM类加载的深入理解\n     通过反射获取类的结构信息   基于java.lang.Class的API\n getName()：获取全类名。 getSimpleName()：获取简单类名 getFields()：获取所有public修饰的属性，包含本类以及父类（包含Object）的 getDeclaredField()：获取本类中所有属性 getMethods()：获取所有public修饰的方法，包含本类以及父类的 getDeclaredMethods()：获取本类中所有方法 getConstructors()：获取本类所有public修饰的构造器。 getDeclaredConstructors()：获取本类中所有构造器 getPackage()：以Package形式返回包信息 getSuperClass()：以Class形式返回父类信息 getInterfaces()：以Class[]形式返回接口信息 getAnnotations()：以Annotation[]形式返回注解信息    基于java.lang.reflect.Field类的API\n  getModifiers()：以int形式返回修饰符**[说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16]**\n//如果有一个字段是有多个修饰符，则两个int相加 public static String name = \u0026#34;minster\u0026#34;; System.out.println(name,getModifiers()); 上面语句会输出9\n  getType()：以Class形式返回类型\n  getName()：返回属性名\n    基于java.lang.reflect.Method类的API\n getModifiers()：以int形式返回修饰符**[说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16]** getReturnType()：以Class形式获取返回类型 getName()：返回方法名 getParameterTypes()：以Class[]返回参数类型数组    通过反射创建对象   调用类中的public修饰的无参构造器\n  调用类中的指定构造器\n  Class相关方法\n  newInstance()：调用类中的无参构造器，获取对应类的对象\n  getConstructor(Class\u0026hellip;clazz)：根据参数列表，获取对应的public构造器对象\n  getDecalaredConstructor(Class\u0026hellip;clazz)：根据参数列表，获取对应的所有构造器\n    Constructor类相关方法\n setAccessible()：暴破 newInstance(Object\u0026hellip;obj)：调用构造器      案例演示\n 通过反射创建某类的对象，要求该类中必须有public的无参构造 通过调用某个特定构造器的方式，实现创建某个类的对象  创建User类\npackage com.reflection_; /** * @Author: minster * @Date: 2021/9/22 19:36 */ public class User { public String name = \u0026#34;minster\u0026#34;; public int age = 21; public User(){ } private User(String name){ this.name = name; } public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 创建实现类ReflectionInstance01\npackage com.reflection_; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /** * @Author: minster * @Date: 2021/9/22 19:36 */ public class ReflectionInstance01 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { String classPath = \u0026#34;com.reflection_.User\u0026#34;; Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); //1. 通过public的无参构造器创建实例  Object user1 = cls.newInstance(); System.out.println(user1); //2. 通过public的有参构造器创建实例  Constructor\u0026lt;?\u0026gt; constructor = cls.getConstructor(String.class, int.class); Object ming = constructor.newInstance(\u0026#34;ming\u0026#34;, 22); System.out.println(ming); //3. 通过非公有的有参构造器创建实例  Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); Object minster = declaredConstructor.newInstance(\u0026#34;minster\u0026#34;); System.out.println(minster); } } 运行上述代码，我们发现方法1,2都能正常运行，但是方法3却报异常。\n因为我们通过getDeclaredConstructor(String.class);获取到的构造器是private的，所以我们在24行访问时会报出IllegalAccessException异常！\n此时我们可以使用暴破法来解决这个问题\n//3. 通过非公有的有参构造器创建实例 //因为要获取的构造方法为私有的，所以获取到的declaredConstructor也是私有的！ Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); //暴破（暴力破解，可以使用反射访问private构造器/方法/属性）！ declaredConstructor.setAccessible(true); Object minster = declaredConstructor.newInstance(\u0026#34;minster\u0026#34;); System.out.println(minster); 使用java.lang.reflection.Constructor的setAccessible方法可以解决这个问题！\n 任何封装的属性在反射面前都是纸老虎！使用暴破可以使反射访问到private构造器/方法/属性\n   注意：当使用反射访问静态成员或静态方法时，访问的参数可以写成null。（因为静态成员或静态方法属于整个类的属性！）\nStudent类\nclass Student{ private static String name; public static String m1(String name){ System.out.println(\u0026#34;hi\u0026#34;); } } Reflection04类\npackage com.reflection_; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @Author: minster * @Date: 2021/9/23 9:44 */ public class Reflection04 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException { String classPath = \u0026#34;com.reflection_.Student\u0026#34;; Class\u0026lt;?\u0026gt; studentClass = Class.forName(classPath); Object o = studentClass.newInstance(); Field name = studentClass.getDeclaredField(\u0026#34;name\u0026#34;); //name为私有字段，需要暴破！  name.setAccessible(true); //给name字段赋值，指定对象为null，因为name字段为static字段  name.set(null,\u0026#34;minster\u0026#34;); //获取name字段的值  System.out.println(name.get(null)); Method declaredMethod = studentClass.getDeclaredMethod(\u0026#34;m1\u0026#34;); //因为m1方法属于静态方法，所以可以使用null对象来调用它  Object o1 = declaredMethod.invoke(null); System.out.println(o1); } } 在反射中，如果方法有返回值，统一返回Object！\n  练习   利用反射创建文件\npackage com.reflection_.homework; import java.io.File; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @Author: minster * @Date: 2021/9/23 10:33 */ public class HomeWork02 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u0026lt;?\u0026gt; fileClass = Class.forName(\u0026#34;java.io.File\u0026#34;); Constructor\u0026lt;?\u0026gt;[] declaredConstructor = fileClass.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructor) { System.out.println(\u0026#34;File的构造器有：\u0026#34;+constructor); } Constructor\u0026lt;?\u0026gt; declaredConstructor1 = fileClass.getDeclaredConstructor(String.class); Method createNewFile = fileClass.getMethod(\u0026#34;createNewFile\u0026#34;); String allPath = \u0026#34;e:\\\\mynew.txt\u0026#34;; Object file = declaredConstructor1.newInstance(allPath); createNewFile.invoke(file); } }   ","date":"2021-09-05T16:22:25+08:00","permalink":"https://minster77.github.io/p/reflection/","title":"Reflection"},{"content":"静态代理模式  间接的“美” 中国人是一个含蓄的民族，讲究微妙和间接的交流方式。对象间的间接通信也同样是面向对象设计中一条重要的审美观。间接性的通信可以给出较低的耦合关系，较强的合作关系，以及微妙的结构和易于复用的设计架构。 \u0026mdash;-\u0026laquo;Java与模式\u0026raquo;\n   代理模式的定义\n​\t代理模式的英文叫Proxy或Surrogate。所谓代理就是指一个人或者一个机构代表另一个人或者另一个机构行动。有一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。\n  意图\n​\t为其他对象提供一种代理以控制对这个对象的访问。\n  代理模式的结构\n 抽象主题角色（接口）：声明了正是主题和代理主题的共同接口。这样一来任何使用真是主题的地方都可以使用代理主题。 代理主题（Peoxy）角色（代理类）：代理主题角色内部含有一个对真实主题角色的引用。从而可以在任何时候操作真实主体对象；代理主题角色提供一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题；控制对真实主题的引用，负责在需要的时候创建真实主题对象（或删除真实主题对象）；代理主题通常在客户端调用真实主题之前或之后都要执行某个操作，而不是单纯将调用传给真实主题。 真实主题角色（被代理类）：定义了代理角色所代表的真实对象。    静态代理\n​\t由程序员创建或特定工具自动生成源码，也就是说在编译时就已经将接口，被代理类，代理类等确定了下来。在程序运行之前，代理类的.class文件就已经生成。\n  静态代理简单实现\n​\t假设现在jack要结婚，jack把他的婚礼包办给了婚礼公司，在这个案例中，我们可以知道抽象主题角色便是婚礼（结婚），然后代理主题角色是婚礼公司，真实主题角色是jack。\n​\t首先，我们创建一个Marry接口。这个接口就是jack（被代理类）和婚礼公司（代理类）的公共接口，他们都有举办婚礼的行为。这样，jack的婚礼就可以让婚礼公司来代理执行。\n创建接口Marry\ninterface Marry{ void HoldWedding(); } 创建被代理类Customer\nclass Customer implements Marry{ @Override public void HoldWedding() { System.out.println(\u0026#34;我是jack，我结婚了！\u0026#34;); } } 创建代理类WeddingCompany\nclass WeddingCompany implements Marry{ private Customer customer; public WeddingCompany(Customer customer){ this.customer = customer; } @Override public void HoldWedding() { before(); this.customer.HoldWedding(); after(); } private void before() { System.out.println(\u0026#34;结婚之前，布置场地\u0026#34;); } private void after(){ System.out.println(\u0026#34;结婚之后，收尾款\u0026#34;); } } 创建测试类StaticProxy\npackage com.polymorphic; public class StaticProxy { public static void main(String[] args) { Marry marry = new WeddingCompany(new Customer()); marry.HoldWedding(); } } 运行结果\n  总结\n 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 代理对象可以做很多真实对象做不了的事情 真实对象可以专注自己的事情    而在通过Runnable接口创建线程时，启动线程需要借助Thread类，这里就涉及到了静态代理模式。\nMarry marry = new WeddingCompany(new Customer()); marry.HoldWedding(); //如果我们把上述代码简写一下 new WeddingCompany(new Customer()).HoldWedding(); //对照Runnable接口创建线程时，启动线程的方法 new Thread(new TestThread()).start(); 可以发现上面代码块的第四行与第六行有异曲同声的美妙！\n  ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"Java静态代理模式"},{"content":"MySQL（一）   MySQL的基本介绍 MySQL的基本使用 增删改查 约束   MySQL的基本介绍   sql、DB、DBMS分别是什么，他们之间的关系？\nDB：DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）\nDBMS：DataBase Management System（数据库管理系统，常见的有：MySQL、Oracle、DB2、Sybase、SqlServer\u0026hellip;）\nSQL：结构化查询语言，是一门标准通用的语言。标准的SQL适合于所有的数据库产品。SQL属于高级语言。SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DNMS完成）\n DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据\n   什么是表？\n  表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。\n  一个表包括行和列：\n 行：被称为数据/记录（data） 列：被称为字段（column）每一个字段包括字段名、数据类型、相关的约束      学习MySQL主要还是学习通用的SQL语句，那么SQL语句包括增删改查，SQL语句怎么分类？\n DQL（数据查询语言）：查询语句，凡是select语句都是DQL。 DML（数据操作语言）：insert(增加)、delete(删除)、update(修改)，对表当中数据进行增删改。 DDL（数据定义语言）：create(增加)、drop(删除)、alter(修改) ，对表结构的增删改。 TCL（事务控制语言）：commit提交事务、rollback回滚事务 DCL（数据控制语言）：grant授权、revoke撤销权限等。    当因为sql脚本中的数据量太大的而无法打开的时候，可以使用source。\n  MySQL的基本使用 MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格：\n 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\\物的方法, 键的值在当前列中具有唯一性。  登录数据库 mysql-h127.0.0.1-u用户名-pmysql-D所选择的数据库名-h主机名-u用户名-pmysql\u0026gt;exit# 退出 使用 “quit;” 或 “\\q;” 一样的效果 mysql\u0026gt;status;# 显示当前mysql的version的各种信息 mysql\u0026gt;selectversion();# 显示当前mysql的version信息 mysql\u0026gt;showglobalvariableslike\u0026#39;port\u0026#39;;# 查看MySQL端口号 创建数据库 对于表的操作需要先进入库use 库名;\n-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbk createdatabasesamp_dbcharactersetgbk;dropdatabasesamp_db;-- 删除 库名为samp_db的库 showdatabases;-- 显示数据库列表。 usesamp_db;-- 选择创建的数据库samp_db showtables;-- 显示samp_db下面所有的表名字 describe表名;-- 显示数据表的结构(缩写为desc) deletefrom表名;-- 清空表中记录 创建数据库表  使用 create table 语句可完成对表的创建, create table 的常见形式: 语法：create table 表名称(列声明);\n -- 如果数据库中存在user_accounts表，就把它从数据库中drop掉 DROPTABLEIFEXISTS`user_accounts`;CREATETABLE`user_accounts`(`id`int(100)unsignedNOTNULLAUTO_INCREMENTprimarykey,`password`varchar(32)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;用户密码\u0026#39;,`reset_password`tinyint(32)NOTNULLDEFAULT0COMMENT\u0026#39;用户类型：0－不需要重置密码；1-需要重置密码\u0026#39;,`mobile`varchar(20)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;手机\u0026#39;,`create_at`timestamp(6)NOTNULLDEFAULTCURRENT_TIMESTAMP(6),`update_at`timestamp(6)NOTNULLDEFAULTCURRENT_TIMESTAMP(6)ONUPDATECURRENT_TIMESTAMP(6),-- 创建唯一索引，不允许重复 UNIQUEINDEXidx_user_mobile(`mobile`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT=\u0026#39;用户表信息\u0026#39;;数据类型的属性解释\n NULL：数据列可包含NULL值； NOT NULL：数据列不允许包含NULL值； DEFAULT：默认值； PRIMARY：KEY 主键； AUTO_INCREMENT：自动递增，适用于整数类型； UNSIGNED：是指数值类型只能为正数； CHARACTER SET name：指定一个字符集； COMMENT：对表或者字段说明；  需要注意的是，创建的时候字段名字需要用**``**来标记，而非**‘ ’**\n增删改查 SELECT  SELECT 语句用于从表中选取数据。 语法：SELECT 列名称 FROM 表名称 语法：SELECT * FROM 表名称\n 单表查询   简单查询\n-- 查看当前数据库版本 selectversion();-- 查看当前使用的是哪个数据库 selectdatabase();-- 查询单个字段 select字段名from表名；-- 查询多个字段（使用逗号隔开） selectdeptno,dnameformdept;-- 查询所有字段 select*fromdept;-- 实际开发中不建议； selecta,b,c,d...fromdept;-- 给查询的列起别名，as关键字可以省略 SELECTdeptno,dnameASdeptnameFROMdept;SELECTdeptno,dnamedeptnameFROMdept;-- 倘若别名中有空格，则用单引号括起来 SELECTdeptno,dname\u0026#39;dept name\u0026#39;FROMdept;-- 字段可以使用数学表达式！ SELECTename,sal*12ASyearsalFROMemp;  条件查询\n不是将表中所有数据都查出来。是查询出来符合条件的。\n-- 语法格式： select字段1,字段2,字段3....from表名where条件;-- = 等 SELECTempno,enameFROMempWHEREsal=800;-- !=或\u0026lt;\u0026gt;不等于 SELECTename,empnoFROMempWHEREsal!=800;SELECTename,empnoFROMempWHEREsal\u0026lt;\u0026gt;800;-- \u0026lt; 小于 \u0026gt; 大于 \u0026lt;= 小于等于 \u0026gt;= 大于等于 SELECTename,empnoFROMempWHEREsal\u0026lt;2000;SELECTename,empnoFROMempWHEREsal\u0026lt;=2000;SELECTename,empnoFROMempWHEREsal\u0026gt;2000;SELECTename,empnoFROMempWHEREsal\u0026gt;=2000;-- between ... and ...,查询两个值之间 使用between...and... 必须左小右大，且为闭区间！ SELECTename,empno,salFROMempWHEREsalBETWEEN2450AND3000;-- 等价于 SELECTename,empno,salFROMempWHEREsal\u0026gt;=2450ANDsal\u0026lt;=3000;-- is null 为 null（is not null 不为空）在数据库中null不能使用=衡量！ SELECTename,empno,salcommFROMempWHEREcommISNULL;SELECTename,empno,salcommFROMempWHEREcommISNOTNULL;-- AND-\u0026gt;并且 OR-\u0026gt;或者 AND的优先级高于OR。如需OR先执行，需要加小括号 SELECT*FROMempWHEREsal\u0026gt;2500AND(deptno=10ORdeptno=20);-- IN 包含相当于多个OR。NOT IN 不包含 SELECTempno,ename,jobFROMempWHEREJOBIN(\u0026#39;MANAGER\u0026#39;,\u0026#39;SALESMAN\u0026#39;);like 称为模糊查询，支持%或下划线匹配\n %匹配任意多个字符 下划线：任意一个字符。（%是一个特殊的符号，_ 也是一个特殊符号）  -- 找出含有O的名字 SELECTenameFROMempWHEREenameLIKE\u0026#39;%O%\u0026#39;;-- 找出第二个字母为O的名字 SELECTenameFROMempWHEREenameLIKE\u0026#39;_O%\u0026#39;;-- 找出名字中含有下划线的 用\\转义 SELECTenameFROMempWHEREenameLIKE\u0026#39;%\\_%\u0026#39;;  排序查询\n ORDER BY : 升序排序，默认\nORDER BY \u0026hellip; desc;：指定降序排序\nORDER BY \u0026hellip; asc;：指定升序排序\n -- 默认排序查询 SELECTename,salFROMempORDERBYsal;-- 指定降序排序 SELECTename,salFROMempORDERBYsaldesc;-- 指定升序排序 SELECTename,salFROMempORDERBYsalasc;-- 按多个字段进行排序 SELECTename,salFROMempORDERBYsalasc,enamedesc;-- sal在前，起主导，只有当sal相等时才会启用ename比较 综合案例：找出工资在1250到3000之间的员工信息，要求按照薪资降序排列。\nSELECT*FROMempWHEREsalBETWEEN1250AND3000ORDERBYsalDESC; 以上执行顺序必须掌握！排序总是在最后！\n   数据处理函数\n  数据处理函数又被称为单行处理函数\n  单行处理函数的特点：一个输入对应一个输出。\n  和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）\n    常见的单行处理函数\n  Lower\t转换小写\nSELECTLOWER(ename)ASenameFROMemp;  upper\t转换大写\nSELECTUPPER(ename)ASenameFROMemp;  substr\t取子串（substr(被截取的字符串,起始下标(从1开始),截取的长度)）\nSELECTSUBSTR(ename,1,1)ASenameFROMemp;  length\t取长度\nSELECTLENGTH(ename)enamelengthFROMemp;  trim\t去空格,可以去前后空白\nSELECT*FROMempWHEREename=trim(\u0026#39; KING\u0026#39;)  str_to_date\t将字符串转换成日期\n  date_format\t格式化日期\n  format\t设置千分位\n  round\t四舍五入\n-- 生成100以内的随机整数 SELECTROUND(RAND()*100,0)FROMemp;  rand()\t生成随机数\nSELECTRAND()FROMemp;  Ifnull\t可以将null转换成一个具体值\n ifnull是空处理函数，专门处理null的。 在所有的数据库中，null只要参与运算，最终结果一定是null。\n需要使用ifnull函数处理，用法：\nifnull(数据，替换值)\n -- 计算年薪的时候，把补贴为null的值替换成0，这样子就可以避免最后算出来的年薪为null SELECTename,(sal+IFNULL(comm,0))*12ASyearsalFROMemp;  concat函数进行字符串的拼接\nSELECTCONCAT(ename,empno)FROMemp;  case..when..then..when..then..else..end\n当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常。 （注意：不修改数据库，只是将查询结果显示为工资上调）\nSELECTename,job,salASoldsal,(CASEJOBWHEN\u0026#39;MANAGER\u0026#39;THENsal*1.1WHEN\u0026#39;SALESMAN\u0026#39;THENsal*1.5ELSEsalEND)ASnewsalFROMemp;      分组函数（多行处理函数）\n 分组函数在使用时必须进行分组才能使用。 如果没有对数据进行分组，那么整张表就会默认为一组    count 计数\nSELECTCOUNT(sal)FROMemp;  sum 求和\nSELECTSUM(sal)FROMemp;  avg 平均值\nSELECTavg(sal)FROMemp;  max 最大值\nSELECTMAX(sal)FROMemp;  min 最小值\nSELECTMIN(sal)FROMemp;    分组函数需要注意的点：\n  分组函数自动处理null，使用时不需要对null进行处理\nSELECTCOUNT(comm)AScommFROMemp;  count(具体字段)：表示统计该字段下所有不为null的元素总数\n  count * ：统计表当中的总行数。只要有一行数据count就++。\n  分组函数不能直接使用在where子句中。\n  所有分组函数都可以组合起来用。\n      分组查询\n sql语句各关键字的执行顺序：FROM-\u0026gt;WHERE-\u0026gt;GROUP BY-\u0026gt;SELECT-\u0026gt;ORDER BY\n ​\t由上面的执行顺序，我们可以知道为什么分组函数不能直接使用在where子句中；因为sql语句在执行的时候，select在group by后面，所以**SELECT MIN(sal) FROM emp;可以正常执行，但SELECT ename FROM emp WHERE sal \u0026gt;(sal);（WHERE在group by前面，还没分组）**却会报错。\n-- 找出每个工作岗位的工资和 SELECTSUM(sal)FROMempGROUPBYJOB; ​\t在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数！其他字段或函数一律不能写在select后面\n 使用Having可以对分完组之后的数据做进一步的过滤（having与group by配套使用）\n-- 找出每个部门最高薪资，要求显示最高薪资大于3000的 SELECTdeptno,MAX(sal)FROMempGROUPBYdeptnoHAVINGMAX(sal)\u0026gt;3000;优化策略：where与having都可以解决的问题，优先使用where\nSELECTdeptno,MAX(sal)FROMempWHEREsal\u0026gt;3000GROUPBYdeptno;这样子可以先选出符合要求的数据再进行分组，优化了执行效率。\n不能使用where的情况\n-- 找出每个部门平均薪资，要求显示平均薪资高于2500的SELECT deptno,AVG(sal)FROM empGROUP BY deptnoHAVING AVG(sal)\u0026gt;2500; 因为上述要求的是平均薪资，即为AVG(sal)，而where后面不能跟分组函数，所以where无法解决上述问题，只能使用having\n  单表查询总结\n当我们需要从某张表中查询数据，需要先经过where条件筛选出有价值的数据，再对这些有价值的数据进行分组。分组之后可以使用having 继续筛选，然后select查询出来，最后排序输出。\n练习：找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，要求按照平均薪资降序排序。\nSELECTjob,AVG(sal)ASavgsalFROMempWHEREjob!=\u0026#39;MANAGER\u0026#39;GROUPBYjobHAVINGavgsal\u0026gt;1500ORDERBYavgsalDESC;  DISTINCT关键字\n DISTINCT关键字可以把查询结果去除重复的记录（原表数据不会被修改）。\n   作用于单列\n-- 查询工作岗位类型 selectDISTINCTjobFROMemp;  作用于多列\nSELECTDISTINCTdeptno,jobFROMemp;上述语句是同时作用在**“deptno+job”**上面的，实际上是根据**“deptno+job”**实现去重。即同一部门同一岗位的信息去掉。\n  需要注意的是DISTINCT只能出现在所有的字段的最前方。\n  count+distinct使用\n    多表查询   什么是多表查询（连接查询）\n从一张表中单独查询，称为单表查询。 emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。 这种跨表查询，多张表联合起来查询数据，被称为连接查询。\n  连接查询的分类\n  根据语法的年代分类： SQL92：1992年的时候出现的语法 SQL99：1999年的时候出现的语法 我们这里重点学习SQL99.(这个过程中简单演示一个SQL92的例子)\n  根据表连接的方式分类：\n  内连接：\n  等值连接\n-- SQL92语法 SELECTe.ename,d.dnameFROMempe,deptdWHEREe.deptno=d.deptno;-- SQL99语法 SELECTe.ename,d.dnameFROMempe(INNER)JOIN-- INNER可以省略，但带着INNER可读性更好！ deptdONe.deptno=d.deptnoWHERE\u0026#39;筛选条件\u0026#39;; sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。\nsql99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where\n   非等值连接\n条件不是一个等量关系，称为非等值连接。\n-- 找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级 SELECTe.ename,e.sal,s.gradeFROMempeJOINsalgradesONe.salBETWEENs.losalANDs.hisalORDERBYgrade;  自连接\n一张表看作两张表来用\n-- 查询员工的上级领导，要求显示员工名和对应的领导名 SELECTa.enameAS\u0026#39;员工名\u0026#39;,b.enameAS\u0026#39;领导名\u0026#39;FROMempaJOINempbONa.mgr=b.empno;      外连接：\n 外连接就是在内连接的基础上，在JOIN的左边加上一个关键字RIGHT或LEFT。\nRIGHT/LEFT代表什么：表示将join关键字右/左边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左/右边的表。在外连接当中，两张表连接，产生了主次关系。\n   左外连接（左连接）\nSELECTa.enameAS\u0026#39;员工名\u0026#39;,b.enameAS\u0026#39;领导名\u0026#39;FROMempaLEFTJOINempbONa.mgr=b.empno;  右外连接（右连接）\nSELECTa.enameAS\u0026#39;员工名\u0026#39;,b.enameAS\u0026#39;领导名\u0026#39;FROMempaRIGHTJOINempbONa.mgr=b.empno;  全连接（不常用）\n  注意：外连接的查询结果条数一定是大于或等于内连接的查询结果条数\n     当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（笛卡尔发现的，这是一个数学现象。）\n 注意：通过笛卡尔积现象可以得出表的连接次数越多效率越低，所以要尽量避免表的连接次数。\n实现案例：查询每个员工所在部门名称演示多表查询（避免笛卡尔乘积）\nSELECTename,dnameFROMemp,deptWHEREemp.DEPTNO=dept.DEPTNO;给表起别名，优化效率：\n-- SQL92语法 SELECTe.ename,d.dnameFROMempe,deptdWHEREe.deptno=d.deptno;多张表的连接查询\n三张表，四张表怎么连接？\nselect...fromajoinbona和b的连接条件joincona和c的连接条件rightjoindona和d的连接条件一条SQL中内连接和外连接可以混合。都可以出现！\n  子查询\nselect语句中嵌套select语句，被嵌套的select语句称为子查询。\n  子查询可以出现在那些地方\nselect..(select).from..(select).where..(select).  where子句中的子查询\n-- 找出比最低工资高的员工姓名和工资 SELECTename,salFROMempWHERE(SELECTMIN(sal)FROMemp);  from子句中的子查询\n注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。\n案例：找出每个岗位的平均工资的薪资等级\n第一步：先把每个岗位的平均薪资查询出来\nSELECTJOB,AVG(sal)ASavgsalFROMempGROUPBYJOB第二步：把以上的查询结果就当做一张真实存在的表t让t表和s表进行表连接，条件：t表avg(sal) between s.losal and s.hisal;\nSELECTt.*,s.gradeFROM(SELECTJOB,AVG(sal)ASavgsalFROMempGROUPBYJOB)tJOINsalgradesONt.avgsalBETWEENs.`LOSAL`ANDs.`HISAL`;查询结果：\n  select后面出现的子查询\n-- 找出每个员工的部门名称，要求显示员工名，部门名 selecte.ename,e.deptno,(selectd.dnamefromdeptdwheree.deptno=d.deptno)asdnamefromempe;  注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果\n    union合并结果集\n-- 查询工作岗位是MANAGER和SALESMAN的员工 -- 使用表连接查询 SELECTename,jobFROMempWHEREjob=\u0026#39;MANAGER\u0026#39;ORjob=\u0026#39;SALESMAN\u0026#39;;-- 使用union查询 SELECTename,jobFROMempWHEREjob=\u0026#39;MANAGER\u0026#39;UNIONSELECTename,jobFROMempWHEREjob=\u0026#39;SALESMAN\u0026#39;;union的效率要高一些。对于表连接来说，每连接一次新表，每次匹配的次数满足笛卡尔积都会翻倍；但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。\nunion在使用的时候的注意事项：\n union在进行结果集合并的时候，要求两个结果集的列数相同 在MySQL中，允许结果集合并时列和列的数据类型不一致。但Oracle结果集合并时列和列的数据类型要一致。    limit：将查询结果集的一部分取出来。通常使用在分页查询当中。\n分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。\n-- 按照薪资降序，取出排名在第【5-9】名的员工 SELECTename,salFROMempORDERBYsalDESCLIMIT4,5;limit语法：\n 完整用法：limit startIndex, length startIndex是偏移量（起始下标），length是需要取出的数据长度。起始下标从0开始\n省略用法：limit 5；取出0-5个数据\nlimit在order by之后执行\n 在Java中，若我们需要每页显示pageSize条记录，会有下面的公式\n limit (pageNo-1)*pageSize , pageSize;\t其中pageNo是页码\n   DQL语句的执行顺序\n1.from2.where3.groupby4.having5.select6.orderby7.limit..  CREATE   表的创建（建表属于DDL语句，DDL包括：create drop alter）\n语法：\ncreatetable表名(字段名1数据类型,字段名2数据类型,字段名3数据类型);createtable表名(字段名1数据类型,字段名2数据类型,字段名3数据类型);表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。 字段名：见名知意。 表名和字段名都属于标识符。\n  mysql中的数据类型：\n  varchar(最长255)：可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。 优点：节省空间 缺点：需要动态分配空间，速度慢\n  char(最长255)：定长字符串，不管实际的数据长度是多少。分配固定长度的空间去存储数据。使用不恰当的时候，可能会导致空间的浪费。\n优点：不需要动态分配空间，速度快。 缺点：使用不当可能会导致空间的浪费。\n  int(最长11)：数字中的整数型。等同于java的int\n  bigint：数字中的长整型。等同于java中的long。\n  float：单精度浮点型数据\n  double：双精度浮点型数据\n  date：短日期类型\n  datetime：长日期类型\n  clob：字符大对象，最多可以存储4G的字符串。超过255个字符的都要采用CLOB字符大对象来存储。\n  blob：二进制大对象。专门用来存储图片、声音、视频等流媒体数据。\n    创建表与增加数据\n创建表\nCREATETABLEt_student(NOINT,NAMEVARCHAR(32),sexCHAR(1),ageINT(3),emailVARCHAR(255));增加数据\n-- 注意字段名要和值一一对应。即数量对应，数据类型对应。 INSERTINTOt_student(NO,NAME,sex,age,email)VALUES(1,\u0026#39;张三\u0026#39;,\u0026#39;男\u0026#39;,20,\u0026#39;123456@qq.com\u0026#39;);-- 顺序可以不一样 INSERTINTOt_student(email,NAME,sex,age,NO)VALUES(\u0026#39;lisi@123.com\u0026#39;,\u0026#39;lisi\u0026#39;,\u0026#39;f\u0026#39;,20,2);-- INSERT可以添加单个字段。没添加到的字段默认值为null INSERTINTOt_student(NO)VALUES(3);-- 如果添加时省略所有字段名，则说明添加全部字段名 insertintot_studentvalues(4);-- 错误的 insertintot_studentvalues(4,\u0026#39;xiaoming\u0026#39;,\u0026#39;f\u0026#39;,21,\u0026#39;ming@123.com\u0026#39;);-- 需要把其他值也添加上 INSERT添加日期\n-- t_user表中的birth为date属性。 INSERTINTOt_user(id,name,birth)VALUES(1,\u0026#39;jack\u0026#39;,STR_TO_DATE(\u0026#39;01-10-1990\u0026#39;,\u0026#39;%d-%m-%Y\u0026#39;)); str_to_date函数可以将字符串转换成日期类型date。通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，需要通过该函数将字符串转换成date\nmysql的日期格式：%Y -\u0026gt; 年，%m -\u0026gt; 月，%d -\u0026gt; 日，%h -\u0026gt; 时，%i -\u0026gt; 分，%s -\u0026gt; 秒\n -- 这个函数可以将日期类型转换成特定格式的字符串。 selectid,name,date_format(birth,\u0026#39;%Y/%m/%d\u0026#39;)asbirthfromt_user; date_format(日期类型数据, \u0026lsquo;日期格式\u0026rsquo;)；这个函数通常使用在查询日期方面。设置展示的日期格式\n   date和datetime两个类型的区别\n date是短日期：只包括月日信息。mysql短日期默认格式：%Y-%m-%d datetime是长日期：包括年月日时分秒信息。mysql长日期默认格式：%Y-%m-%d %h:%i:%s  now() 函数可以获取系统当前的时间，获取到的信息带有：时分秒信息！是datetime类型的。\n-- 在表t_user中增加一个字段create——time ALTERTABLEt_userADDcreate_timeDATETIME;  INSERT插入多条数据\ninsertintot_user(id,name,birth,create_time)values(1,\u0026#39;zs\u0026#39;,\u0026#39;1980-10-11\u0026#39;,now()),(2,\u0026#39;lisi\u0026#39;,\u0026#39;1981-10-11\u0026#39;,now()),(3,\u0026#39;wangwu\u0026#39;,\u0026#39;1982-10-11\u0026#39;,now());  将查询结果插入到一张表当中\ncreatetabledept_bakasselect*fromdept;insertintodept_bakselect*fromdept;  UPDATE   语法格式：update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3... where 条件;\n注意：没有条件限制会导致所有数据全部更新。\n-- 更新t_user表中id=1的数据 UPDATEt_userSETNAME=\u0026#39;mary\u0026#39;,birth=\u0026#39;2000-10-1\u0026#39;,create_time=NOW()WHEREid=1;  DELETE   删除表中的数据\n语法格式：delete from 表名 where 条件;\n注意：没有条件，整张表的数据会全部删除！\n-- 删除t_user表中 id为2的数据 deletefromt_userwhereid=2;  删除表：\n-- 这不是删除表中的数据，这是把表删除。 droptablet_user;  快速删除表中的数据\n传统删除表中的数据是使用delete语句，其原理如下\n 表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！\n缺点是：删除效率比较低。\n优点是：支持回滚，后悔了可以再恢复数据！！！(使用rollback)\n 快速删除表中的数据使用truncate语句，其原理如下：\n 语法：truncate table dept_bak;\n删除效率比较高，表被一次截断（删除表中的所有数据），物理删除。\n缺点：不支持回滚\n优点：快速删除表中的数据。\n   约束  常见的约束  非空约束，not null 唯一约束，unique 主键约束，primary key 外键约束，foreign key      非空约束（not null）\n非空约束，针对某个字段设置其值不为空，如：学生的姓名不能为空\ndroptableifexistst_student;CREATETABLEt_student(student_idINT(10),student_nameVARCHAR(20)NOTNULL,sexCHAR(2)DEFAULT\u0026#39;m\u0026#39;,birthdayDATE,emailVARCHAR(30),classes_idINT(3));插入数据\ninsertintot_student(student_id,birthday,email,classes_id)values(1002,\u0026#39;1988-01-01\u0026#39;,\u0026#39;qqq@163.com\u0026#39;,10);因为插入的数据没有插入student_name字段的值，所以系统会报错\nnot null只有列级约束，没有表级约束\n  唯一约束（unique）\n唯一性约束，它可以使某个字段的值不能重复，如：email 不能重复。\ndroptableifexistst_student;createtablet_student(student_idint(10),student_namevarchar(20)notnull,-- 非空约束 sexchar(2)default\u0026#39;m\u0026#39;,birthdaydate,emailvarchar(30)unique,-- 唯一约束 classes_idint(3));-- 联合唯一 createtablet_vip(vip_idint,vip_namevarchar(20),unique(vip_id,vip_name));上述联合唯一的unique(vip_id,vip_name)由于约束没有添加在列的后面，所以被称为表级约束。\nunique和not null联合使用\ncreatetablet_vip(idint,namevarchar(20)notnullunique-- 主键字段 );在mysql中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）\n  主键约束（primary key）\n每个表应该具有主键，主键可以标识记录的唯一性，主键分为单一主键和复合（联合）主键，单一主键是由一个字段\n构成的，复合（联合）主键是由多个字段构成的。\n 主键约束：就是一种约束 主键字段：该字段上添加了主键约束，这样的字段叫做主键字段 主键值：：主键字段中的每一个值都叫做主键值（建议使用int，bigint，char；不建议使用varchar）  droptableifexistst_student;createtablet_student(student_idint(10)primarykey,/*列级约束*/student_namevarchar(20)notnull,sexchar(2)default\u0026#39;m\u0026#39;,birthdaydate,emailvarchar(30),classes_idint(3));-- 复合主键 createtablet_vip(vip_idint,vip_namevarchar(20),primarykey(vip_id,vip_name));-- 实际开发中，不建议使用复合主键！ **注意：**每一张表都必须有主键，否则这张表无效。且一张表只能有一个主键\n 自然主键：主键值是一个自然数，和业务没有关系。 业务主键：主键值和业务紧密关联，例如银行卡账号做主键值。这就是业务主键   实际开发中，自然主键使用比较多，因为主键只要做到不重复就行，不需要任何意义。而主键一旦和业务挂钩，那么当业务发生变动的时候可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。\n auto_increment：表示自增，从1开始，以1递增，用于维护主键。\n  外键约束（foreign key）\n外键主要是维护表之间的关系的，主要是为了保证参照完整性，如果表中的某个字段为外键字段，那么该字段的值必须来源于参照的表的主键，如：emp 中的 deptno 值必须来源于 dept 表中的 deptno 字段值。\n 外键约束：就是一种约束 外键字段：该字段上添加了外键约束，这样的字段叫做外键字段 外键值：：外键字段中的每一个值都叫做外键值。外键值可以为null  建立学生和班级表之间的连接：\n首先建立班级表 t_classes\ndroptableifexistst_classes;createtablet_classes(classes_idint(3),classes_namevarchar(40),constraintpk_classes_idprimarykey(classes_id));然后创建表t_student\ndroptableifexistst_student;createtablet_student(student_idint(10),student_namevarchar(20),sexchar(2),birthdaydate,emailvarchar(30),classes_idint(3),constraintstudent_id_pkprimarykey(student_id),constraintfk_classes_idforeignkey(classes_id)referencest_classes(classes_id));注意：t_classes是父表，t_student是子表。\n 外键不一定是主键，但一定要有unique约束\n   ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/mysql%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"MySQL基本介绍与使用"},{"content":"MySQL（二）   存储引擎 事务 索引 备份与还原 视图   存储引擎 ​\t存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）；实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。\n  创建存储引擎\nCREATETABLE`t_student`(`student_id`intNOTNULL,`student_name`varchar(20)DEFAULTNULL,`sex`char(2)DEFAULTNULL,`birthday`dateDEFAULTNULL,`email`varchar(30)DEFAULTNULL,`classes_id`intDEFAULTNULL,PRIMARYKEY(`student_id`),KEY`fk_classes_id`(`classes_id`),CONSTRAINT`fk_classes_id`FOREIGNKEY(`classes_id`)REFERENCES`t_classes`(`classes_id`))ENGINE=InnoDBDEFAULTCHARSET=gbk-- ENGINE=InnoDB就是指定存储引擎 CHARSET是字符集  mysql默认的存储引擎是InnoDB。CHARSET默认的字符集是utf8\n   MySQL有哪些常用的存储引擎\nCMD下使用show engines\\G可以查看MySQL支持的存储引擎\n  MyISAM存储引擎 它管理的表具有以下特征： 使用三个文件表示每个表：\n 格式文件 — 存储表结构的定义（mytable.frm） 数据文件 — 存储表行的内容（mytable.MYD） 索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。 可被转换为压缩、只读表来节省空间   提示一下：对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引。\nMyISAM存储引擎特点：可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！\nMyISAM不支持事务机制，安全性低。\n   InnoDB存储引擎\n 这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。 InnoDB存储引擎最主要的特点是：非常安全。 它管理的表具有下列主要特征：  每个 InnoDB 表在数据库目录中以.frm 格式文件表示 InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名，表空间存储数据+索引。） 提供一组用来记录事务性活动的日志文件 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理 提供全 ACID 兼容 在 MySQL 服务器崩溃后提供自动恢复 多版本（MVCC）和行级锁定 支持外键及引用的完整性，包括级联删除和更新   InnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，不能很好的节省存储空间。    MEMORY存储引擎\n 使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定， 这两个特点使得 MEMORY 存储引擎非常快。 MEMORY 存储引擎管理的表具有下列特征：  在数据库目录内，每个表均以.frm 格式的文件表示。 表数据及索引被存储在内存中。（目的就是快，查询快！） 表级锁机制。 不能包含 TEXT 或 BLOB 字段。   MEMORY 存储引擎以前被称为HEAP 引擎。 MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。 MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。    MyISAM和InnoDB的区别\n​\t在MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。\n​\t虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。\n​\t5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。\n下面是两者的简单对比：\n  是否支持行级锁\nMyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(eow-level locking)和表级锁，默认为行级锁。\n也就是说，MyISAM一锁就锁住了整张表，这在并发写的时候会很蠢！！这也就是为什么InnoDB在并发写的时候，性能更加厉害了。\n  是否支持事务\nMyISAM不提供事务支持\nInnoDB提供事务支持，具有提交(commit)和回滚(rollback)事务的能力\n  是否支持外键\nMyISAM不支持，InnoDB支持\n 一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定\n   是否支持数据库异常崩溃后的安全恢复\nMyISAM不支持，InnoDB支持。\n使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于redo log 。\n  MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是可重复读 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。     是否支持 MVCC\nMyISAM 不支持，而 InnoDB 支持。\n讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。\nMVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。\n      锁机制与InnoDB锁算法\nMyISAM和InnoDB存储引擎使用的锁：\n MyISAM采用表级锁(table-level locking) InnoDB支持行级锁(row-level locking)  表级锁和行级锁对比：\n  表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。\n  行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。\n 锁粒度：所谓加锁粒度就是你要锁住的范围是多大。\n比如你在家上卫生间，你只要锁住卫生间就可以了吧，不需要将整个家都锁起来不让家人进门吧，卫生间就是你的加锁粒度。\n   InnoDB存储引擎的锁的算法有三种：\n Record lock：记录锁，单个行记录上的锁 Gap lock：间隙锁，锁定一个范围，不包括记录本身 Next-key lock：record+gap临键锁，锁定一个范围，包含记录本身    事务   什么是事务？\n事务其实就是一个完整的业务逻辑。\n 一个完整的业务逻辑：假设A向B转账1000；将A账户的钱减去1000；将B账户的钱增加1000。这就是一个完整的业务逻辑\n以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的\n 在本质上，一个事务其实就是多条DML语句同时成功或同时失败。\n  只有DML语句才会有事务，其他语句和事务无关。因为 只有insert、update、delete三个语句是数据库表中数据进行增、删、改的。只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。\n 事务是怎么做到多条DML语句同时成功和同时失败的\nInnoDB存储引擎：提供一组用来记录事务性活动的日志文件\n 在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。\n 在事务的执行过程中，我们可以提交事务，也可以回滚事务。\n演示事务的回滚操作\nmysql\u0026gt;usebjpowernodeDatabasechangedmysql\u0026gt;select*fromdept_bak;Emptyset(0.00sec)-- 开启事务 mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)-- 回滚操作 mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.30sec)mysql\u0026gt;select*fromdept_bak;Emptyset(0.00sec)演示事务的提交操作\nmysql\u0026gt;select*fromdept_bak;Emptyset(0.00sec)-- 开启事务 mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintodept_bak(deptno,dname,loc)values(10,\u0026#39;ming\u0026#39;,\u0026#39;guangzhou\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)-- 提交事务 mysql\u0026gt;commit;QueryOK,0rowsaffected(0.07sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromdept_bak;+--------+-------+-----------+|DEPTNO|DNAME|LOC|+--------+-------+-----------+|10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou||10|ming|guangzhou|+--------+-------+-----------+4rowsinset(0.00sec)由上面代码测试，我们可以知道\n commit：提交事务 rollback：回滚事务（回滚永远都是只能回滚带上一次的提交点！）   在mysql中，默认情况下是支持自动提交事物的（自动提交！），即没执行一条DML语句，则提交一次。\n这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条\n 使用start transaction可以把mysql的自动提交机制关闭掉\n  事务的三个特性\n 原子性：说明事务是最小的工作单元。不可再分。 一致性：所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。 隔离性：A事务和B事务之间具有一定的隔离。例如教室A和教室B之间有一道墙，这道墙就是隔离性。 持久性：事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上！    事物的隔离级别\n 读未提交：read uncommitted（最低的隔离级别）  事务A可以读取到事务B未提交的数据。 这种隔离级别存在的问题就是：脏读现象！(Dirty Read)；我们称读到了脏数据 这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是读已提交起步   读已提交：read committed  事务A只能读取到事务B提交之后的数据。 这种隔离级别解决了脏读的现象。 这种隔离级别存在不可重复读取数据的问题。 这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。 oracle数据库默认的隔离级别是：read committed   可重复读：repeatable read  事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。 解决了不可重复读取数据。 可重复读会出现幻读。每一次读取到的数据都是幻象。不够真实   序列化/串行化：serializable（最高的隔离级别）  这是最高隔离级别，效率最低。解决了所有的问题。 这种隔离级别表示事务排队，不能并发！与synchronized相似，线程同步（事务同步） 每一次读取到的数据都是最真实的，并且效率是最低的。     InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。\n——摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章\n 设置隔离级别：set global transaction isolation level read uncommitted;\n查看隔离级别：SELECT @@tx_isolation\n  索引   什么是索引\n索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。\n索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，也可以多个字段联合起来添加索引。\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。\n 对于一本字典来说，查找某个汉字有两种方式： 第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。效率比较低。 第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过索引检索，效率较高。\n   索引的底层数据结构\n  索引类型\n  主键索引(Primary Key)\n数据表的主键列使用的就是主键索引。\n一张数据表只能有一个主键，并且主键不能为null，不能重复。\n在Mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。\n  二级索引（辅助索引）\n二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位到主键的位置。\n唯一索引，普通索引，前缀索引等索引属于二级索引。\n 唯一索引(Unique K)：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。**建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率、 普通索引(Index)：普通索引的唯一作用就是快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。 **前缀索引(Prefix)：**前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建议的数据更小，因为只取几个字符。 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。  二级索引：\n    索引的优缺点\n优点：\n 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  缺点：\n 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。  但是，使用索引一定能提高查询性能吗?\n大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。\n  MySQL的查询方式\n 第一种方式：全表扫描（如果字段没有添加索引就是用全表扫描，效率低） 第二种方式：根据索引检索。   在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。\n遵循左小又大原则存放。采用中序遍历方式遍历取数据。\n   索引的实现原理\n假设现在有一张表t_user\nid(PK)name每一行记录在硬盘上都有物理存储编号------------------------------------------------------------------------ 100\tzhangsan\t0x1111 120lisi0x222299wangwu0x888888zhaoliu0x9999101jack0x666655lucy0x5555130tom0x7777提醒：\n 在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。 在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。 在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）  索引的简单实现原理：存放遵循左小右大原则\n注意：上图只是索引的实现原理的大概模型，事实上索引的实现原理远比上图复杂的多！\n  索引的创建和删除\n创建索引：\n-- 给emp表的ename字段添加索引，起名：emp_ename_index createindexemp_name_indexonemp(ename);删除索引：\n-- 将emp表上的emp_ename_index索引对象删除。 dropindexemp_name_indexonemp;mysql中查看一个SQL语句是否使用了索引检索\nexplainselect*fromempwhereename=\u0026#39;KING\u0026#39;;  需要添加索引的条件。\n 在mysql当中，主键上，以及unique字段上都会自动添加索引的\n  条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同） 条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。 条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）  建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。 建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。\n  索引失效\n  select * from emp where ename like '%T';ename上即使添加了索引，也不会走索引。原因是因为模糊匹配当中以“%”开头了！尽量避免模糊查询的时候以“%”开始。这是一种优化的手段/策略。\nexplainselect*fromempwhereenamelike\u0026#39;%T\u0026#39;;  使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会实现。所以这就是为什么不建议使用or的原因。\nexplainselect*fromempwhereename=\u0026#39;KING\u0026#39;orjob=\u0026#39;MANAGER\u0026#39;;  使用复合索引的时候，没有使用左侧的列查找，索引失效\n 两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。\n createindexemp_job_sal_indexonemp(job,sal);explainselect*fromempwheresal=800;  在where当中索引列参加了运算，索引失效。\ncreateindexemp_sal_indexonemp(sal);explainselect*fromempwheresal+1=800;  在where当中索引列使用了函数\nexplainselect*fromempwherelower(ename)=\u0026#39;smith\u0026#39;;    备份与还原 /* 备份与还原 */------------------ 备份，将数据的结构与表内数据保存起来。 利用mysqldump指令完成。-- 导出 mysqldump[options]db_name[tables]mysqldump[options]---databaseDB1[DB2DB3...]mysqldump[options]--all--database1.导出一张表mysqldump-u用户名-p密码库名表名\u0026gt;文件名(D:/a.sql)2.导出多张表mysqldump-u用户名-p密码库名表1表2表3\u0026gt;文件名(D:/a.sql)3.导出所有表mysqldump-u用户名-p密码库名\u0026gt;文件名(D:/a.sql)4.导出一个库mysqldump-u用户名-p密码--lock-all-tables--database库名\u0026gt;文件名(D:/a.sql)可以-w携带WHERE条件-- 导入 1.在登录mysql的情况下：source备份文件2.在不登录的情况下mysql-u用户名-p密码库名\u0026lt;备份文件视图   什么是视图\n​\t视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表并且在引用视图时动态生成。\n​\t视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n​\t视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n  ","date":"2021-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/mysql%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/","title":"MySQL的进阶使用"},{"content":"索引的底层数据结构 Hash表 哈希表是键值对的集合，通过键（key）即可快速取出对应的值（value），因此哈希表可以快速检索数据（时间复杂度接近O(1)）。\n为何能通过key快速取出value呢？原因在于哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到value对应的index值，找到了index也就找到了对应的value。\nhash = hashfunc(key); index = hash %array_size; 但是！哈希算法会有个Hash冲突问题，也就是说多个不同的key最后得到的index相同。通常情况下，我们会使用链地址法来解决这个问题。链地址法就是将哈希冲突数据存放在链表中。就比如JDK1.8之前HashMap就是通过链地址法来解决哈希冲突的。不过JDK1.8以后HashMap为了减少链表过长的时候搜索时间过长的问题，就引入了红黑树\n为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。\n既然哈希表这么快，为什么MySQL 没有使用其作为索引的数据结构呢？\n1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。\n2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。\n试想一种情况:\nSELECT*FROMtb1WHEREid\u0026lt;500;在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。\nB树\u0026amp;B+树 B树也成B-Tree，全称多路平衡查找树，B+树是B树的一种变体。B树和B+树中的B是Balanced（平衡）的意思\n目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。\nB-Tree B-Tree是为磁盘设备设计的一种平衡查找树。\n系统从磁盘读取数据到内存，是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性取出来，而不是需要什么取什么。\nInnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：\nshowvariableslike\u0026#39;innodb_page_size\u0026#39;;而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\n满足以下条件的，就是B-Tree\n根结点至少有两个子女 每一个结点最多包含K个孩子，K的大小取决于磁盘页的大小。\n模拟查找关键字29的过程：\n根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 在磁盘块8中的关键字列表中找到关键字29。\n​\t分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。\n​\t总结：说到底，B-Tree就是将原先一个结点只能存储一个值的情况，改为一个结点可以存储多个值，因为查找的时候，需要将数据从磁盘中读取到内存里面，一旦磁盘IO次数过多，就会造成查询缓慢，所以这里存储多个值，可以一次性读取相近的值，从而避免查询多次IO，将查询操作放到内存里面。内存执行效率可以忽略不计。\n​\t再简单说，举个例子，数据库有10条数据，id为1,2,3…10，以前要查询第10条，我查询数据库10次，然后for循环到第10条（对应二叉树）；现在不用了，现在我把1,2,3…10直接查出来，放到内存里面，直接从内存里面比较然后拿出来（对应B-Tree）\n​\t缺点： 结点中的数据，不仅存储了key，还存储了value值，而这些数据是存储在页中的，每一页为16KB，页存储的空间是有限的，所以有可能存在，每一个结点，只存储了一个key和value就存不下去了，也就是变成了二叉树的数据结构。深度一样，磁盘IO树也是一样了。所以又衍生出了B+Tree。\nB+Tree B+Tree是B-Tree的一种优化，更适合实现外存储索引结构，InnoDB就是用B+Tree实现索引结构。\n满足以下条件，就是B+Tree\n  非叶子结点，不保存数据，只保存索引；所有的数据都保存在叶子结点中\n  叶子结点中，保存所有数据的信息，及指向含这些元素记录的指针，并且叶子结点本身根据关键字的大小自小而大顺序链接，是一个链表结构。\n  每一个父结点的数据都出现在子结点中，是子结点的最大或最小元素 如查找元素3，B+Tree，因为没有非叶子结点没有存储数据，所以同样大小的磁盘页可以容纳更多的索引。\n  与B-Tree的比较\n 存储结构不一样，单一节点存储更多的元素，使得查询的IO次数更少 查找方式一致，所有查询都要查找到叶子节点，查询性能稳定 所有叶子节点形成有序链表，便于范围查询  数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。\n辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。\n在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）\n MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。\nInnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。\n 总结 B+Tree就是，将原先每一个非叶子结点存储的key，value这种结构，改为只存储key，然后叶子结点存储key，value，通过使用链接结构，上一个指针指向上一个值，下一个指针指向下一个值这种方式。\n","date":"2021-09-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"索引的底层数据结构"},{"content":"Java编程思想集合篇（二） Java HashMap为什么通过(n - 1) \u0026amp; hash 获取哈希桶数组下标？\n看过HashMap源码人应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，就是通过(n - 1) \u0026amp; hash来计算的，那么为什么用的是位运算而不是取模运算(hash % n)呢？\n获取hash桶数组下标源码\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 一. 位运算与取模运算时间比较\npackage com.polymorphic; public class Test { int a = 1; int number = 100000; // 数据集数量，初始定义为十万  // 位运算  public long bitwise() { long start = System.currentTimeMillis(); //从十万开始，一直到Integer的最大值，计算所需时间  for (int i = number; i \u0026gt; 0; i++) { a \u0026amp;= i; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\u0026#34;位运算时间为：\u0026#34; + time + \u0026#34;ms\u0026#34;); return time; } // 取模运算  public long module() { long start = System.currentTimeMillis(); for (int i = number; i \u0026gt; 0; i++) { a %= i; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\u0026#34;取模运算时间为：\u0026#34; + time + \u0026#34;ms\u0026#34;); return time; } public static void main(String[] args) { Test t = new Test(); t.bitwise(); t.module(); } } 运行结果为\n从测试结果我们可以看出，如果数据集足够的大，那么取模运算的时间将会是位运算时间的十几倍。这只是一方面，如果数据集足够大的话，HashMap的初始容量肯定不够，这也触发了HashMap的扩容机制。所以采用二进制位操作 \u0026amp;，相对于%能够提高运算效率\n二.位运算是如何保证索引不越界\n讲到这，我们也就要想想为什么HashMap的容量是2的n次幂？两者之间有着千丝万缕的联系。\n当 n 是2的次幂时， n - 1 通过 二进制表示即尾端一直都是以连续1的形式表示的。当(n - 1) 与 hash 做与运算时，会保留hash中 后 x 位的 1，这样就保证了索引值 不会超出数组长度。\n同时当n为2次幂时，会满足一个公式：(n - 1) \u0026amp; hash = hash % n。\n","date":"2021-08-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%BA%8C/","title":"Java编程思想集合篇（二）"},{"content":"Lamda表达式   Lambda表达式，可以称为闭包，它是推动Java8发动的最重要新特性\n  Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）\n  为什么要使用Lambda表达式\n 可以避免匿名内部类定义过多 可以让你的代码看起来更加简洁 去掉了一堆没有意义的代码，只留下核心的逻辑    基本语法\n(parameters)-\u0026gt;expression[表达式]; (parameters)-\u0026gt;statement[语句]; (parameters)-\u0026gt;{statement};   函数式接口（Functional Interface）是学习Lambda表达式的关键所在。其定义为：\n  任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。\npublic interface Runnable{ public abstract void run(); }   对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。\n    Lambda表达式的推导演示\n现在，我们有一个函数式接口LambdaInterface，它只有一个抽象方法我们该怎样实现他的方法并执行呢？\n  接口LambdaInterface\n//创建函数式接口 interface LambdaInterface { void lambda(); }     创建实现类去实现接口，再创建实现类的对象，调用该方法\n//1.创建实现类实现接口 class LambdaImp implements LambdaInterface { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda1\u0026#34;); } } main函数中调用\npublic static void main(String[] args) { LambdaInterface lambdaImp = new LambdaImp(); lambdaImp.lambda(); }   上述需要在外部写一个实现类，比较繁琐，我们简化一下用一个静态内部类实现。\n在TestLambda类中\n//2.静态内部类实现 static class LambdaImp2 implements LambdaInterface { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda2\u0026#34;); } } main函数中\nLambdaImp2 lambdaImp2 = new LambdaImp2(); lambdaImp2.lambda();   因为静态内部类的实现不能直接在main函数中写，我们可以继续简化，在main函数中写一个局部内部类实现接口\n//3.局部内部类实现 class LambdaImp3 implements LambdaInterface { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda3\u0026#34;); } } LambdaImp3 lambdaImp3 = new LambdaImp3(); lambdaImp3.lambda();   因为是使用局部内部类实现需要写方法名和继承的接口，所以我们继续简化，使用匿名内部类来实现接口\n//4.匿名内部类实现  lambdaImp = new LambdaInterface() { @Override public void lambda() { System.out.println(\u0026#34;I am Lambda4\u0026#34;); } }; lambdaImp.lambda();   倘若我们要继续简化下去，把一些接口、类和方法的声明都省略掉，仅保留核心代码。此时可以使用Lambda表达式来进行简化！\n//6.Lambda表达式简化实现 lambdaImp = ()-\u0026gt;{ System.out.println(\u0026#34;I am Lambda5\u0026#34;); }; lambdaImp.lambda(); 运行结果：\n​\t我们可以发现，步骤1到步骤5都能实现需求。而每一个步骤都可以做出一定的简化，从步骤1的外部类实现到使用Lambda表达式保留核心代码，使我们的代码更为的简洁了，这便是Lambda表达式的推导过程。\n    Lambda的简化\n创建接口LambdaInterface02\n//1.创建函数式接口 interface LambdaInterface02 { void lambda(int a); } 创建测试类TestLambda02\npackage com.lambda; public class TestLambda02 { public static void main(String[] args) { LambdaInterface02 lambdaInterface = null; //Lambda表达式  LambdaInterface02 lambda1 = (int a) -\u0026gt; { System.out.println(\u0026#34;I am Lambda\u0026#34;+a); }; lambda1.lambda(1); //简化1：去掉括号与类型  LambdaInterface02 lambda2 = a -\u0026gt; { System.out.println(\u0026#34;I am Lambda\u0026#34;+a); }; lambda1.lambda(2); //简化2：去掉花括号  LambdaInterface02 lambda3 = (int a) -\u0026gt; System.out.println(\u0026#34;I am Lambda\u0026#34;+a); lambda1.lambda(3); } }   总结\n  Lambda表达式只能有一行代码的情况下才能简化成为一行（去掉花括号），如果有多行代码，就需要用代码块包裹（花括号）\n  使用Lambda表达式的前提是接口为函数式接口\n  多个参数也可以去掉参数类型，但是需要把全部参数类型都去掉且必须加上小括号\nLambdaInterface02 lambda2 = (a,b) -\u0026gt; { System.out.println(\u0026#34;I am Lambda\u0026#34;+a+b); };     ","date":"2021-08-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"Lambda表达式"},{"content":"编译类型、运行类型及多态的区别 Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态。\n 因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋值给一个父类引用变量，无须任何转型，或者被称为向上转型，由系统自动完成。  测试代码\n  Father类\npackage com.polymorphic; public class Father { public Father(){ System.out.println(\u0026#34;Father的构造方法\u0026#34;); } public void doWork(){ System.out.println(\u0026#34;Father Do Work!\u0026#34;); } }   Son类\npackage com.polymorphic; public class Son extends Father{ public Son(){ System.out.println(\u0026#34;Son的构造方法\u0026#34;); } public void doWork(){ System.out.println(\u0026#34;Son Do Work!\u0026#34;); } }   Test类\npackage com.polymorphic; public class Test { public static void main(String[] args) { Father child = new Son(); son.doWork(); } }   运行结果\n在测试类中：\nFather child = new Son(); 在这里我们声明了一个Father的引用变量，指向了Son类的一个实例，我们可以得知child这个引用变量的Father类就是编译类型，而new Son()中的Son类就是运行类型。\n  由运行结果可知：程序在运行时，首先会调用父类的构造器，然后再调用子类的构造器，接下来：在编译过程中，就会自动检查引用变量child的编译类型中，是否包含doWork方法，很明显，在父类中有doWork方法（如果没有会报错），但是，在JVM运行时，由于在子类中覆盖了doWork方法，所以child实际运行时，是调用了子类的doWork方法，而不是父类的，这也就是多态的一种（运行时多态）。\n  什么是编译类型和运行类型呢？\n ​\t引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法（意思是说：编写代码时，只能调用父类中具有的方法，如果子类重写了该方法，运行时实际调用的是运行时类型的该方法。程序在编译时，会在编译类型中检查是否具有所调用的方法，如果编写代码时，使用引用变量调用子类中的特有方法，或者调用了重载父类中的方法，而父类中找不到该方法，则会编译报错），因此，编写Java代码时，引用变量只能调用声明该变量所用类里包含的方法。与方法不同的是，对象的属性则不具备多态性。通过引用变量来访问其包含的实例属性时，系统总是访问它编译时类所定义的属性，而不是它运行时所定义的属性(属性无多态，方法具有多态)。\n​\t要访问子类中特有的方法和属性，在编写代码时，必须进行类型转换。\n——以上摘自《疯狂Java讲义》\n   什么是多态？\n 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n 在测试类中：\n//编译时类型 引用变量 运行时类型  Father child = new Son(); 这行代码编译时类型和运行时类型不一致(父类引用指向子类)，同时Son继承了Father并且重写了Father的doWork方法，这就是所谓的多态。\n  代码演示方法具有多态，属性无多态\nClass A\npackage com.polymorphic; public class A { String a = \u0026#34;This is A!\u0026#34;; public String getString(){ return this.a; } } **Class B **\npackage com.polymorphic; public class B extends A{ String a = \u0026#34;This is B!\u0026#34;; public String getString(){ return this.b; } } Test\npackage com.polymorphic; public class Test { public static void main(String[] args) { A a1 = new A(); System.out.println(a1.getClass()+\u0026#34; \u0026#34;+a1.getString()+\u0026#34; \u0026#34;+a1.a); B b1 = new B(); System.out.println(b1.getClass()+\u0026#34; \u0026#34;+b1.getString()+\u0026#34; \u0026#34;+b1.a); a1 = b1; System.out.println(a1.getClass()+\u0026#34; \u0026#34;+a1.getString()+\u0026#34; \u0026#34;+a1.a); b1 = (B)a1; System.out.println(b1.getClass()+\u0026#34; \u0026#34;+b1.getString()+\u0026#34; \u0026#34;+b1.a); A a2 = new B(); System.out.println(a2.getClass()+\u0026#34; \u0026#34;+a2.getString()+\u0026#34; \u0026#34;+a2.a); } } 运行结果\n ​\t从这个结果可以看出类继承时，子类会覆盖与父类相同的属性。总结一点就是：对象访问变量看声明，访问方法看实际对象类型（new出来的类型）。也可以说：属性无多态，而方法具有多态。\n   ","date":"2021-06-28T16:22:25+08:00","permalink":"https://minster77.github.io/p/polymorphic/","title":"polymorphic"},{"content":"JavaIO流2   BufferedReader与BufferedWriter 使用字节流实现对二进制文件复制 对象流 标准输入输出流 转换流 打印流 Properties类   BufferedReader与BufferedWriter   BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的。\n  关闭处理流的时候，只需要关闭外层流即可\n演示bufferedReader的使用\npackage com.java_io; import java.io.BufferedReader; import java.io.FileReader; public class BufferedReaderTest { public static void main(String[] args) throws Exception{ String path = \u0026#34;E://note.txt\u0026#34;; //创建BufferedReader对象  BufferedReader bufferedReader = new BufferedReader(new FileReader(path)); //按行读取，提高效率  String line; /* * bufferedReader.readLine()是按行读取文件的 * 当返回null时，表示已读取完毕 */ while ((line =bufferedReader.readLine())!=null){ System.out.println(line); } bufferedReader.close(); } }   需要注意的是，关闭流时只需要关闭BufferedReader。因为底层会自动关闭节点流\n底层代码\npublic void close() throws IOException { synchronized (lock) { if (in == null) return; try { in.close(); } finally { in = null; cb = null; } } }   演示BufferedWriter\npackage com.java_io; import java.io.BufferedWriter; import java.io.FileWriter; public class BufferedWriterTest { public static void main(String[] args) throws Exception{ String path = \u0026#34;E://a.txt\u0026#34;; //创建对象，把FileWriter的Boolean值置为true可以实现追加功能  //默认为false，会覆盖原来的内容  BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(path,true)); bufferedWriter.write(\u0026#34;hello,成志恒\u0026#34;); //插入一个当前系统的换行符  bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;hello2,成志恒\u0026#34;); bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;hello3,成志恒\u0026#34;); bufferedWriter.newLine(); bufferedWriter.close(); } }   使用bufferd进行文件拷贝\npackage com.bufferd; import java.io.*; public class BufferedCopy_ { public static void main(String[] args) { String path1 = \u0026#34;e://a.txt\u0026#34;; String path2 = \u0026#34;e://a1.txt\u0026#34;; BufferedReader br = null; BufferedWriter bw = null; String line; try { br = new BufferedReader(new FileReader(path1)); bw = new BufferedWriter(new FileWriter(path2)); while ((line = br.readLine())!=null){ bw.write(line); bw.newLine(); } } catch (IOException e) { e.printStackTrace(); } finally { try { if(br != null){ br.close(); } if(bw != null){ bw.close(); } } catch (Exception e) { e.printStackTrace(); } } } } 使用说明：\n BufferedReader和BufferedWriter是按照字符操作的 如果去操作二进制文件（声音，视频，doc，pdf），可能造成文件损坏    使用字节流实现对二进制文件复制   BufferedOutputstream和BufferedInputStream结合实现对图片的拷贝\npackage com.bufferd; import com.sun.xml.internal.ws.api.ha.StickyFeature; import java.io.*; public class BufferedOutputStream_ { public static void main(String[] args) { String path1 = \u0026#34;e://567.jpg\u0026#34;; String path2 = \u0026#34;e://678.jpg\u0026#34;; BufferedInputStream bis = null; BufferedOutputStream bos = null; try { bis = new BufferedInputStream(new FileInputStream(path1)); bos = new BufferedOutputStream(new FileOutputStream(path2)); byte[] b = new byte[1024]; int len; while((len = bis.read(b))!=-1){ bos.write(b,0,len); } System.out.println(\u0026#34;拷贝成功...\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { if(bis!=null){ bis.close(); } if (bos!=null){ bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } }   字节流可以操作二进制文件，也可以操作文本文件\n  对象流   序列化和反序列化\n 序列化就是在保存数据时，保存数据的值和数据类型 反序列化就是在恢复数据时，恢复数据的值和数据类型 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，改类必须实现两个接口之一：  Serializable //这是一个标记接口，没有方法 Externalizable //该接口有方法需要实现，一般不使用      ObjectOutputStream提供序列化功能\n  序列化后保存的文件格式不是纯文本的，而是按照序列化的格式来保存\n  常用的几种基本类型都实现了Serializable接口，所以可以直接保存其数据类型\n  如果需要实例化某个类的对象，该类需要实现Serializable\n  代码演示\npackage com.outputstream; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class ObjectOutputStream_ { public static void main(String[] args) throws Exception{ String filePath = \u0026#34;e:\\\\a.bat\u0026#34;; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); oos.write(100);//int -\u0026gt; Integer(实现了Serializable接口)  oos.writeBoolean(true);//boolean -\u0026gt; Boolean(实现了Serializable接口)  oos.writeChar(\u0026#39;a\u0026#39;);//char -\u0026gt; Character(实现了Serializable接口)  oos.writeUTF(\u0026#34;成志恒\u0026#34;);//string -\u0026gt; String(实现了Serializable接口)  oos.writeDouble(9.5);//double -\u0026gt; Double(实现了Serializable接口)  //保存一个dog对象  oos.writeObject(new Dog(\u0026#34;dog\u0026#34;,10)); oos.close(); System.out.println(\u0026#34;保存成功...\u0026#34;); } } class Dog implements Serializable { public Dog(String name, int age) { this.name = name; this.age = age; } private String name; private int age; }   ObjectInputStream提供反序列化功能\n 读取（反序列化）的顺序需要和你保存数据（序列化）的顺序一致 在反序列化的时候，如果需要调用对象（dog）的方法，则需要向下转型，而实现向下转型的关键是当前类可以引用dog类，即在当前类下引用类。  代码演示\npackage com.inputstream_; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import com.outputstream.Dog;8//引用dog类  public class ObjectInputStream_ { public static void main(String[] args) throws IOException, ClassNotFoundException { String filePath = \u0026#34;e:\\\\a.bat\u0026#34;; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readUTF()); System.out.println(ois.readDouble()); Object dog = ois.readObject(); System.out.println(\u0026#34;类型为:\u0026#34;+dog.getClass()); System.out.println(dog); //向下转型  Dog dog1 = (Dog)dog; System.out.println(dog1.getAge()); ois.close(); System.out.println(\u0026#34;反序列成功\u0026#34;); } }   注意事项和细节说明\n  读写顺序要一致\n  要求实现序列化或反序列化对象，需要实现Serializable接口\n  序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性\n//SerialVersionUID序列化的版本号，可以提高兼容性 private static final long serialVersionUID = 1L;   序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员\n//下面两个属性都不会被序列化 private static String color; private transient String nation;   序列化对象时，要求里面属性的类型也需要实现序列化接口\n代码演示\nMaster类\npackage com.outputstream; public class Master { } Dog类新增加一个Master类型的属性\nprivate Master master = new Master(); 此时运行ObjectOutputStream_系统会报错\n如果要解决上述问题，需要Master类实现Serializable接口\npackage com.outputstream; import java.io.Serializable; public class Master implements Serializable { } 此时再运行ObjectOutoutStream_，保存成功\n  序列化具备可继承性，也就是如果某类已经 实现了序列化，则它的所有子类也已经默认实现了序列化\n    标准输入输出流   System.in(标准输入：键盘)\n 该流为System类中的public final static InputStream in = null; 编译类型：InputStream 运行类型：BufferedInputStream    System.out(标准输出：显示器)\n 该流为System类中的public final static PrintStream out = null; 编译类型：PrintStream 运行类型：PrintStream    代码演示\npackage com.standard; import java.util.Scanner; public class OutAndIn { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入数据\u0026#34;); String next = scanner.next(); System.out.println(\u0026#34;next=\u0026#34;+next); } }   转换流   在读取文件内容时，会默认文件为utf-8方式编码的，一旦文件编码方式改变了，所读取到的信息就会产生乱码，所以有转换流的出现\n  转换流可以把一个字节流转换成字符流，而字节流读取文件信息可以按照其编码方式来读取，所以能很好解决乱码问题\n  转换流有InputStreamReader与OutputStreamWriter\n  InputStreamReader：Reader的子类，可以将InputStream包装成Reader\n  OutputStreamWriter：Writer的子类，可以将OutputStream包装成Writer\n  当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\n  可以在使用是指定编码格式（比如utf-8，gbk，gb2312等）\n    演示使用InputStreamReader转换流解决中文乱码问题\n将字节流FileInputStream转换成字符流InputStreamReader，指定编码gbk/utf-8\npackage com.inputstream_; import java.io.*; public class InputStreamReader_ { public static void main(String[] args) throws IOException { String filePath = \u0026#34;e:\\\\a.txt\u0026#34;; //1.将FieleInputStream转换成InputStreamReader，编码方式为gbk  InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath),\u0026#34;gbk\u0026#34;); //2.将InputStreamReader传入BufferedReader  BufferedReader br = new BufferedReader(isr); //3.读取文件  String s = br.readLine(); //4.打印文件内容  System.out.println(s); //5.关闭流  br.close(); } } 为了减少代码行数，在开发中经常把1和2合在一起写\nBufferedReader br = new BufferedReader( new InputStreamReader( new FileInputStream(filePath),\u0026#34;gbk\u0026#34;));   OutStreamWriter同理\npackage com.outputstream; import java.io.BufferedWriter; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; public class OutStreamWriter_ { public static void main(String[] args) throws IOException { String filePath = \u0026#34;e:\\\\a.txt\u0026#34;; String charSet = \u0026#34;utf-8\u0026#34;; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(filePath),charSet); osw.write(\u0026#34;hello,成志恒11\u0026#34;); osw.close(); } }   打印流   打印流只有输出流没有输入流\n  PrintStream(字节打印流)\n在默认情况下，PrintStream输出数据的位置是标准输出（显示器）\n演示代码\npackage com.print; import java.io.PrintStream; public class PrintStream_ { public static void main(String[] args) { PrintStream printStream = System.out; printStream.println(\u0026#34;hello,word\u0026#34;); printStream.close(); } } 通过查看Print的底层源码\npublic void print(String s) { if (s == null) { s = \u0026#34;null\u0026#34;; } write(s); } 可以知道print底层使用的是write，所以我们可以直接调用write进行打印/输出\nprintStream.write(\u0026#34;hello,word\u0026#34;,getBytes()); 所得运行结果跟上述一样。\n另外，通过System.setOut()方法可以将内容输出到指定的的设备上\nString filePath = \u0026#34;e:\\\\a.txt\u0026#34;; System.setOut(new PrintStream(filePath)); System.out.println(\u0026#34;hi，word！\u0026#34;); 运行结果\n  PrintWriter(字符字符打印流)\n PrintWriter使用完之后必须关闭流，否则写入的内容不会刷新  使用PrintWriter将内容输出到指定设备\npackage com.print; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class PrintWriter_ { public static void main(String[] args) throws IOException { PrintWriter printWriter = new PrintWriter(new FileWriter(\u0026#34;e:\\\\a.txt\u0026#34;)); printWriter.print(\u0026#34;hello.word!!!\u0026#34;); //必须关闭流！  printWriter.close();//相当于flush+关闭流  } }   Properties类   Properties类主要用于读取Java的配置文件。\n  传统的读取配置文件信息的方法\n代码演示\npackage com.properties; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class Properties_ { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(\u0026#34;src\\\\mysql.properties\u0026#34;)); String line = \u0026#34;\u0026#34;; while((line = br.readLine()) != null){ //利用split将等号前后的内容划分成两个数组  String[] split = line.split(\u0026#34;=\u0026#34;); System.out.println(split[0]+\u0026#34;值为\u0026#34;+split[1]); } } } 如果我们使用传统方法获取指定的ip值，会有很多问题，所以一般使用Properties类去读取配置文件\n  Properties类读取配置文件\n  该类是专门用于读取配置文件的集合类，配置文件的格式需要按照一下格式编写：\n 键=值\n键=值\n   注意：键值对不需要有空格，值不需要用引号括起来，默认类型为String\n  Properties的常见方法\n load：加载配置文件的键值对到Priperties对象 list：将数据显示到指定设备 getProperty(key)：根据键获取值 setProperty(key,value)：设置键值对到Properties对象 store：将Properties中的键值对存储到配置文件。在idea中，保存信息到配置文件，如果信息含有中文，会存储为Unicode码 http://tool.chinaz.com/tools/unicode/aspx Unicode码查询工具    代码演示\npackage com.properties; import java.io.FileReader; import java.io.IOException; import java.util.Properties; public class Properties_01 { public static void main(String[] args) throws IOException { //1.创建Properties对象  Properties properties = new Properties(); //2.加载指定文件  properties.load(new FileReader(\u0026#34;src\\\\mysql.properties\u0026#34;)); //3.把k-v输出到控制台  properties.list(System.out); //4.根据key值获取相对应的value  String user = properties.getProperty(\u0026#34;user\u0026#34;); System.out.println(\u0026#34;用户名=\u0026#34;+user); } } 运行结果\n  使用Properties类来创建配置文件\npackage com.properties; import java.io.FileWriter; import java.io.IOException; import java.util.Properties; public class Properties_02 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.setProperty(\u0026#34;charset\u0026#34;,\u0026#34;utf8\u0026#34;); properties.setProperty(\u0026#34;user\u0026#34;,\u0026#34;志恒\u0026#34;);//中文保存为Unicode码  properties.setProperty(\u0026#34;pwd\u0026#34;,\u0026#34;11111\u0026#34;); properties.store(new FileWriter(\u0026#34;src\\\\mysql2.properties\u0026#34;),null); System.out.println(\u0026#34;保存成功\u0026#34;); } } 运行结果\n  使用Properties来修改文件内容\n 如果该文件没有key，就会自动创建 如果该文件有key，就会修改  properties.setProperties(\u0026#34;pwd\u0026#34;,888888);   Properties父类是Hashtable，所以其核心代码底层就是Hashtable 的核心方法\npublic synchronized V put(K key, V value) { // Make sure the value is not null  if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable.  Entry\u0026lt;?,?\u0026gt; tab[] = table; int hash = key.hashCode(); int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; entry = (Entry\u0026lt;K,V\u0026gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) \u0026amp;\u0026amp; entry.key.equals(key)) { V old = entry.value; entry.value = value;//如果key存在，就替换  return old; } } addEntry(hash, key, value, index);//如果是新的值，就addEntry  return null; } ​\n  ","date":"2021-06-19T16:22:25+08:00","permalink":"https://minster77.github.io/p/java_io%E6%B5%81_2/","title":"Java_IO流_2"},{"content":"泛型   引出泛型 泛型的介绍及使用 泛型的使用细节 泛型课堂练习题 自定义泛型 Junit   引出泛型   现在有这样的一个需求\n 编写一个程序，在ArrayList中，添加三个Dog对象 Dog对象含有name和age，并输出name和age（要求使用getXxx方法）  用传统的方法编码，代码演示如下\n创建Dog类\nclass Dog{ private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 创建测试类Generic01\npackage com.generic; import java.util.ArrayList; public class Generic01 { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(new Dog(\u0026#34;旺财\u0026#34;,10)); arrayList.add(new Dog(\u0026#34;小黄\u0026#34;,8)); arrayList.add(new Dog(\u0026#34;富贵\u0026#34;,5)); //使用增强for遍历  for (Object o : arrayList) { //向下转型  Dog dog = (Dog) o; System.out.println(dog.getName()+\u0026#34;--\u0026#34;+dog.getAge()); } } } 用传统方式即可很快完成需求。\n假如程序员不小心把一个Cat对象添加到集合里面，会发生什么呢？\narrayList.add(new Cat(\u0026#34;小黑\u0026#34;,3)); 编译运行，发现程序报错\n可以发现，倘若我们使用传统的方式来解决需求时，程序会有两个缺点\n 不能对加入到集合ArrayList中的数据类型进行约束（不安全，会发生上面那样的编译错误，而且编译器编译时识别不了） 遍历的时候需要进行类型转换，如果集合中的数据量较大时会对效率有影响  而我们使用泛型便可以很好的解决上述两个缺点！\n把测试类Generic01中集合的定义改为\nArrayList\u0026lt;Dog\u0026gt; arrayList = new ArrayList\u0026lt;Dog\u0026gt;(); 便是使用了泛型，可以规范ArrayList集合中元素的取值。而且当我们使用泛型之后，如果编译器发现添加的类型不满足集合规定的要求，就会报错，可以避免发生异常。\n同时，我们遍历集合的时候，不再需要先取出Object类型再进行向下转型了，可以直接获取到Dog类型的数据。\n//使用增强for遍历 for (Dog dog : arrayList) { System.out.println(dog.getName()+\u0026#34;--\u0026#34;+dog.getAge()); } 使用泛型的好处\n 编译时，编译器会检查添加元素的类型，提高了安全性 减少了类型转换的次数，提高效率    泛型的介绍及语法与使用   泛型的介绍（泛型是可以代表一种数据类型的）\n  泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题\n  在类声明或实例化时只要指定好需要的具体类型即可\n  Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时使代码更加简洁、健壮\n  泛型的作用是：可以在类声明时通过一个标识表示类中的某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型（看下面代码理解）。\n 在编程时，我们新建一个类的属性的时候，有时候可能会不确定该属性的类型，让其由用户来决定，这时候我们便可以使用泛型\n class Person\u0026lt;E\u0026gt;{ //E表示数据类型  E s; //E也可以是参数类型  public Person(E s) { this.s = s; } //E做返回类型  public E getS() { return s; } } 我们在Generic02中，可以根据所需来声明E的类型\npackage com.generic; public class Generic02 { public static void main(String[] args) { //当我们要s为String类型的时候  Person\u0026lt;String\u0026gt; stringPerson = new Person\u0026lt;String\u0026gt;(\u0026#34;jack\u0026#34;); //当我们要s为int类型的时候  Person\u0026lt;Integer\u0026gt; person = new Person\u0026lt;Integer\u0026gt;(1); } } E的数据类型在定义Person时指定，即在编译期间就可以确定E的类型\n    泛型的语法\ninterface 接口 \u0026lt;E\u0026gt;{ } class 类\u0026lt;K,V,E\u0026gt;{ } 其中，K,T,V不代表值，而是表示类型\n任意字母都可以。常用T表示\n  泛型的应用实例\n 创建三个学生对象 把学生对象放到HashMap中，而且学生名字为key，学生对象为value 用两种方式遍历学生对象  代码演示\n创建Student类\nclass Student{ private String name; private int age; public Student(String name,int age) { this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 创建测试类GenericExercise\npackage com.generic; import java.util.*; public class GenericExercise { public static void main(String[] args) { Student jack = new Student(\u0026#34;jack\u0026#34;, 10); Student tom = new Student(\u0026#34;tom\u0026#34;, 13); Student mary = new Student(\u0026#34;mary\u0026#34;, 15); HashMap\u0026lt;String,Student\u0026gt; hashMap = new HashMap\u0026lt;String,Student\u0026gt;(); hashMap.put(jack.getName(),jack); hashMap.put(tom.getName(),tom); hashMap.put(mary.getName(),mary); Set\u0026lt;String\u0026gt; strings = hashMap.keySet(); Iterator\u0026lt;String\u0026gt; iterator = strings.iterator(); while (iterator.hasNext()) { String next = iterator.next(); System.out.println(next+\u0026#34;:\u0026#34;+hashMap.get(next)); } System.out.println(\u0026#34;==============\u0026#34;); Set\u0026lt;Map.Entry\u0026lt;String, Student\u0026gt;\u0026gt; entries = hashMap.entrySet(); for (Map.Entry\u0026lt;String, Student\u0026gt; entry : entries) { System.out.println(entry.getKey()+\u0026#34;=\u0026#34;+entry.getValue()); } } } 运行结果\n  泛型的使用细节   interface List\u0026lt;T,V\u0026gt;等泛型的声明中，其中T,V只能是引用类型，不能为基本数据类型！\n//正确的定义 List \u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;Integer\u0026gt;(); //错误的定义\tList \u0026lt;int\u0026gt; list2 = new ArrayList\u0026lt;int\u0026gt;();   在给泛型指定的具体类型后，可以传入该类型或该子类类型（继承）。\nclass Detail{ public static void main(String[] args){ Pig\u0026lt;A\u0026gt; piga = new Pig\u0026lt;A\u0026gt;(new A()); Pig\u0026lt;A\u0026gt; piga = new Pig\u0026lt;A\u0026gt;(new B()); } } class A{ } class B extends A{ } class Pig\u0026lt;E\u0026gt;{ E e; publiu Pig(E e){ this.e = e; } }   泛型的使用方式\n//传统写法 List \u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;Integer\u0026gt;(); //实际开发中，通常使用简写。因为编译器会进行类型推断，所以后面的可以不写 List \u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;();//推荐这种写法！   如果是这样写 List list1 = new ArrayList(); 也会使用泛型，默认是Object\nList list1 = new ArrayList(); //等价于 List \u0026lt;Object\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;();   泛型课堂练习题 定义Employee类\n  该类包含：private成员变量 name，sal，birthday，其中birthday为Mydate类的对象；\n  为每一个属性定义getter，setter方法；\n  重写toString方法输出name，sal，birthday\n  MyDate类包含：private成员变量month，day，year；并为每一个属性定义getter，setter方法；\n  创建Employee类的三个对象，并把这些对象放入ArrayList集合中（ArrayList需要使用泛型来定义），对集合中的元素进行排序，并遍历输出；\n  排序方式：调用ArrayList的sort方法，传入Comparator对象，先按照name排序，如果name相同，则按照生日日期的先后排序。\n创建MyDate类\npackage com.generic; class MyDate implements Comparable\u0026lt;MyDate\u0026gt;{ private int year; private int month; private int day; public MyDate(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getMonth() { return month; } public void setMonth(int month) { this.month = month; } public int getDay() { return day; } public void setDay(int day) { this.day = day; } @Override public String toString() { return \u0026#34;MyDate{\u0026#34; + \u0026#34;year=\u0026#34; + year + \u0026#34;, month=\u0026#34; + month + \u0026#34;, day=\u0026#34; + day + \u0026#39;}\u0026#39;; } //实现Comparable的方法，让Birthday的比较封装在MyDate类中  //封装后代码的维护性和可复用行大大提高！  @Override public int compareTo(MyDate o) { //按照year的大小进行排序  int yearMinus = this.getYear() - o.getYear(); //如果year不相同，返回比较值  if (yearMinus != 0){ return yearMinus; } //按照month的大小进行排序  int monthMinus = this.getMonth() - o.getMonth(); if (monthMinus != 0){ return monthMinus; } //如果year与month相同，按照day的大小进行排序  return this.getDay() - o.getDay(); } } 创建Employee类\npackage com.generic; class Employee{ private String name; private double sal; private MyDate birthday; public Employee(String name, double sal, MyDate birthday) { this.name = name; this.sal = sal; this.birthday = birthday; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } public MyDate getBirthday() { return birthday; } public void setBirthday(MyDate birthday) { this.birthday = birthday; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \u0026#34;\\nEmployee{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, sal=\u0026#34; + sal + \u0026#34;, birthday=\u0026#34; + birthday + \u0026#39;}\u0026#39;; } } 创建测试类GenericExercise02\npackage com.generic; import java.util.ArrayList; import java.util.Comparator; public class GenericExercise02 { public static void main(String[] args) { Employee jack = new Employee(\u0026#34;jack\u0026#34;, 1000, new MyDate(2000, 03, 20)); Employee tom = new Employee(\u0026#34;tom\u0026#34;, 2000, new MyDate(1999, 02, 1)); Employee mary = new Employee(\u0026#34;jack\u0026#34;, 3000, new MyDate(2000, 02, 19)); ArrayList\u0026lt;Employee\u0026gt; employees = new ArrayList\u0026lt;\u0026gt;(); employees.add(jack); employees.add(tom); employees.add(mary); System.out.println(); employees.sort(new Comparator\u0026lt;Employee\u0026gt;() { @Override public int compare(Employee emp1, Employee emp2) { if(!(emp1 instanceof Employee )\u0026amp;\u0026amp; !(emp2 instanceof Employee)){ System.out.println(\u0026#34;类型不正确...\u0026#34;); return 0; } //按照name排序，字母的先后顺序  int i = emp1.getName().compareTo(emp2.getName()); //i不等于0说明name不相同，即通过名字即可完成排序，所以返回i；  if(i != 0){ return i; } //如果name长度相同，便按照birthday进行排序  return emp1.getBirthday().compareTo(emp2.getBirthday()); } }); System.out.println(employees); } } 运行结果\n  自定义泛型   自定义泛型类\n  基本语法\nclass 类名 \u0026lt;T,V...\u0026gt;{ }   注意细节\n 普通成员可以使用泛型（属性、方法） 使用泛型的数组，不能初始化（因为数组在创建的时候，不能确定泛型的类型，无法在内存开辟空间） 静态方法中不能使用类的泛型（因为static是与类相关的，在类加载时，对象还没有创建，而泛型是在对象创建时才产生的。） 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型） 如果在创建对象时，没有指定类型，默认为Object      自定义泛型接口\n  基本语法\ninterface 接口名 \u0026lt;T,E,R...\u0026gt;{ }   注意细节\n  在接口中，静态成员也不能使用泛型\n  泛型接口的类型，在继承接口或者实现接口时确定\ninterface IA\u0026lt;T,V\u0026gt;{ T get(V v); } //继承接口时确定泛型的类型 //T-\u0026gt;Double,V-\u0026gt;String interface IB extends IA\u0026lt;Double,String\u0026gt;{ } //当我们区实现IB接口时，因为IB在继承IA时指定了T为Double，V为String //所以在实现IA的方法时，会自动替换掉T,V class IBImp implements IB{ @Override public Double get(String v){ } }   没有指定类型，默认为Object\n  在jdk8中，default方法也能使用泛型\n      自定义泛型方法\n  基本语法\n修饰符 \u0026lt;T,R\u0026gt;返回类型 方法名(参数列表){ }   注意细节\n 泛型方法，可以定义在普通类中，也可以定义在泛型类中 当泛型方法被调用时，类型会确定 public void eat(E e){}，修饰符后面没有\u0026lt;T,R\u0026hellip;\u0026gt; eat方法不是泛型方法，而是使用了泛型 泛型方法可以使用类声明的泛型，也可以使用自己声明的泛型      泛型的继承和通配符\n  泛型不具备继承性\nList \u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();//系统会报错           JUnit  一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中 如果有多个功能代码测试，就需要来回注销，切换很麻烦 而使用JUnit便可以很好的解决上述问题    基本介绍\n JUnit是一个Java语言的单元测试框架 多数Java的开发环境都已经继承了JUnit作为单元测试的工具    使用\n在需要测试的文件上面增加一个@Test即可\n  ","date":"2021-06-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E6%B3%9B%E5%9E%8B/","title":"Java泛型"},{"content":"Java IO流1（概念及节点流）   文件 IO流原理及流的分类 InputStream的子类及使用 OutputStream的子类及使用 利用FileInputStream及FileOutputStream进行文件copy Reader与Writer的子类及使用 节点流和处理流   文件   文件是保存数据的地方，例如word文档，txt文档等都是文件。\n  文件流\n文件在程序中是以流的形式来操作的\n 流：数据在数据源(文件）和程序（内存）之间经历的路径 输入流：数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径    常用的文件操作\n    使用new File（String pathname）创建\npackage com.java_io; import org.junit.Test; import java.io.File; import java.io.IOException; public class FileCreate1 { public static void main(String[] args) { } //方法1：使用new File(filePath)创建文件  @Test public void createFile01() throws IOException { //创建的文件路径名称  String filePath = \u0026#34;e:\\\\news1.txt\u0026#34;; File file = new File(filePath); try { file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } }   使用new File(File parent,String child)创建\n@Test public void createFile02(){ File parentFile = new File(\u0026#34;e:\\\\\u0026#34;); String fileName = \u0026#34;news2.txt\u0026#34;; //此时的file对象在Java程序(内存)中只是一个对象而已  //只有执行了createNewFile方法才会真正在磁盘创建文件  File file = new File(parentFile,fileName); try { //此时在磁盘中创建了文件  file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } }   使用new File(String parent,String child)创建\n@Test public void createFile03(){ String parentPath = \u0026#34;e:\\\\\u0026#34;; //String parentPath = \u0026#34;e:/\u0026#34;; 也可以  String fileName = \u0026#34;new3.txt\u0026#34;; File file = new File(parentPath,fileName); try { file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } }   获取文件信息\n getName()：获取文件名字 getAbsolutePath()：获取文件绝对路径 getParent()：获取父级目录 length()：获取文件大小(字节) exists()：查看文件是否存在 isFile()：检测是不是一个文件 isDirectory()：检测是不是一个目录  代码演示\npackage com.java_io; import org.junit.Test; import java.io.File; public class fileInformation { public static void main(String[] args) { } @Test public void fileInformation(){ //先创建文件对象  File file = new File(\u0026#34;e:\\\\news1.txt\u0026#34;); //调用对应的方法，得到相应的信息  System.out.println(\u0026#34;文件名字=\u0026#34;+file.getName()); System.out.println(\u0026#34;文件绝对路径=\u0026#34;+file.getAbsolutePath()); System.out.println(\u0026#34;文件父级目录=\u0026#34;+file.getParent()); System.out.println(\u0026#34;文件大小（字节）=\u0026#34;+file.length()); System.out.println(\u0026#34;文件是否存在=\u0026#34;+file.exists()); System.out.println(\u0026#34;是不是一个文件=\u0026#34;+file.isFile()); System.out.println(\u0026#34;是不是一个目录=\u0026#34;+file.isDirectory()); } }   目录的操作\n delete()：删除目录。 mkdir()：创建一级目录 mkdirs()：创建多级目录  代码示例\n//检查目录下是否存在news2.txt文件，若存在则删除  @Test public void m1(){ File file = new File(\u0026#34;e:\\\\news2.txt\u0026#34;); if (file.exists()) { if (file.delete()) { System.out.println(\u0026#34;删除成功\u0026#34;); }else { System.out.println(\u0026#34;删除失败\u0026#34;); } }else { System.out.println(\u0026#34;找不到改文件...\u0026#34;); } } } 创建目录\n//检查e:\\\\demo\\\\a\\\\b\\\\c是否存在，若不存在则创建  @Test public void m2(){ String directoryPath = \u0026#34;e:\\\\demo\\\\a\\\\b\\\\c\u0026#34;; File file = new File(directoryPath); if (file.exists()) { System.out.println(\u0026#34;改目录存在...\u0026#34;); }else { if (file.mkdirs()) { System.out.println(directoryPath+\u0026#34;目录创建成功\u0026#34;); }else { System.out.println(directoryPath+\u0026#34;目录创建失败\u0026#34;); } } }   IO流原理及流的分类   输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中\n  输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中\n  流的分类\n 按操作数据单位不同分为：  字节流（8bit）：二进制文件使用 字符流（按字符）：文本文件使用   按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：字节流，处理流/包装流  而Java IO流有四个抽象基类\n    字节流 字符流     输出流 OutputStream Writer   输入流 InputStream Reader    其他的流都是继承于这四大基类的。下图是Java IO流的整体架构图\n所理解的流就像快递小哥，在物流中心和客户之间做传递作用\n  InputStream的子类及使用   InputStream的常用子类\n FileInputStream：文件输入流 BufferedInputStream：缓冲字节输入流 ObjectInoutStream：对象字节输入流    使用FileInputStream读取文件\nread()读取单个字节\npackage com.java_io; import org.junit.Test; import java.io.FileInputStream; import java.io.IOException; public class FileInputStreamTest { public static void main(String[] args) { } @Test public void InputStream(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; FileInputStream fileInputStream = null; int readFile = 0; try { //创建FileInputStream对象，用于读取文件  fileInputStream = new FileInputStream(filePath); //read()：从输入流中读取一个字节的数据，如果没有输入，则被阻止  //如果返回-1.则表示读取完毕  while ((readFile = fileInputStream.read())!=-1){ System.out.print((char) readFile); } } catch (Exception e) { e.printStackTrace(); }finally { //关闭文件流，释放资源  try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } read(byte[b])缓冲区读取b个字节\n@Test public void InputStream02(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; byte [] buf = new byte[8];//每次读取8个字节的数据  FileInputStream fileInputStream = null; int readLen = 0;//记录读取的字节数  try { fileInputStream = new FileInputStream(filePath); /* * 创建FileInputStream对象，用于读取文件 * 从输入流读取最多buf.length字节数据到字节数组，若没有输入，则阻塞此方法 * 如果返回值为-1，表示读取完毕 * 如果读取正常则返回读取的字节数*/ while((readLen = fileInputStream.read(buf))!=-1){ //new Sting(buf,0,len):把一个字节数组从0取到len构造成一个新的String  System.out.print(new String(buf,0,readLen)); } } catch (IOException e) { e.printStackTrace(); } finally { try { //关闭流，释放资源  fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 需要注意的是使用FileInputStream读取文件时，读取到的字符是乱码的\n    OutputStream的子类及使用   FileOutputStream\n演示使用FileOutputStream。将数据写到文件中，如果该文件不存在，则创建该文件。\npackage com.java_io; import org.junit.Test; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class FileOutputStreamTest { public static void main(String[] args) { } @Test public void fileOutputStream(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; FileOutputStream fileOutputStream = null; try { //创建FileOutputStream对象，对文件操作  fileOutputStream = new FileOutputStream(filePath,true); //向文件写入一个字节的数据  fileOutputStream.write(\u0026#39;H\u0026#39;); //向文件写入字符串  //str.getBytes()将字符串转换为字节数组  String str = \u0026#34;Hello,Word!\u0026#34;; fileOutputStream.write(str.getBytes()); System.out.println(\u0026#34;写入成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } }   若需要写入指定的字符，使用\n//write(byte[] b,int off,int len); fileOutputStream.write(str.getBytes(),0,str.length()); 可以将len字节从偏移量off的指定字节数组写入此文件输入流\n  需要注意的是，如果使用\nfileOutputStream = new FileOutputStream(File file,boolean append); 时没有将append设置为true的话，系统会默认append的值为false，则会清空记事本再写入新的内容（覆盖之前的内容）。\n若需要换行或者添加制表符输入，使用其转义字符即刻\nfileOutputStream.write(\u0026#34;\\n\u0026#34;.getBytes());//换行 fileOutputStream.write(\u0026#34;\\t\u0026#34;.getBytes());//增加制表符     利用FileInputStream及FileOutputStream进行文件Copy   思路分析\n 创建文件的输入流，将文件读到程序中 创建文件的输出流，将读取到的文件输入写到指定的文件中    代码演示\npackage com.java_io; import org.junit.Test; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopy { public static void main(String[] args) { } /* * 将\u0026#34;e:\\\\567.jpg\u0026#34;复制到\u0026#34;d:\\\\567.jpg\u0026#34;*/ @Test public void fileCopy(){ String srcPath = \u0026#34;e:\\\\567.jpg\u0026#34;; String destPath = \u0026#34;d:\\\\567.jpg\u0026#34;; //创建输入流及输出流对象  FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try { //定义字节数组接收，提高效率  byte [] buf = new byte[1024]; int readlen = 0; fileInputStream = new FileInputStream(srcPath); fileOutputStream = new FileOutputStream(destPath); while ((readlen = fileInputStream.read(buf))!=-1){ fileOutputStream.write(buf,0,readlen); } System.out.println(\u0026#34;写入成功！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { //关闭输入输出流，释放资源  if(fileInputStream==null){ fileInputStream.close(); } if(fileOutputStream==null){ fileOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 需要注意的是，写入文件时，必须使用\nwrite(byte[],0,readLength) 写入。readLength为读入数据的长度，这样写可以避免byte数组过大时把其余子集读入造成文件损失\n  Reader与Writer的子类及使用   FileReader的相关方法：\n new FileReader(File/String)：创建对象 read()：每次读取单个字符并返回，如果到文件末尾，返回-1 read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾则返回-1。  相关API\n new String(char[])：将char[] 转换成String new String(char[],off,len)：将char[]的指定部分转换成String  代码演示\npackage com.java_io; import org.junit.Test; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class FileReaderTest { public static void main(String[] args) { } @Test public void FileReaderTest(){ String filePath = \u0026#34;e:\\\\story.txt\u0026#34;; FileReader fileReader = null; char [] chars = new char[1024]; try { //新建对象  fileReader = new FileReader(filePath); try { while ((fileReader.read(chars))!=-1){ System.out.println(chars); } } catch (IOException e) { e.printStackTrace(); } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { if(fileReader==null){ //关闭流，释放资源  fileReader.close(); } } catch (IOException e) { e.printStackTrace(); } } } }   FileWriter的相关方法\n new FileWriter(File/String)：覆盖模式，相当于流的指针在首端 new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端 write(int)：写入单个字符 write(char[])：写入指定数组 write(char[],off,len)：写入指定数组的指定部分 write(String)：写入整个字符串 write(String,off,len)：写入字符串的指定部分  相关API\n toCharArray：将String转换成char[];  注意：\n  FileWriter使用后，必须关闭(close)或刷新(flush),否则写入不到指定的文件\n  FileWriter的类图如下\n  FileWriter的使用\npackage com.java_io; import org.junit.Test; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; public class FileWriterTest { public static void main(String[] args) { } @Test public void FileWriter(){ String filePath = \u0026#34;e:\\\\note.txt\u0026#34;; FileWriter fileWriter = null; String str = \u0026#34;AD\u0026#34;; char [] chars ={\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}; int writerLen = 3; try { fileWriter = new FileWriter(filePath,true); fileWriter.write(\u0026#39;H\u0026#39;); fileWriter.write(\u0026#34;\\n\u0026#34;);//换行  fileWriter.write(str); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(chars); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(chars,0,writerLen); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(str,0,1); } catch (IOException e) { e.printStackTrace(); } finally { try { fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } }   如果需要换行或者输入制表符则可以\nfileWriter.write(\u0026#34;\\n\u0026#34;);//换行 fileWriter.write(\u0026#34;\\t\u0026#34;);//制表符     节点流和处理流   节点流可以从一个特定的数据源读写数据\n  处理流(包装流)是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter\n  分析BufferedReader处理流\n查看BufferedReader的源码可以知道，BufferedReader中定义了一个Reader属性，即他可以封装任意一个节点流，所以使用BufferedReader去操作的时候，其可以访问各种不同的数据源。其功能更为强大\nBufferedWriter同理。\n  节点流与处理流的区别和联系\n 节点流是底层流/低级流，直接跟数据源相接。 处理流(包装流)包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出 处理流(包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连    模拟装饰者设计模式来理解处理流BufferedReader/BufferedWriter\n创建Reader抽象类(Reader_)\npackage com.decorator_pattern; public abstract class Reader_ { public void readString(){ } public void readFile(){ } } 创建节点流子类FileReader_\npackage com.decorator_pattern; public class FileReader_ extends Reader_{ public void readFile(){ System.out.println(\u0026#34;readFile\u0026#34;); } } 创建节点流子类StringReader_\npackage com.decorator_pattern; public class StringReader_ extends Reader_{ public void readString(){ System.out.println(\u0026#34;readString\u0026#34;); } } 创建处理流BufferedReader_\npackage com.decorator_pattern; public class BufferedReader_ extends Reader_{ private Reader_ reader_;//属性时Reader_类型  public BufferedReader_(Reader_ reader_) { this.reader_ = reader_; } //封装方法  public void readFile(){ reader_.readFile(); } //装饰者模式的特性：增加新功能  public void readStrings(int num){ for (int i = 0; i \u0026lt; num; i++) { reader_.readString(); } } } Test类\npackage com.decorator_pattern; public class Test { public static void main(String[] args) { //新建bufferedReader_对象，把FileReader_传进去，使方法可以对文件操作  BufferedReader_ bufferedReader_1 = new BufferedReader_(new FileReader_()); bufferedReader_1.readFile(); //必须是相应的对象的方法才会有用  bufferedReader_1.readStrings(10);//无效  //新建bufferedReader_对象，把StringReader_传进去，使方法可以对字符串操作  BufferedReader_ bufferedReader_2 = new BufferedReader_(new StringReader_()); bufferedReader_2.readStrings(10); } } 测试结果\n通过上述设计模式可以让BufferedReader包装其他节点流，这样子就能提高对数据源操作的效率\n可以使用统一的一个read方法来优化上述代码。如：\n在Reader_抽象类中使用抽象方法read\npackage com.decorator_pattern; public abstract class Reader_ { public abstract void read(); } 然后子类实现此方法即可\npackage com.decorator_pattern; public class FileReader_ extends Reader_{ public void read(){ System.out.println(\u0026#34;readFile\u0026#34;); } } 此时，想要操作相应的数据则需要利用对象的动态绑定机制，绑定到对应的实现子类即可\t。\n所以Test中的\n//多态性，因为bufferedReader_1是new了FileReader_对象，所以去找FileReader_对象  bufferedReader_1.readStrings(10); 能输出readFile。\n  处理流的功能\n 性能的提高：主要以增加缓冲的方式来提高输入输出的效率 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便    ","date":"2021-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java_io%E6%B5%81/","title":"Java_IO流"},{"content":"单例设计模式 什么是设计模式  静态方法和属性的经典实用 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索  什么是单例模式   单例：就是单个的实例\n  所谓的类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法\n  单例模式有两种方式：\n  饿汉式（只有类被加载了，该对象就会被创建）\n 将构造器私有化 在类的内部之间创建（该对象是static） 提供一个公共的static方法，返回对象  例如，我们规定一个人必须专一，只能有一个女朋友！\npackage com.singleton; public class SingleTon { public static void main(String[] args) { GirlFriend instance = GirlFriend.getInstance(); System.out.println(instance); //无论你怎么创建，该对象都是同一个  GirlFriend instance1 = GirlFriend.getInstance(); System.out.println(instance1); //返回结果为True  System.out.println(instance==instance1); } } class GirlFriend{ private String name ; //在类内部创建了对象，加static是为了可以在静态方法中返回girlFriend对象  private static GirlFriend girlFriend = new GirlFriend(\u0026#34;小红\u0026#34;); //构造器私有化  private GirlFriend(String name){ this.name = name; } public static GirlFriend getInstance(){ return girlFriend; } @Override public String toString() { return \u0026#34;GirlFriend{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 由于类被加载之后，对象无论如何都会被创建，会造成资源的浪费。\npackage com.singleton; public class SingleTon { public static void main(String[] args) { System.out.println(GirlFriend.n); } } class GirlFriend{ private String name ; public static int n = 100; //对象，通常是重量级的对象，饿汉模式可能造成创建了对象，但没有使用  private static GirlFriend girlFriend = new GirlFriend(\u0026#34;小红\u0026#34;); //构造器私有化  private GirlFriend(String name){ System.out.println(\u0026#34;构造器被调用了\u0026#34;); this.name = name; } public static GirlFriend getInstance(){ return girlFriend; } @Override public String toString() { return \u0026#34;GirlFriend{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 使用懒汉式可以很好的解决这个问题\n  懒汉式（不调用就不会创建对象）\n 将构造器私有化 定义一个static静态属性对象 提供一个public的static方法，可以返回一个对象  懒汉式：只有当用户使用getInstance时才会返回一个对象。后面再调用时，会返回上次创建的对象\npackage com.singleton; public class SingleTon01 { public static void main(String[] args) { System.out.println(Cat.n); System.out.println(\u0026#34;================\u0026#34;); Cat cat = Cat.getInstance(); System.out.println(cat); } } class Cat{ private String name; public static int n = 100; private static Cat cat; private Cat(String name){ System.out.println(\u0026#34;构造器被调用\u0026#34;); this.name = name; } public static Cat getInstance(){ //判断有没有创建Cat对象  if(cat == null){ cat = new Cat(\u0026#34;miao\u0026#34;); } return cat; } @Override public String toString() { return \u0026#34;Cat{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }     饿汉式VS懒汉式\n 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例而懒汉式是在使用时才创建 饿汉式不存在线程安全问题，懒汉式存在线程安全问题 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。 在我们的JavaSE标准类中，java.lang.Runtime就是经典的单例模式    ","date":"2021-05-28T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"Java单例模式"},{"content":"JavaInterface   接口的基本介绍 接口的注意事项及使用细节 接口实现与类的继承 接口的多态性   接口基本介绍   接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。\n接口的定义：\ninterface 接口名{ //属性  //方法 } 类实现接口:\nclass ClassName implements Interface { //自己的属性  //自己的方法  //必须实现的接口的抽象方法 }   在jdk7前，接口里的所以方法都没有方法体，即都是抽象方法。\n  jdk8后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。但默认方法需要使用default关键字修饰\n  在接口中，定义抽象方法时可以省略abstract关键字。如果一个类实现了接口，则需要把接口的所有抽象方法都实现。\n代码演示\n创建接口Interface01\npackage com.interface_; public interface Interface01 { //定义属性  public int n =1; //定义抽象方法  public void A(); //定义默认方法  default public void B(){ System.out.println(\u0026#34;我是默认方法\u0026#34;); } //定义静态方法  public static void C(){ System.out.println(\u0026#34;我是静态方法\u0026#34;); } } 创建实现类InterfaceImp01\npackage com.interface_; public class InterfaceImp01 implements Interface01{ @Override public void A() { System.out.println(\u0026#34;实现抽象方法\u0026#34;); } @Override public void B() { Interface01.super.B(); } } 创建测试类InterfaceTest\npackage com.interface_; public class InterfaceTest { public static void main(String[] args) { InterfaceImp01 interfaceImp01 = new InterfaceImp01(); interfaceImp01.A(); interfaceImp01.B(); //调用静态方法  Interface01.C(); } } 输出结果：\n  对于初学者来说，接口的概念不难理解。难的是不知道什么时候使用接口，下面例举应用场景来理解接口的使用：\n 现在要制作战斗机，武装直升机。专家只需要把飞机需要的功能/规格定下来即可，然后让工程师来实现 现在有一个项目经理，管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员来实现。    接口的注意事项与使用细节   接口不能被实例化\n  接口中所有的方法都是public，接口中的抽象方法可以不用abstract修饰\ninterface Interface{ void say(); //相当于  public abstract void say(); }   一个普通类实现接口，就必须将该接口的所有方法都实现(可以使用alt+enter来解决)\n  抽象类去实现接口时，可以不实现接口的抽象方法\n  一个类可以同时实现多个接口。\n创建接口Interface01\ninterface Interface01{ say(); } 创建接口Interface02\ninterface Interface02{ hi(); } 实现类dog\nclass dog implements Interface01,Interface02{ @Override public void hi(){ } @Override public void say(){ } }   接口中的属性只能是final，而且是public static final修饰符。属性的访问形式为接口名.属性名\ninterface Interface01{ int n = 1; //实际上是  public static final int n = 1;//必须初始化值 } 证明：创建测试类InterfaceTest\npackage com.interface_; public class InterfaceTest { public static void main(String[] args) { //此处可以直接调用接口Interface01的属性，证明该属性为static  Interface01.n; Interface01.n = 10;//系统会报错，证明该属性被final修饰  } }   接口不能继承其他的类，但是可以继承其他接口。\ninterface Interface03 extends Interface01,Interface02{ } 而且继承其他接口时不用实现其他接口的方法。\n  接口的修饰符与类一样，只能是public或者是默认\n  思考题：下面程序是否正确，正确的话输出什么？\n//创建接口 public interface Interface02 { int a = 23; } //创建接口实现类 public class InterfaceImp02 implements Interface02{ } //创建测试类 public class InterfaceTest { public static void main(String[] args) { InterfaceImp02 imp02 = new InterfaceImp02(); System.out.println(imp02.a); //因为InterfaceImp02实现了接口Interface02 所以也可以成功输出  System.out.println(InterfaceImp02.a); //a为static属性，所以可以输出  System.out.println(Interface02.a); } } 代码正确，输出结果为\n  接口实现与类继承   当子类继承了父类，就会**自动的拥有父类的功能(方法)。**而如果子类需要拓展功能，可以通过实现接口的方式拓展\n  可以理解成实现接口就是对Java单继承机制的一种补充\n下面举个例子理解接口实现与类继承\n例：假如有一只小猴子悟空，他继承了父亲的爬树技能。当他看到鱼儿在游泳时，就跟鱼儿学习了游泳技能；当他看到鸟儿在飞翔时，就跟鸟儿学习了飞翔技能\u0026hellip;\n代码演示：\n创建猴子父类 Monkey\npackage com.interface_; public class Monkey { private String name; public Monkey(String name) { this.name = name; } public void climbing(){ System.out.println(name + \u0026#34;在爬树\u0026#34;); } } 子类LittleMonkey\npackage com.interface_; public class LittleMonkey extends Monkey{ public LittleMonkey(String name) { super(name); } } 此时，LittleMonkey继承了Monkey，所以很自然的会爬树\n因为悟空需要拓展技能，我们创建接口FishAble和BirdAble\npackage com.interface_; public interface FishAble { public void Swimming(); } package com.interface_; public interface BirdAble { public void flying(); } 而且LittleMonkey也实现了FishAble与BirdAble\npackage com.interface_; public class LittleMonkey extends Monkey implements BirdAble,FishAble{ public LittleMonkey(String name) { super(name); } @Override public void flying() { System.out.println(this.getName()+\u0026#34;通过学习，学会了飞翔\u0026#34;); } @Override public void Swimming() { System.out.println(this.getName()+\u0026#34;通过学习，学会了游泳\u0026#34;); } } 最终，悟空学会了飞翔与游泳\npublic class InterfaceTest { public static void main(String[] args) { LittleMonkey wuKong = new LittleMonkey(\u0026#34;悟空\u0026#34;); wuKong.climbing(); wuKong.flying(); wuKong.Swimming(); } }   实现接口VS继承类\n接口和继承解决的问题不同\n 继承的价值主要在于：解决代码的复用性和可维护性 接口的价值主要在于：设计好各种规范（方法），让它的实现类去实现这些方法。更加的灵活  接口比继承更加灵活\n  继承是满足is-a的关系，而接口只需满足like-a的关系即可。\n比如：猫它是动物(is-a)，而猫像鱼一样会游泳(like-a)\n  接口在一定程度上实现代码解耦（即：接口的规范性+动态绑定机制）\n  接口的多态性   接口类型的变量可以指向实现了接口类的对象实例\npackage com.interface_; public class InterfacePolyParameter { public static void main(String[] args) { //接口的多态体现  IF if01 = new Monster(); if01 = new Car(); } } interface IF{} class Monster implements IF{} class Car implements IF{}     多态参数的体现\n演示一个案例：有一个接口UsbInterface usb，既可以接收手机对象，又可以接收相机对象，就体现了接口的多态（接口引用可以指向实现了接口的类的对象）\n创建接口UsbInterface\npackage com.interface_; public interface UsbInterface { void start(); void stop(); } 创建接口实现类Phone1\npackage com.interface_; public class Phone1 implements UsbInterface{ @Override public void start() { System.out.println(\u0026#34;Phone开始工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Phone停止工作\u0026#34;); } } 创建接口实现类Camera1\npackage com.interface_; public class Camera1 implements UsbInterface{ @Override public void start() { System.out.println(\u0026#34;Camera开始工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Camera停止工作\u0026#34;); } } 创建类Computer01\npackage com.interface_; public class Computer01 { //1. UsbInterface usbInterface 说明Work的形参类型是UsbInterface  //2. 这个参数可以接收实现了UsbInterface接口的类的对象实例  public void Work(UsbInterface usbInterface){ usbInterface.start(); usbInterface.stop(); } } Tset\npackage com.interface_; public class InterfaceTest02 { public static void main(String[] args) { //创建手机对象，Phone1实现了UsbInterface接口  Phone1 phone1 = new Phone1(); //创建相机对象，Camera1实现了UsbInterface接口  Camera1 camera1= new Camera1(); //创建计算机对象  Computer01 computer01 = new Computer01(); //把手机接入电脑  computer01.Work(phone1); System.out.println(\u0026#34;===============\u0026#34;); //把相机接入电脑  computer01.Work(camera1); } } 运行结果\n  多态数组的体现\n演示一个案例：给定Usb数组中，存放Phone和Camera对象，Phone类还有一个特有的方法call()，请遍历Usb数组，如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用Phone特有方法call。\n创建接口Usb\ninterface Usb{ void Work(); } 创建接口实现类Phone2与Camrea2\nclass Phone2 implements Usb{ @Override public void Work() { System.out.println(\u0026#34;Phone工作了\u0026#34;); } public void call(){ System.out.println(\u0026#34;Phone打电话\u0026#34;); } } class Camera2 implements Usb{ @Override public void Work() { System.out.println(\u0026#34;Camera工作了\u0026#34;); } } 创建测试类InterfacePolyAry\npackage com.interface_; public class InterfacePolyAry { public static void main(String[] args) { //多态数组 -\u0026gt;接口类型数组  Usb[] usbs = new Usb[2]; usbs[0] = new Phone2(); usbs[1] = new Camera2(); for (int i = 0; i\u0026lt;usbs.length; i++){ usbs[i].Work();//多态绑定  //需要进行类型的向下转型  if(usbs[i] instanceof Phone2){ ((Phone2) usbs[i]).call(); } } } } 运行结果\n    接口存在多态传递现象（代码演示）\n创建接口InterfacePoly1\ninterface InterfacePoly1{ void hi(); } 创建接口InterfacePoly2继承了接口创建接口InterfacePoly1\ninterface InterfacePoly2 extends InterfacePoly1{ } 创建接口实现类InterfacePolyImp\nclass InterfacePolyImp implements InterfacePoly2{ @Override public void hi() { System.out.println(\u0026#34;hi\u0026#34;); } } 创建测试类InterfacePolyPass\npackage com.interface_; public class InterfacePolyPass { public static void main(String[] args) { //接口类型的变量可以指向实现了该接口的对象实例  InterfacePoly2 interfacePoly2 = new InterfacePolyImp(); //如果InterfacePoly2继承了InterfacePoly1接口，而InterfacePolyImp实现了InterfacePoly2接口  //那么实际上就相当于InterfacePolyImp实现了InterfacePoly1接口  //这就是所谓的接口多态传递现象  InterfacePoly1 interfacePoly1 = new InterfacePolyImp(); } }   ","date":"2021-05-04T16:22:25+08:00","permalink":"https://minster77.github.io/p/javainterface/","title":"JavaInterface"},{"content":"JavaException   什么是异常 异常体系结构 Java异常处理机制 自定义异常 总结   1、什么是异常   软件程序在运行过程中，非常可能遇到一些异常问题，在Java中称为异常。\n  异常指程序运行中出现的不期而至的各种状况，如文件找不到、网络连接错误等。\n  需要掌握的三种类型的异常\n 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常：运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。 错误ERROR：错误不是异常，而是脱离程序员控制的问题。    2、异常体系结构   在Exception分支中有一个重要的子类RuntimeException(运行时异常)\n ArrayIndexOutOfBoundsException(数组下标越界异常) NullPointerException(空指针异常) ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFountException（找不到类）  等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。\n  这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n  Exception与Error的区别\n Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程 Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能去处理这些异常    3、异常处理机制   当编写的代码出现异常时，程序会自动报出现异常错误\npackage com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; System.out.println(a/b); } } 控制台会报出Exception\n  在代码中加入了try\u0026hellip;catch\u0026hellip;finally异常处理机制\npackage com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; try{//监控区域  System.out.println(a/b); }catch (ArithmeticException e){//catch 捕获异常  System.out.println(\u0026#34;程序出现错误，变量b不能为0\u0026#34;); }finally {//处理后续工作  System.out.println(\u0026#34;finally\u0026#34;); } } } finally在异常捕获块中主要用于一些IO流及资源的关闭工作，可以不写。\ncatch里面的参数表示想要捕获的异常类型，Throwable为最高异常\n  假设要捕获多个异常，需要从小到大的去捕获\n  throw与throws主动抛出异常，前者用在方法中，后者用在方法上\npackage com.exception; public class Throw { public static void main(String[] args) { try { new Throw().test(1,0); } catch (ArithmeticException e) { e.printStackTrace(); } } //假设在方法中，处理不了这个异常，就用throws在方法上抛出  public void test(int a,int b)throws ArithmeticException{ if(b==0){ throw new ArithmeticException(); } } }   4、自定义异常   使用Java内置的异常类可以描述在编程中出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即刻。\n  在程序中自定义异常类，大体可以分为一次啊几个步骤：\n 创建自定义异常类 在方法中通过throw关键字抛出异常对象 如果在抛出异常的方法中处理异常，可以使用try\u0026hellip;catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续下一步操作 在出现异常方法类的调用中捕获并处理异常。  创建MyException异常类\npackage com.exception.demo02; //自定义异常类 public class MyException extends Exception{ int a = 5; public MyException(int a){ this.a = a; } @Override public String toString() { return \u0026#34;MyException{\u0026#34; + \u0026#34;a=\u0026#34; + a + \u0026#39;}\u0026#39;; } } 测试类Test\npackage com.exception.demo02; import com.oop.Tset; public class Test { public static void test(int a) throws MyException { System.out.println(\u0026#34;传递的参数为\u0026#34;+a); if(a\u0026gt;5){//如果参数大于5，抛出异常  throw new MyException(a); } System.out.println(\u0026#34;OK\u0026#34;); } public static void main(String[] args) { try { test(10); } catch (MyException e) {//捕获异常  System.out.println(e); } } }   5、总结  处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 对于不确定的代码，也可以加上try-catch处理潜在的异常 尽量去处理异常，切记知识简单地调用printStackTrace去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句去释放占用的资源  ","date":"2021-05-03T16:22:25+08:00","image":"https://minster77.github.io/Java_Exception.jpg","permalink":"https://minster77.github.io/p/javaexception/","title":"JavaException"},{"content":"Java内部类   内部类的基本介绍 局部内部类 匿名内部类 成员内部类 静态内部类   内部类基本介绍   一个类的内部又完整的嵌套了另一个类结构。被嵌套的类又称为内部类，嵌套其他类的类称为外部类。是类的五大成员之一（属性、方法、构造器、代码块、内部类）。\n  内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\n  基本语法\nclass Outer{//外部类  class Inner{//内部类  } } class Other{//外部其他类  }   内部类的分类\n 定义在外部类的局部位置上（比如方法内）：  局部内部类（有类名） 匿名内部类（没有类名，重点！）   定义在外部类的成员位置上：  成员内部类（没用static修饰） 静态内部类（使用static修饰）      局部内部类 说明：局部内部类是定义在外部类的局部位置上的，通常在方法中，并且有类名。\n  可以直接访问外部类的所有成员，包含私有的\n  不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final。（使用了final说明该内部类不能被继承！）\n  作用域：仅仅在定义它的方法或代码块中。\n  局部内部类访问外部类的成员（访问方式：直接访问）\n  外部类访问局部内部类的成员（访问方式：创建对象，再访问[注意，必须在作用域内！]）\n代码演示\npackage com.innerclass; public class LocalInnerClass { public static void main(String[] args) { Outer01 outer01 = new Outer01(); outer01.m2(); } } class Outer01{ private int n = 100; private void m1(){ System.out.println(\u0026#34;m1\u0026#34;); } public void m2(){ //定义为final就不能被继承  //作用域：定义它的方法或代码块中  final class Inner01{//局部内部类  public void f1(){ //访问外部类的成员属性n与m1  System.out.println(\u0026#34;n = \u0026#34;+ n); m1(); } } //外部类调用必须在内部类的作用域内！  Inner01 inner01 = new Inner01(); inner01.f1(); } }     外部其他类不能访问局部内部类！因为局部内部类是一个局部变量\n  如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想要访问外部类的成员，则可以使用(外部类目.this.成员)去访问。\nSystem.out.println(\u0026#34;OuterClass的n2 = \u0026#34;+ OuterClass.this.n2); OuterClass.this本质就是外部类的对象，即哪个对象调用了内部类作用域的方法，OuterClass.this就是哪个对象\n  匿名内部类 说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名（系统的底层有给他分配名字）。\n  匿名内部类的基本语法\nnew 类或接口(参数列表){ //类体 };   匿名内部类的本质（代码演示）\n有一个需求，想要使用AnonInterface接口，并创建对象。\n传统的方式是写一个类，实现该接口，并创建其对象。\nAnonmousInterface接口\ninterface AnonInterface{ public void cry(); } Tiger类\nclass Tiger implements AnonInterface{ public void cry(){ @Override System.out.println(\u0026#34;Titge 在叫\u0026#34;); } } 然后在main函数创建其对象即可\npackage com.innerclass; public class AnonymousInnerClass { public static void main(String[] args) { AnonInterface tiger = new Tiger(); tiger.cry(); } } 如果我们现在的需求改为Tiger类只使用一次，后面不再使用时。我们可以使用匿名内部类来简化开发。\nAnonInterface接口\ninterface AnonInterface{ public void cry(); } 外部类Outer02\nclass Outer02{ private int n = 10; public void method(){ //使用匿名内部类  AnonInterface tiger = new AnonInterface(){ @Override public void cry() { System.out.println(\u0026#34;tiger 在叫\u0026#34;); } }; tiger.cry(); } } main\npackage com.innerclass; public class AnonymousInnerClass { public static void main(String[] args) { Outer02 outer02 = new Outer02(); outer02.method(); } } 上述代码与传统方式均实现了需求，而且上面的代码，Tiger类只使用了一次。这就是匿名内部类的奇妙之处！\n思考：上述外部类Outer02中，Tiger的编译类型及运行类型分别是什么？\n  Tiger的编译类型为接口AnonInterface\n  Tiger的运行类型为匿名内部类 Outer02$1\n其实在使用匿名内部类时，底层是给该内部类分配了名字的\nClass Outer02$1 implements AnonInterface{ @Override pubilc void cry(){ System.out.println(\u0026#34;Tiger 在叫\u0026#34;); } } 我们通过getclass()方法可以验证上述代码。\nSystem.out.println(tiger.getClass()); 而且，在外部类Outer02中，AnonInterface tiger = new AnonInterface()这条语句的执行，jdk底层会在创建匿名内部类Outer02$1时，立刻创建Outer02$1实例，并且把地址返回给tiger\n  需要注意的是：匿名内部类Outer02$1是只使用一次，就不能再使用。而对象Tiger能重复使用！\n基于类构建的匿名内部类也与上述大体一致。\n  匿名内部类的细节\n  匿名内部类的语法比较奇特，需要注意的是，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征。因此可以直接调用匿名内部类的方法。\n代码演示：\n创建Person类\nclass Person{ public void hi(){ System.out.println(\u0026#34;hi\u0026#34;); } public void sayHi(String name){ System.out.println(\u0026#34;Hi \u0026#34;+name); } } 创建外部类Outer03\nclass Outer03{ private int i = 10; public void f1(){ Person person = new Person(){ @Override public void hi() { System.out.println(\u0026#34;匿名内部类重写了Hi方法\u0026#34;); } }; //动态绑定，person的运行类型是Outer03$1  person.hi(); //因为匿名内部类返回的是一个对象（new），所以可以直接调用方法  //在底层 class 匿名内部类 extends Person  new Person(){ @Override public void sayHi(String name) { super.sayHi(name); } }.sayHi(\u0026#34;jack\u0026#34;); } } 创建AnonymousInnerClassDetail\npackage com.innerclass; public class AnonymousInnerClassDetail { public static void main(String[] args) { Outer03 outer03 = new Outer03(); outer03.f1(); } } 输出结果：\n  外部其他类不能访问匿名内部类\n    匿名内部类的实践\n匿名内部类可以当做实参直接传递，简洁高效，避免硬编码\n创建接口InterfaceExercise\ninterface InterfaceExercise{ public void show(); } 创建InnerClassExercise01\npackage com.innerclass; public class InnerClassExercise01 { public static void main(String[] args) { //匿名内部类做形参，简洁高效。  f1(new InterfaceExercise(){ @Override public void show() { System.out.println(\u0026#34;这是一幅名画...\u0026#34;); } }); } //静态方法，参数是接口类型  public static void f1(InterfaceExercise iE){ iE.show(); } } 如果使用实现类实现该接口，那修改一个实现类的对象时会影响到其他的实现类对象。而使用匿名内部类，可以避免这个问题，并且这个类只使用一次即可。\n  成员内部类 说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。\n  可以直接访问外部类的所有成员，包含私有的\n  可以添加任意访问修饰符(public,protected,默认,private)，因为它的地位就是一个成员。\n代码演示：\n创建外部类Outer05\nclass Outer05{ private int i = 10; //定义在成员位置上，可以添加修饰符！  public class Inner04{ public void say(){ //可以访问外部类的私有属性  System.out.println(\u0026#34;成员内部类 i = \u0026#34;+i); } } //因为作用域是方法或代码块内，所以需要写一个方法来使用内部类  public void t1(){ Inner04 inner04 = new Inner04(); inner04.say(); } } 创建测试类MemberInnerClass\npackage com.innerclass; public class MemberInnerClass { public static void main(String[] args) { Outer05 outer05 = new Outer05(); outer05.t1(); } } 运行结果：\n  作用域与外部类的其他成员一样，为整个类体。比如上述案例，在外部类的成员方法中创建成员内部类对象，再调用方法。\n  外部其他类可以访问成员内部类\n外部其他类使用成员内部类的两种方式\n第一种方式\n//第一种方式 //outer05.new Inner04();相当于把 new Inner04()当做是outer05的成员 Outer05.Inner04 inner04 = outer05.new Inner04(); 第二种方式\n//在外部类中编写一个方法，可以返回一个Inner04的值 Outer05.Inner04 getInner04 = outer05.getInner04(); 外部类Outer05中\n//该方法返回一个成员内部类 Inner04 getInner04(){ return new Inner04(); }   静态内部类 说明：静态内部类定义在外部类的成员位置，并且有static修饰\n  可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问非静态成员\n  可以添加任意访问修饰符(public,protected,默认,private)，因为它的地位就是一个成员。\n  作用域：同其他成员，为整个类体\n代码演示\n创建Outer06类\nclass Outer06{ private int n1 = 10; private static int n2 = 100; static class Inner06{ void say(){ System.out.println(\u0026#34;hi n = \u0026#34; + n2); } } void t1(){ Inner06 inner06 = new Inner06(); inner06.say(); } } 创建测试类StaticInnerClass\npackage com.innerclass; public class StaticInnerClass { public static void main(String[] args) { Outer06 outer06 = new Outer06(); outer06.t1(); } } 运行结果：\n  静态内部类要访问外部类的话，可以访问其全部静态成员。\n  外部类访问静态内部类，需要先创建对象，再访问。\n  外部其他类使用静态内部类的方式有两种，与成员内部类的一样。\n  ","date":"2021-05-03T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%86%85%E9%83%A8%E7%B1%BB/","title":"Java内部类"},{"content":"深入面向对象   面向对象三大特性 static关键字详解 抽象类和接口 内部类及OOP实战   面向对象三大特性 封装   我们在程序设计中要追求“高内聚，低耦合”。\n 高内聚：就是类的内部数据操作细节由自己完成，不允许外部干涉 仅暴露少量的方法给外部使用    所以在设计时需要把一些数据与方法封装起来（数据的隐藏）\n  属性私有，get/set调用\n  作用\n 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 增加了系统可维护性    代码演示\nStudent类\npackage com.oop.demo02; //学生类 public class Student { private String name; private int age; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } Test类\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Student s1 = new Student(); s1.setName(\u0026#34;成志恒\u0026#34;); s1.setAge(21); s1.setSex(\u0026#34;男\u0026#34;); System.out.println(s1.getName()+\u0026#34; \u0026#34;+s1.getAge()+\u0026#34; \u0026#34;+s1.getSex()); } }   继承   继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\n  JAVA中类只有单继承，没有多继承\n  在java中，所有类都默认直接或者间接继承Object类\n继承使用关键字extends来表示，代码示例如下\nPerson类\npackage com.oop.demo03; public class Person { public int money = 10000; public String name = \u0026#34;mayun\u0026#34;; } Person类为父类，只定义了两个属性\nStudent类\npackage com.oop.demo03; public class Student extends Person{ public void print(){ System.out.println(this.money+\u0026#34; \u0026#34;+this.name); } } Student类为子类，继承了父类的属性与方法\nTest类\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); student.print(); } } 结果：\n由此可见，在Java中通过extends实现继承关系，而子类可以使用父类中的属性与方法（私有的不能调用）。\n  在继承中，当子类中有与父类相同的属性或方法时，可以使用super关键字来调用父类的属性或方法\n  super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。\n代码示例：\nPerson类\npackage com.oop.demo03; public class Person { public int money = 10000; public String name = \u0026#34;Person\u0026#34;; public void print(){ System.out.println(\u0026#34;Person调用了\u0026#34;); } } Student类\npackage com.oop.demo03; public class Student extends Person{ public int money = 50000; public String name = \u0026#34;Student\u0026#34;; public void print(){ System.out.println(\u0026#34;Student调用了\u0026#34;); } public void test(String name){ System.out.println(name); System.out.println(this.name); System.out.println(super.name); } public void test1(){ print();//子类的方法  this.print();//子类的方法  super.print();//父类的方法  } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); student.test(\u0026#34;成志恒\u0026#34;); System.out.println(); student.test1(); } } 运行结果:\n可以看到，this调用的是Student类中本身的值，super调用了Person类中的值。方法亦如此\n  super调用构造器\nPerson类\npackage com.oop.demo03; public class Person { public Person(){ System.out.println(\u0026#34;Person无参执行了\u0026#34;); } } Student类\npackage com.oop.demo03; public class Student extends Person{ public Student(){ System.out.println(\u0026#34;Student无参执行了\u0026#34;); } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); } } 由此可见在Student类中的无参构造器默认调用了Person类中的无参构造器，即隐藏使用了super()方法。\n需要注意的是，super()方法必须要在子类构造器的第一行，否则系统会报错\n  super的注意点\n super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super与this不能同时调用构造方法    super与this的对比\n  代表的对象不同\nthis：本身调用者这个对象\nsuper：代表父类对象的应用\n  前提\nthis：没有继承也可以使用\nsuper：只能在继承条件才可以使用\n  构造方法\nthis()：本类的构造\nsuper()：父类的构造\n    方法的重写(父类的功能，子类不一定需要，所以要重写)\n 需要有继承关系，子类重写父类的方法，与属性无关 重写只跟非静态方法有关，方法名必须相同 参数列表必须相同 子类的方法必须要和父类的一致，方法体不同 IDEA快捷键：Alt+Insert ：override；  代码：\n父类B\npackage com.oop.demo03; public class B { public static void test1(){ System.out.println(\u0026#34;B==\u0026gt;test\u0026#34;); } public void test2(){ System.out.println(\u0026#34;B==\u0026gt;test\u0026#34;); } } 子类A\npackage com.oop.demo03; public class A extends B { public static void test1(){ System.out.println(\u0026#34;A==\u0026gt;test\u0026#34;); } @Override//注解（重写用）  public void test2() { System.out.println(\u0026#34;A==\u0026gt;test\u0026#34;); } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { A a = new A(); //父类的引用指向了子类  B b = new A(); a.test1(); b.test1(); System.out.println(\u0026#34;==============\u0026#34;); a.test2();//子类重写了父类的方法  b.test2(); } }   静态方法和非静态方法的区别\n 静态方法：方法的调用只与左边定义的数据类型有关 非静态：重写    多态   即同一方法可以根据发送对象的不同而采用多种不同的行为方式\n  一个对象的实际类型是确定的，但可以指向对象的引用类型有很多\n  对象能执行哪些方法，主要看左边的类型，与右边关系不大\n  多态存在的条件\n 有继承关系 子类重写父类的方法 父类引用子类对象  代码示例\nPerson类\npackage com.oop.demo04; public class Person { public void run(){ System.out.println(\u0026#34;run\u0026#34;); } } Student类\npackage com.oop.demo04; public class Student extends Person{ } Test\npackage com.oop.demo04; public class Test { public static void main(String[] args) { //一个对象的实际类型是可以确定的  //new Student  //new Person  //但可以指向的引用类型就不确定了：父类的引用指向子类  Student s1 = new Student(); Person s2 = new Student(); Object s3 = new Student(); s1.run(); s2.run(); } } 可以知道虽然s1，s2，s3的对象都是Student，但是它可以有不同的父类的引用，这就是方法的多态。\n如果子类重写了父类的方法，则执行子类的方法\n在Studunt类中重写run方法\npackage com.oop.demo04; public class Student extends Person{ @Override public void run() { System.out.println(\u0026#34;son run\u0026#34;); } } 运行结果：\n 假如在子类中写一个独有的方法，s2可以调用吗？\nStudent类\npackage com.oop.demo04; public class Student extends Person{ @Override public void run() { System.out.println(\u0026#34;son run\u0026#34;); } public void eat(){ System.out.println(\u0026#34;eat\u0026#34;); } } 在Student类中加了一个eat方法\n如果使用Test类中的s2调用这个方法，系统会报错\n所以父类可以指向子类，但是不能调用子类独有的方法\n  多态的注意事项：\n 多态是方法的多态，属性没有多态性 父类和子类需要有联系，不然会有类型转换异常(ClassCastException)    instanceof 是 Java 的一个二元操作符，类似于 ==，\u0026gt;，\u0026lt; 等操作符。\n  instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。\npackage com.oop.demo05; public class Test { public static void main(String[] args) { //Object \u0026gt; String  //Object \u0026gt; Person \u0026gt; Student  //Object \u0026gt; Person \u0026gt; Teacher  Object object = new Student(); System.out.println(object instanceof Student); System.out.println(object instanceof Person); System.out.println(object instanceof Object); System.out.println(object instanceof String); System.out.println(object instanceof Teacher); } }   ​\t需要注意的是若比较的两个类毫无联系，编译器会报错\n​\t  类型转换\n 父类引用指向子类的对象 把子类转换为父类：向上转型 把父类转换为子类：向下转型，强制转换  package com.oop.demo05; public class Test { public static void main(String[] args) { Student student = new Student(); student.run();//子类能直接调用父类的方法  Person person = student; ((Student)person).eat();//父类调用子类的方法需要强制转换  } }   Static关键字详解   static标注的属性或方法为静态属性或方法。\n  static(静态)方法只会在类加载的时候执行一次。\npackage com.oop.demo06; public class Person { //先与构造方法执行，可以用来定义常量  { System.out.println(\u0026#34;匿名代码块\u0026#34;); } //最先执行，但只执行一次  static { System.out.println(\u0026#34;静态代码块\u0026#34;); } //最后执行  Person(){ System.out.println(\u0026#34;构造方法\u0026#34;); } public static void main(String[] args) { Person person = new Person(); System.out.println(\u0026#34;================\u0026#34;); Person person1 = new Person(); } }   static关键字还可以用来静态导入包\n正常来说要使用Math类的方法每一次都需要在方法前面加\u0026quot;Math.\u0026quot;\nSystem.out.println(Math.random()); 否则会报错\n但是如果通过static导入包的话，就可以直接使用了\npackage com.oop; import static java.lang.Math.random; public class Tset { public static void main(String[] args) { System.out.println(random()); } }   抽象类和接口 抽象类   abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类，那么该类就是抽象类\npackage com.oop.demo08; //抽象类 public abstract class Action { //抽象方法  public abstract void run(); }   抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类\npackage com.oop.demo08; public abstract class Action { public abstract void run(); public void go(){ System.out.println(\u0026#34;go\u0026#34;); } }   抽象类不能new 只能靠子类去实现它\n  抽象类存在的意义：在一些复杂的项目中，把公有属性抽象出来，再使用时只需要继承这个抽象类即可，提高开发效率。\n  接口   接口就是规范，定义的是一组规则，体现了现实世界中“如果你是\u0026hellip;则必须能\u0026hellip;”的思想。\n  接口的本质是契约。\n  接口中的所有定义的方法都是public abstract的；属性为常量。\n  接口定义的关键字为interface，接口都需要有实现类\n接口UserService\npackage com.oop.demo09; public interface UserService { void add(String name); void delete(String name); void update(String name); void query(String name); } 实现类UserServiceImp\npackage com.oop.demo09; //实现了接口的类就必须要实现接口中的所有方法 public class UserServiceImp implements UserService{ @Override public void add(String name) { } @Override public void delete(String name) { } @Override public void update(String name) { } @Override public void query(String name) { } }   利用接口可以实现多继承！\n接口TimeService\npackage com.oop.demo09; import java.sql.Time; public interface TimeService { Time timer(); } 接口RunService\npackage com.oop.demo09; public interface RunService { void run(); } 实现类TestImp\npackage com.oop.demo09; import java.sql.Time; public class TestImp implements TimeService,RunService{ @Override public void run() { } @Override public Time timer() { return null; } }   内部类  内部类就是在一个类的内部再定义一个类,详解见内部类解析  成员内部类 静态内部类 局部内部类 匿名内部类    ","date":"2021-05-02T16:22:25+08:00","image":"https://minster77.github.io/Java_OOP_02.jpg","permalink":"https://minster77.github.io/p/javaoop_02/","title":"JavaOOP_02"},{"content":"初识面向对象   初识面向对象 方法回顾和加深 对象的创建分析   初识面向对象   面向过程思想\n 步骤清晰简单，第一步做什么，第二部做什么\u0026hellip;. 面向过程适合处理一些较为简单的问题    面向对象思想\n 物以类聚，分类的思想模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！    对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。\n  面向对象编程的本质就是：以类的方式组织代码，以对象的形式组织(封装)数据\n  面向对象的三大特性\n 封装：封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。 继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 多态：多态是同一个行为具有多个不同表现形式或形态的能力。    回顾方法和加深   静态方法与非静态方法的调用\n 静态方法定义： 在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。  Student类\npackage com.oop.demo01; public class Student { //静态方法  public static void eat(){ System.out.println(\u0026#34;kazikazi\u0026#34;); } //非静态方法  public void say(){ System.out.println(\u0026#34;hello\u0026#34;); } } Demo01类\npackage com.oop.demo01; public class Demo01 { public static void main(String[] args) { //调用静态方法可以直接调用  Student.eat(); System.out.println(\u0026#34;========================\u0026#34;); //调用非静态方法时需要实例化对象 new  //对象类型 对象名字 = new 对象值；  Student student = new Student(); student.say(); } } 运行结果\n可以知道，静态方法在main方法中调用可以直接调用，非静态方法则需要先实例化类(new一个对象)才能调用\n  值传递\npackage com.oop.demo01; public class Demo02 { public static void main(String[] args) { int a = 1; System.out.println(a);//1  change(a);//实参  System.out.println(a);//1  } //返回值为空  public static void change(int a){//形参  a = 10; } } 上述代码中a的值没有改变是因为实参传递给形参的是值 形参和实参在内存上是两个独立的变量 对形参做任何修改不会影响实参\n 通俗来说就是：小明去餐厅看到别人桌子上的糯米鸡好吃，然后小明就叫服务员点了一份糯米鸡，小明吃完了，别人桌上的却不受影响，因为他们吃的不是同一份糯米鸡。\n   引用传递\npackage com.oop.demo01; public class Demo04 { public static void main(String[] args) { Person person = new Person(); person.name = \u0026#34;高佬\u0026#34;; System.out.println(person.name); Demo04.change(person); System.out.println(person.name); } public static void change(Person person){ //person是一个对象，指向了一个对象  person.name=\u0026#34;志恒\u0026#34;; } } class Person{ String name; } 实参传递给形参的是参数对于 堆内存上的引用地址 实参和 形参在内存上指向 了同一块区域 对形参的修改会影响实参\n  对象的创建分析 对象的创建   对象可以通过new关键字来创建，示例如下\n创建一个Student类\npackage com.oop.demo02; //学生类 public class Student { //属性  String name; int age; //方法  public void print(){ System.out.println(this.name+\u0026#34;学生在学习\u0026#34;); } } Test类\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { /* 类：抽象的，需要实例化 * 类实例化之后会返回一个自己的对象 * student对象就是一个Student类的具体实例 * */ Student student1 = new Student(); Student student2 = new Student(); //给对象赋值  student1.name = \u0026#34;小明\u0026#34;; student1.age = 10; System.out.println(student1.name); System.out.println(student1.age); System.out.println(student2.name); System.out.println(student2.age); } } 运行结果：\n  使用new关键字创建的时候，除了分配空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用。\n  构造器   构造器又叫构造方法，在进行创建对象的时候必须要调用的。并且构造器有一下两个特点：\n 必须和类的名字相同 必须没有返回类型，也不能写void  作用\n 使用new关键字，本质就是在调用构造器 初始化对象的值  注意点\n 定义有参构造之后，如果想使用无参构造，就必须显示的定义一个无参的构造   ait+Insert IDEA生成构造器的快捷键\n   构造器代码示例：\nPerson类：\npackage com.oop.demo02; public class Person { //一个类即使什么都不写，它都会存在一个方法（构造器）  //显示的定义构造器  String name; int age; //无参构造  public Person() { } //有参构造：一旦定义了有参构造，无参就必须显示定义  public Person(String name,int age) { this.name = name; this.age = age; } } Test类：\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Person person = new Person(\u0026#34;minster\u0026#34;,21); System.out.println(person.name+\u0026#34; \u0026#34;+person.age); } }   对象的内存分析   首先先创建一个简单的Pet类\npackage com.oop.demo02; public class Pet { String name; int age; public Pet() { } public Pet(String name, int age) { this.name = name; this.age = age; } public void shout(){ System.out.println(this.name+\u0026#34;在叫\u0026#34;); } } Tset\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Pet dog = new Pet(\u0026#34;旺财\u0026#34;,3); Pet cat = new Pet(\u0026#34;cat\u0026#34;, 3); dog.shout(); cat.shout(); } } 内存分析图\n在内存中，创建一个对象，栈空间中存放的是对象的引用，而堆空间中存放的是new出来的东西，栈、堆两个空间通过一个内存地址相互连接。\n  ","date":"2021-05-01T16:22:25+08:00","image":"https://minster77.github.io/Java_OOP_01.jpg","permalink":"https://minster77.github.io/p/javaoop_01/","title":"JavaOOP_01"},{"content":"Java数组   数组概述 数组声明创建 java内存分析 数组使用 多维数组 Arrays类 冒泡排序 稀疏数组   数组概述  数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 每一个数据称作一个数组元素，数组元素可以通过一个下标来访问  数组声明与创建   首先必须声明数组变量，才能在程序中使用数组(声明时数组并不存在)。声明方法：\ndataType[] arrayRefvar;\t//首选方法 dataType addayRefvar[];\t//效果相同，但不是首选方法   java语言使用new操作符来创建方法(创建后数组就存在了)，语法如下：\ndataType[] arrayRefvar = new dataType[arraySize];   数组的元素是通过索引访问的，数组索引从0开始\n  获取数组长度：arrays.length\n  联系：给数组赋值并累加求值\npackage com.heng.array; public class Demo01 { public static void main(String[] args) { int[] arrays = new int[10]; int sum = 0; for (int i = 0; i \u0026lt;arrays.length ; i++) { arrays[i] = i; } for (int i = 0; i \u0026lt;arrays.length ; i++) { sum+=arrays[i]; } System.out.println(sum); } }   初始化\npackage com.heng.array; public class Demo02 { public static void main(String[] args) { //静态初始化:创建+赋值  int[] a = {1,2,3,4}; Demo01[] demo01s = {new Demo01(),new Demo01()}; //动态初始化  int[] b = new int[10]; } }   数组的四个基本特点\n 数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同的数据类型，不允许出现混合类型 数组中的元素可以是任何类型，包括基本类型和引用类型 数组可以看做一个对象，Java对象是在堆中的，数组对象本身是在堆中的。    数组边界\n数组的合法区间：[0,length-1],如果越界就就会报错！\npackage com.heng.array; public class Demo03 { public static void main(String args[]){ int[] a = new int[2]; System.out.println(a[2]);//越界！  } }   Java内存分析   堆\n 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用    栈\n 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址）    方法区\n 可以被所有的线程共享 包含了所有的class和static变量    java内存分析图示\n  数组使用   For-Each循环\npackage com.heng.array; public class Demo04 { public static void main(String[] args) { int[] array = {1,2,3,4,5}; for (int i : array) { System.out.println(i); } } }   数组作为参数\npackage com.heng.array; public class Demo05 { public static void main(String[] args) { int[] arrays = {1,2,3,4,5}; printArrays(arrays); } public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } } }   数组做返回值\npackage com.heng.array; public class Demo05 { public static void main(String[] args) { int[] arrays = {1,2,3,4,5}; int[] reverse = reverse(arrays); printArrays(reverse); } //反转数组  public static int[] reverse(int[] arrays){ int[] result = new int[arrays.length]; for (int i = 0,j=result.length-1; i \u0026lt; arrays.length; i++,j--) { result[j] = arrays[i]; } return result; } //打印数组  public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } } }   多维数组   多维数组可以看成是数组的数组。例如一个二维数组就是一个特殊的一维数组，每一个元素都是一个一维数组\n  多维数组的组成\npackage com.heng.array; public class Demo06 { public static void main(String[] args) { //创建一个二维数组  int[][] arrays = {{1,2},{3,4},{5,6},{7,8}}; /* * 相当于一个四行二列 [4][2] * {1,2} arrays[0] * {3,4} arrays[1] * {5,6} arrays[2] * {7,8} arrays[3] * */ //打印arrays[0]所得的结果为arrays[0]的地址  System.out.println(arrays[0]); System.out.println(\u0026#34;==================\u0026#34;); //但是通过printArrays函数打印就能把arrays[0]的值打印出来  printArrays(arrays[0]); System.out.println(\u0026#34;==================\u0026#34;); //或者用二维数组打印方式打印  System.out.println(arrays[0][0]+\u0026#34; \u0026#34;+arrays[0][1]); } public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } System.out.println(); } }   Arrays类   数组的工具类java.util.Arrays\n  该类包含用于操作数组的各种方法（如排序和搜索）。\npackage com.heng.array; import java.util.Arrays; public class Demo07 { public static void main(String[] args) { int[] a = {2,4,5,6,71,1,15,48,89,12,545}; System.out.println(Arrays.toString(a)); Arrays.sort(a);//排序方法 ：升序  System.out.println(Arrays.toString(a)); } }   冒泡排序   冒泡排序是最常用的八大排序算法之一，通过嵌套循环实现\n  冒泡排序的原理\n 比较数组中两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置 每一次比较都会产生一个最大或者最小的数字 下一轮则可以少一次排序 一次循环，直到结束    示例代码\npackage com.heng.array; import java.util.Arrays; public class Demo08 { public static void main(String[] args) { int[] a = {1,5,10,55,2,444,64,50}; System.out.println(Arrays.toString(a));\tSystem.out.println(\u0026#34;=================\u0026#34;); int[] sort = sort(a); //调用完排序方法后，返回一个排序后的数组  System.out.println(Arrays.toString(a)); } public static int[] sort(int[] array){ //临时变量  int temp = 0; //外层循环，判断我们要走多少次  for (int i = 0; i \u0026lt; array.length-1; i++) { //通过flag标识减少没有意义的比较  boolean flag = false; //内层循环，比较判断两个数，交换位置  for (int j = 0; j \u0026lt; array.length-1-i; j++) { if(array[j+1]\u0026gt;array[j]){ temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; flag = true; } } if(flag==false){ break; } } return array; } }   稀疏数组   稀疏数组就是一种数据结构\n  当一个数组中大部分元素为0，或者为同一值得数组时，可以使用稀疏数组来保存该数组。\n  稀疏数组的处理方式是：\n 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序的规模    原始数组转换成稀疏数组\npackage com.heng.array; public class Demo09 { public static void main(String[] args) { //五子棋游戏：创建一个二维数组 11*11 0：没有旗子 1：黑棋 2：白棋  int[][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; //输出原始的数组  System.out.println(\u0026#34;输出原始的数组\u0026#34;); for (int[] ints:array1) { for (int anInt:ints) { System.out.print(anInt+\u0026#34;\\t\u0026#34;); } System.out.println(); } //转换为稀疏数组  //获取有效值的个数  int sum = 0; for (int i = 0; i \u0026lt; 11; i++) { for (int j = 0; j \u0026lt; 11; j++) { if(array1[i][j]!=0){ sum++; } } } System.out.println(\u0026#34;有效值为：\u0026#34;+sum); //创建一个稀疏数组  int[][] array2 = new int[sum+1][3]; array2[0][0] = 11; array2[0][1] = 11; array2[0][2] = sum; //遍历二维数组，将非0的值存放到稀疏数组中  int count = 0; for (int i = 0; i \u0026lt; array1.length; i++) { for (int j = 0; j \u0026lt; array1[i].length; j++) { if(array1[i][j]!=0){ count++; array2[count][0] = i; array2[count][1] = j; array2[count][2] = array1[i][j]; } } } //输出稀疏数组  System.out.println(\u0026#34;输出稀疏数组\u0026#34;); for (int i = 0; i \u0026lt; array2.length; i++) { System.out.println(array2[i][0]+\u0026#34;\\t\u0026#34; +array2[i][1]+\u0026#34;\\t\u0026#34; +array2[i][2]+\u0026#34;\\t\u0026#34;); } } }   稀疏数组还原\n//输出稀疏数组  System.out.println(\u0026#34;输出稀疏数组\u0026#34;); for (int i = 0; i \u0026lt; array2.length; i++) { System.out.println(array2[i][0]+\u0026#34;\\t\u0026#34; +array2[i][1]+\u0026#34;\\t\u0026#34; +array2[i][2]+\u0026#34;\\t\u0026#34;); } System.out.println(\u0026#34;=======================\u0026#34;); System.out.println(\u0026#34;还原\u0026#34;); //稀疏数组转换成原始数组  //1.读取稀疏数组  int[][] array3 = new int[array2[0][0]][array2[0][1]]; //2.给其中的元素还原值  for (int i = 1; i \u0026lt; array2.length; i++) { array3[array2[i][0]][array2[i][1]] = array2[i][2]; } System.out.println(\u0026#34;输出还原后的数组\u0026#34;); for (int[] ints:array1) { for (int anInt:ints) { System.out.print(anInt+\u0026#34;\\t\u0026#34;); } System.out.println(); }   ","date":"2021-04-20T16:22:25+08:00","image":"https://minster77.github.io/cover04.jpg","permalink":"https://minster77.github.io/p/javaarray/","title":"JavaArray"},{"content":"Java集合类(四)   开发中如何选择集合实现类 TreeSet底层源码剖析 TreeMap底层源码剖析 Collections工具类 集合章节练习题   开发中如何选择集合实现类  在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：   先判断存储的类型（一组对象[单列]或一组键值对[双列]） 一组对象[单列]：Collection接口  允许重复：List  增删多：LinkedLike（底层维护了一个双向链表） 改查多：ArrayList（底层维护了Object类型的可变数组）   不允许重复：Set  无序：HashSet（底层是HashMap，维护了一个哈希表【数组+链表+红黑树】） 排序：TreeSet 插入和取出顺序一致：LinkeHashSet（底层是LinkedHashMap），维护了数组+双向链表     一对键值对：Map  键无序：HashMap（底层是哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树） 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap（底层是HashMap） 读取文件：Properties    TreeSet底层源码剖析   TreeSet的底层就是TreeMap\n key不允许重复。    TreeSet可以实现有序排序，但是当我们使用其无参构造器时，仍然是无序的。要使用TreeSet提供的一个构造器，传入一个比较器（匿名内部类）才能实现排序\n下面使用TreeSet对数据进行排序（按字符串长度比较）\n创建测试类TreeSet_\npackage com.conllection_.sets; import java.util.Comparator; import java.util.TreeSet; public class TreeSet_ { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度进行比较  return ((String)o1).length() - ((String)o2).length(); } }); treeSet.add(\u0026#34;jack\u0026#34;); treeSet.add(\u0026#34;tom\u0026#34;); treeSet.add(\u0026#34;a\u0026#34;); treeSet.add(\u0026#34;ha\u0026#34;); treeSet.add(\u0026#34;xiaohu\u0026#34;); System.out.println(\u0026#34;treeSet = \u0026#34; +treeSet); } } debug调试，我们可以看到TreeSet此时使用的构造器\npublic TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } 可以发现，该构造器把我们的一个比较器（匿名内部类）对象传到了TreeSet的底层TreeMap\npublic TreeMap(Comparator\u0026lt;? super K\u0026gt; comparator) { this.comparator = comparator; } 并且把比较器对象赋给了TreeMap的属性comparator。\n在调用treeSet.add(\u0026ldquo;tom\u0026rdquo;);时，在底层会执行put的方法\npublic boolean add(E e) { return m.put(e, PRESENT)==null; } 继续往下走，可以发现程序执行以下代码\nint cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths //cpr为我们传进去的匿名内部类 Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; //动态绑定到我们的匿名内部类对象，且调用了其compare方法。  cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else//如果两个元素比较后相等，即返回0，这个key就不能加入进去  return t.setValue(value); } while (t != null); } 此时的treeSet集合如下\n运行结果\n需要注意的是，排序规则可以自己定义，按照需求来定义。\n  TreeMap底层源码剖析   TreeMap机制与TreeSet大体一致，但TreeMap是键值对方式存储数据\n  TreeMap底层实现的是Entry数组\n创建TreeMap_测试类\npackage com.conllection_.maps; import java.util.Comparator; import java.util.TreeMap; public class TreeMap_ { public static void main(String[] args) { //使用有参构造，重写比较器  TreeMap treeMap = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { //按照字符串长度进行比较  return ((String)o1).length()-((String)o2).length(); } }); treeMap.put(\u0026#34;jack\u0026#34;,\u0026#34;杰克\u0026#34;); treeMap.put(\u0026#34;tom\u0026#34;,\u0026#34;汤姆\u0026#34;); treeMap.put(\u0026#34;xiaohu\u0026#34;,\u0026#34;小虎\u0026#34;); treeMap.put(\u0026#34;mary\u0026#34;,\u0026#34;玛丽\u0026#34;);//替换杰克  System.out.println(\u0026#34;treeMap = \u0026#34;+ treeMap); } } 调试程序，执行put方法，首次添加时会进行初始化\nEntry\u0026lt;K,V\u0026gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check  root = new Entry\u0026lt;\u0026gt;(key, value, null); size = 1; modCount++; return null; } 因为此时只有一个元素，不能进行比较，所以就直接添加到Entry里面了\n继续添加元素，程序执行以下代码\nint cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } 此时会调动到比较器进行比较，与TreeSet不同的是当key值比较结果相同时，程序会把新增的key的value值替换掉原来的key的value值。\n需要注意的是，key不能为null\n  Collections工具类   Collections是一个操作Set、List和Map等集合的工具类\n  Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n  排序操作（均为static方法）\n reverse(List)：反转List中元素的顺序 shuffle(List)：对List集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定List集合元素按升序排序 sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序 swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换  代码演示\n创建Collections01测试类\npackage com.collections_; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Collections02 { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;smith\u0026#34;); list.add(\u0026#34;h\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 1. reverse(List)：反转List中元素的顺序  Collections.reverse(list); System.out.println(\u0026#34;将list反转后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 2. shuffle(List)：对List集合元素进行随机排序  Collections.shuffle(list); System.out.println(\u0026#34;将list元素进行随机排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 3. sort(List)：根据元素的自然顺序对指定List集合元素按升序排序  Collections.sort(list); System.out.println(\u0026#34;自然排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 4. sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序  Collections.sort(list, new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度排序  //可以加入一些校验代码，提高严谨性  return ((String)o1).length()-((String)o2).length(); } }); System.out.println(\u0026#34;按字符串长度排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 5. swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换  Collections.swap(list,1,3); System.out.println(\u0026#34;将下标为1的元素与下标为3的元素互换\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); } } 运行结果：\n  查找、替换\n Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素 Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素 int frequency(Collection,Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值  代码演示\n创建Collections02测试类\npackage com.collections_; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Collections02 { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;smith\u0026#34;); list.add(\u0026#34;h\u0026#34;); System.out.println(\u0026#34;List = \u0026#34;+list); // 1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素  System.out.println(\u0026#34;返回自然顺序中的最大元素\u0026#34;); System.out.println(\u0026#34;然顺序中的最大元素是\u0026#34;+Collections.max(list)); // 2. Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素  System.out.println(\u0026#34;返回Comparator指定的顺序中的最大元素\u0026#34;); //比如返回字符串长度最长元素  Object maxObject = Collections.max(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String)o1).length() - ((String) o2).length(); } }); System.out.println(\u0026#34;字符串长度最长元素是\u0026#34; + maxObject); // 3. Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 // 4. Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素 // 5. int frequency(Collection,Object)：返回指定集合中指定元素的出现次数  System.out.println(\u0026#34;tom出现的次数为\u0026#34; + Collections.frequency(list, \u0026#34;tom\u0026#34;)); // 6. void copy(List dest,List src)：将src中的内容复制到dest中  ArrayList dest = new ArrayList(); for (int i = 0; i \u0026lt; list.size(); i++) { dest.add(\u0026#34;\u0026#34;); } Collections.copy(dest,list); System.out.println(\u0026#34;dest = \u0026#34;+ dest); // 7. boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值  Collections.replaceAll(list,\u0026#34;tom\u0026#34;,\u0026#34;汤姆\u0026#34;); System.out.println(\u0026#34;替换后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34; + list); } } 运行结果：\n需要注意的是，使用copy时，dest数组的大小必须大于src数组，否则会报数组越界异常\nint srcSize = src.size(); if (srcSize \u0026gt; dest.size()){ throw new IndexOutOfBoundsException(\u0026#34;Source does not fit in dest\u0026#34;); }   本章练习题   试分析HashSet和TreeSet分别如何实现去重的\n  HashSet去重机制：HashSet是通过hashCode()+equals()方法实现去重的。底层先通过hashCode方法计算出key对应的hash值，然后通过hash值查找在table表上对应索引位置上是否已经存在值。如果该位置上不存在值，则直接把key添加进去。否则通过equals方法遍历比较新增的key与已存在的key是否相同，相同就把key加入到已存在的key的后面，否则不添加。equals方法可以自定义比较的内容。\n  TreeSet去重机制：如果你在定义TreeSet时传入了一个Comparator匿名内部类（比较器），就使用该比较器中定义的compare方法实现去重。如果返回是0，则说明添加元素相同，不添加。如果你没有传入一个Comparator匿名内部类，系统会通过你添加的对象实现的Comprareable接口的compareTo实现去重。\nelse { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //把k指向key对象的类型实现的Comparable接口  Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; //动态绑定compareTo方法  cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); }     分析下面代码运行会不会抛出异常，并从源码层面说明原因\nTreeSet treeSet = new TreeSet(); treeSet.add(new Person()); class Person{ } 会抛出ClassCastException异常\n因为在定义TreeSet时没有传进去一个Comparator匿名类，所以在执行add的时候，程序会进入下述代码中\nelse { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //把k指向key对象的类型实现的Comparable接口  Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; //动态绑定compareTo方法  cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } 又因为Person类并没有实现Comparable接口，所以运行到第6行代码处时会抛出ClassCastException异常。\n  已知：Person类按照id和name重写了hashCode与equals方法。下面代码会输出什么？\nExercises04测试类\npackage com.collections_; import java.util.HashSet; import java.util.Objects; public class Exercises04 { public static void main(String[] args) { Person p1 = new Person(1001,\u0026#34;AA\u0026#34;); Person p2 = new Person(1002,\u0026#34;BB\u0026#34;); HashSet set = new HashSet(); set.add(p1); set.add(p2); System.out.println(set); p1.name = \u0026#34;CC\u0026#34;; set.remove(p1); System.out.println(set); set.add(new Person(1001,\u0026#34;CC\u0026#34;)); System.out.println(set); set.add(new Person(1001,\u0026#34;AA\u0026#34;)); System.out.println(set); } } Person类\nclass Person{ public int id; public String name; public Person(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(id, name); } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 输出结果为\n为什么set.remove(p1);执行了却没有remove成功呢？\n因为在执行remove方法之前，我们把p1的name值改变了**p1.name = \u0026ldquo;CC\u0026rdquo;;**而且我们在Person类中重写了hashCode方法，所以我们把name值改变的同时导致p1对应的hash值也发生改变。而我们观看remove的源码可以知道\nfinal Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) 此处传进去的hash值为p1更改后hash值而辅助变量p却指向了table表中的p1，即hash值为table的hash值\nif ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) 因为两个hash值不同，所以在接下来的几个if判断中结果都为false\nfinal Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, index; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) { Node\u0026lt;K,V\u0026gt; node = null, e; K k; V v; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))//False  node = p; else if ((e = p.next) != null) {//False  if (p instanceof TreeNode) node = ((TreeNode\u0026lt;K,V\u0026gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } //False  if (node != null \u0026amp;\u0026amp; (!matchValue || (v = node.value) == value || (value != null \u0026amp;\u0026amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 所以最后只能return null；然后回到remove方法\npublic V remove(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } 因为removeNode方法return null，所以返回到remove也只能return null 即修改失败。\n而后面添加\nset.add(new Person(1001,\u0026#34;CC\u0026#34;)); set.add(new Person(1001,\u0026#34;AA\u0026#34;)); 可以成功，原理跟上述图示一样\n因为后面添加的Person(1001,\u0026ldquo;AA\u0026rdquo;)同上面一样是指向索引为3处（该处为null），所以添加成功\n而Person(1001,\u0026ldquo;AA\u0026rdquo;)添加成功是因为此时索引为1出的Person值的name已发生改变。且计算出来的Hash值与索引为1处对应。所以该Person添加到索引为1处的Person后面\n  ","date":"2021-04-16T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%9B/","title":"Java集合类（四）"},{"content":"JavaMethod   什么是方法 方法的定义及调用 方法重载 命令行传参 可变参数 递归   何谓方法   方法是语句的结合，他们在一起执行一个功能。\n 方法是解决一类问题的步骤的有序组合 方法包含于类中 方法在程序中被创建，在其地方被引用    设计方法时，最好保持方法的原子性，就是一个方法只完成一个功能，这样子利于我们后期的拓展。\n  命名规则：首字母小写的驼峰命名法\n  方法创建及使用\npackage com.heng.method; public class Demo01 { //main方法  public static void main(String[] args) { int sum = add(1,3); System.out.println(sum); } //add方法  public static int add(int a , int b){ return a+b; }   方法的定义及调用  方法的定义    方法包含一个方法头和一个方法体。以下是一个方法的所有部分\n  修饰符：定义了该方法的访问类型\n  返回值类型：方法会根据所需返回对应的值得类型，当无需返回值时，方法的类型是void\n  方法名：是方法的实际名称，方法名和参数表共同构成方法签名\n  参数类型：参数像是一个占位符。有实参与形参，也可以不包含参数\n 形参：在方法被调用时用于接收外界输入的数据 实参：调用方法是实际传给方法的数据  public class Demo01 { public static void main(String[] args) { //实际参数：实际调用传递给他的参数  int sum = add(1,3); System.out.println(sum); } //形式参数，用来定义作用的  public static int add(int a , int b){ return a+b; }   方法体：方法体包含具体的语句。定义了方法的功能\npublic static int add(int a,int b){ /* 修饰符:public static * 返回值类型:int * 方法名:add * 参数类型:int 参数名:a */ return a+b;//方法体  }     return除了放回值之外也可以终止方法。\n  方法的调用   调用方法：对象名.方法名（实参列表）  方法的重载   重载是在一个类中，有相同的函数名称，但形参不同的函数。\n  方法重载的规则\n 方法名必须相同。 参数类别必须不同（个数不同、类型不同、参数排列顺序不同等） 方法的返回类型可以相同也可以不同 仅仅返回类型不同不足以成为方法的重载    下面代码两个方法名都为max 但方法类型不同，所以两个方法重载\npackage com.heng.method; public class Demo02 { public static void main(String[] args) { //调用double类型的返回方法  double max = max(20,30); //根据需要的类型调用方法  System.out.println(max); } public static int max(int num1,int num2){ int result = 0; if(num1==num2){ System.out.println(\u0026#34;num1=num2\u0026#34;); return 0;//终止方法  } if(num1\u0026gt;num2){ result = num1; }else { result = num2; } return result; } public static double max(double num1,double num2){ double result = 0; if(num1==num2){ System.out.println(\u0026#34;num1=num2\u0026#34;); return 0;//终止方法  } if(num1\u0026gt;num2){ result = num1; }else { result = num2; } return result; } }   命令行传参   有时候你希望运行一个程序再传递给它消息，这要靠传递命令行参数给main()函数实现\npackage com.heng.method; public class Demo03 { public static void main(String[] args) { for (int i = 0; i \u0026lt; args.length; i++) { System.out.println(\u0026#34;args[\u0026#34;+i+\u0026#34;]:\u0026#34;+args[i]); } } } 上述代码需要先进入到命令行模式编译成.class文件\n编译完成后，生成了一个class文件\n最后在命令行模式下执行Demo03.class；同时向main()函数传参\n需要注意的是执行class文件需要返回到src目录下才能执行\n  可变参数   可变参数又可以叫做不定项参数（本质就是数组）\n  在方法声明中，在指定参数类型后加一个省略号(\u0026hellip;)即表示可变参数\n  一个方法中只能指定一个可变参数，他必须是方法的最后一个参数。任何普通的参数必须在它之前声明\n  代码演示：\npackage com.heng.method; public class Demo04 { public static void main(String[] args) { //新建一个对象  Demo04 demo04 = new Demo04(); //调用对象方法  demo04.printMax(34,3,2,4,1,5.5); demo04.printMax(new double[]{1,2,3}); } public void printMax(double... number){ if(number.length==0){ System.out.println(\u0026#34;没有参数\u0026#34;); return; } double result = number[0]; //排序  for (int i = 1; i \u0026lt; number.length; i++) { if(number[i]\u0026gt;result){ result = number[i]; } } System.out.println(\u0026#34;max=\u0026#34;+result); } }   递归   递归结构包括两部分：\n 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环 递归体：什么时候调用自身方法。    需要注意的是递归是把函数堆压在栈里面的，如果递归的次数太多，栈内存会不过，即系统会报错\n  递归代码演示：\npackage com.heng.method; public class Demo05 { public static void main(String[] args) { Demo05 demo05 = new Demo05(); int result = demo05.f(5); System.out.println(result); } public int f(int i){ if(i==1){ return 1; }else { return i*f(i-1); } } } 上述代码的执行过程\n  ","date":"2021-04-08T16:22:25+08:00","image":"https://minster77.github.io/cover03.jpg","permalink":"https://minster77.github.io/p/javamethod/","title":"JavaMethod"},{"content":"Java集合类(三)   Map接口实现类的特点和常用方法 Map接口的六大遍历方式 Map小结及HashMap底层源码分析 Hashtable基本介绍   Map接口实现类的特点和常用方法 Map接口的特点 注意：这里讲的是Jdk8的Map接口特点\n  Map与Collection并列存在。用于保存具有映射关系的数据：key-value\n  Map中的key和value可以是任何引用类型的数据，会封装到HashMao$Node对象中\n  Map中的key不允许重复，原因和HashSet一样\n  Map中的value可以重复\n  Map的key可以为null，value也可以为null，但是key为null的结点只能有一个，value为null的结点可以有多个\n  常用String类作为Map的key\n  key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n代码演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class Map_ { public static void main(String[] args) { Map map = new HashMap(); //key不可以重复，重复的会被等价替换  //value可以重复  map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  map.put(\u0026#34;no1\u0026#34;,\u0026#34;张三丰\u0026#34;);//当有相同的key，就等于等价替换  map.put(\u0026#34;no3\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  //key只能有一个null  map.put(null,null); map.put(null,\u0026#34;abc\u0026#34;);//等价替换  //value可以多个为null  map.put(\u0026#34;no4\u0026#34;,null); map.put(\u0026#34;no5\u0026#34;,null);//value可以多个为null  map.put(1,\u0026#34;赵敏\u0026#34;); //通过get方法，传入key，会返回对应的value  System.out.println(map.get(\u0026#34;no3\u0026#34;)); System.out.println(\u0026#34;map = \u0026#34; + map); } }   Map接口k-v详解\n  Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的。因为Node实现了Entry接口，所以有些书上也说一对k-v就是一个Entry。\n  k-v 数据最后是存放在HashMap$Node node = newNode(hash,key,value,null) 这个对象里面的。\n  k-v 为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry。而一个Entry对象本身就具有key，value值。所以有EntrySet\u0026lt;Entry\u0026lt;K,V\u0026raquo;，即\ntransient Set\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; entrySet;   EntrySet中，定义的类型是Map.Entry，但是实际上存放的还是HashMap$Node。原因如下\nstatic class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt;   由于Map.Entry提供了两个重要的方法：K getKey(); V getValue() ，所以当我们把HashMap$Node对象存放到EntrySet就可以方便我们的遍历。\n程序演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; import java.util.Set; public class MapSource { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  Set set = map.entrySet(); for (Object obj:set) { //向下转型  Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey() + \u0026#34;-\u0026#34; + entry.getValue()); } System.out.println(\u0026#34;Map = \u0026#34; + map); } } 输出结果：\nkeySet()：与Node封装到EntrySet集合一样，不过他是封装到Set集合，利用该方法可以单独遍历Key值\nvalues：与Node封装到EntrySet集合一样，不过他是封装到Collection集合，利用该方法可以单独遍历Value值\nSet set1 = map.keySet(); System.out.println(set1); Collection values = map.values(); System.out.println(values); 运行结果\n  Map接口的常用方法   put()：添加元素\n  remove()：根据键删除映射关系\n  get()：根据键获取值\n  size()：获取元素的个数\n  isEmpty()：判断元素个数是否为0\n  clear()：清除集合键值对\n  containsKey()：查找键是否存在\n代码演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class MapMethod { public static void main(String[] args) { Map map = new HashMap(); // 1. put()：添加元素  map.put(\u0026#34;no1\u0026#34;,new Book(\u0026#34;小王子\u0026#34;,100)); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;); map.put(\u0026#34;no2\u0026#34;,\u0026#34;史森明\u0026#34;); map.put(\u0026#34;no3\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(\u0026#34;no4\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(null,\u0026#34;小虎\u0026#34;); map.put(\u0026#34;no5\u0026#34;,null); System.out.println(\u0026#34;map = \u0026#34; + map); // 2. remove()：根据键删除映射关系  map.remove(\u0026#34;no3\u0026#34;); System.out.println(\u0026#34;map = \u0026#34; + map); // 3. get()：根据键获取值  System.out.println(map.get(\u0026#34;no1\u0026#34;)); // 4. size()：获取元素的个数  System.out.println(map.size()); // 5. isEmpty()：判断元素个数是否为0  System.out.println(map.isEmpty()); // 6. clear()：清除集合键值对  map.clear(); System.out.println(map.isEmpty()); System.out.println(map.size()); // 7. containsKey()：查找键是否存在  map.put(\u0026#34;no1\u0026#34;,new Book(\u0026#34;小王子\u0026#34;,100)); System.out.println(map.containsKey(\u0026#34;no1\u0026#34;)); System.out.println(map.containsKey(\u0026#34;no5\u0026#34;)); } } class Book{ private String name; private double price; public Book(String name, double price) { this.name = name; this.price = price; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } }   Map接口的六大遍历方式   遍历以下Map接口的元素\nimport java.util.Set; public class MapFor { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;); map.put(\u0026#34;no2\u0026#34;,\u0026#34;史森明\u0026#34;); map.put(\u0026#34;no3\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(\u0026#34;no4\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(null,\u0026#34;小虎\u0026#34;); map.put(\u0026#34;no5\u0026#34;,null); } }     使用keySet()+增强for遍历k-v\nSystem.out.println(\u0026#34;=====第一种遍历方式=====\u0026#34;); Set keySet = map.keySet(); for (Object key : keySet) { System.out.println(key+\u0026#34;=\u0026#34;+map.get(key)); } 运行结果\n  使用keySet()+迭代器遍历k-v\nSystem.out.println(\u0026#34;=====第二种遍历方式=====\u0026#34;); Iterator iterator = keySet.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next+\u0026#34;=\u0026#34;+map.get(next)); } 运行结果\n  使用values()+增强for遍历value（因为value不能映射key，所以只能遍历value）\nSystem.out.println(\u0026#34;=====第三种遍历方式=====\u0026#34;); Collection values = map.values(); for (Object value : values) { System.out.println(value); } 运行结果\n  使用values()+迭代器遍历\nSystem.out.println(\u0026#34;=====第四种遍历方式=====\u0026#34;); Iterator iterator1 = values.iterator(); while (iterator1.hasNext()) { Object next = iterator1.next(); System.out.println(next); } 运行结果\n  使用EntrySet()+增强for遍历\nSystem.out.println(\u0026#34;=====第五种遍历方式=====\u0026#34;); Set entrySet = map.entrySet(); for (Object obj : entrySet) { //将obj转成Map.Entry  Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey()+\u0026#34;-\u0026#34;+entry.getValue()); } 运行结果\n  使用EntrySet()+迭代器遍历\nSystem.out.println(\u0026#34;=====第六种遍历方式=====\u0026#34;); Iterator iterator2 = entrySet.iterator(); while (iterator2.hasNext()) { Object next = iterator2.next(); Map.Entry entry = (Map.Entry)next; System.out.println(entry.getKey()+\u0026#34;-\u0026#34;+entry.getValue()); } 运行结果\n  HashMap练习题   使用HashMap添加三个元素对象，要求：\n 键：员工ID，值：员工对象 遍历显示工资\u0026gt;18000的员工（遍历方法两种） 员工类：姓名、工资、员工id  员工类Staff代码如下\nclass Staff{ private String name; private double wages; private int id; public Staff(String name, double wages, int id) { this.name = name; this.wages = wages; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getWages() { return wages; } public void setWages(double wages) { this.wages = wages; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \u0026#34;Staff{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, wages=\u0026#34; + wages + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } } 测试类MapExercise代码如下\npackage com.conllection_.maps; import java.util.*; public class MapExercise { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;01\u0026#34;,new Staff(\u0026#34;成志恒\u0026#34;,19000,01)); map.put(\u0026#34;02\u0026#34;,new Staff(\u0026#34;史森明\u0026#34;,20000,02)); map.put(\u0026#34;03\u0026#34;,new Staff(\u0026#34;小虎\u0026#34;,17000,03)); map.put(\u0026#34;04\u0026#34;,new Staff(\u0026#34;李元浩\u0026#34;,18000,04)); System.out.println(\u0026#34;===第一种方式===\u0026#34;); //使用entrySet方法返回映射中包含的映射的 Set 视图  Set entrySet = map.entrySet(); //利用增强for循环遍历  for (Object o : entrySet) { //向下转型，为了能调用父类的方法  Map.Entry entry = (Map.Entry)o; //把value对象指向从entry集中取出来的value  Object value = entry.getValue(); //向下转型，这样可以使用Staff对象的getWages方法。  Staff staff = (Staff) value; if(staff.getWages()\u0026gt;18000){ System.out.println(staff.toString()); } } System.out.println(\u0026#34;===第二种方式===\u0026#34;); //使用keySet()方法返回封装到Map封装到Set里面的结点的Key值  Set set = map.keySet(); //创建迭代器  Iterator iterator = set.iterator(); while (iterator.hasNext()) { //获取迭代器中的数据  Object next = iterator.next(); //向下转型，吧staff对象指向从map里面取到的value对象。  Staff staff1 = (Staff) map.get(next); if (staff1.getWages()\u0026gt;18000){ System.out.println(staff1); } } } } 运行结果：\n上述题目中，数据的封装情况如下图\n所以当我们需要取出value值时，我们需要先通过EntrySet取出Entry，然后通过Entry的指向取到HashSet$Node的值。\n  Map小结及HashMap底层源码分析 Map小结   Map接口的常用实现类：HashMap、Hashtable和Properties\n  HashMap是Map接口使用频率最高的实现类\n  HashMap是以key-value对的方式来存储数据的\n  key不能重复，但是value可以重复，允许使用null键（只能有一个）和null值（可以多个）\n  如果添加相同的可以，则会覆盖原来的key-value，等同于修改。（key不会替换，value会替换）\nif (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //此处e指向替换前的Node，所以 e.value = value;即可完成替换  e.value = value; afterNodeAccess(e); return oldValue; }   与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。\n  HashMap没有实现同步，因此线程是不安全的。方法没有做同步互斥的操作，没有synchronize\n  HashMap底层机制及源码剖析   HashMap底层机制示意图\n（key，value）是一个Node实现了Map$Entry\u0026lt;K,V\u0026gt;\n  HashMap的扩容机制[和HashSet扩容机制相同]\n HashMap底层维护了Node类型的数组table，默认为null 当创建对象时，将加载因子(loadfactor)初始化为0.75 当添加key-value是，通过key的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换value；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。 第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12 如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），否则任然采用数组扩容机制  源码分析\n创建MapSource类\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class MapSource { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  map.put(\u0026#34;no1\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  } } 调试程序，执行HashMap的无参构造器，=。\npublic HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 将负载因子(loadFactor)初始化并且创建一个空的table。\n向HashMap集合添加元素，执行put方法\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 通过hash方法计算key的Hash值，然后返回给putVal方法。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 执行putVal方法，程序首先判断table是否为null，如果为null就table的容量扩容到16\nif ((tab = table) == null || (n = tab.length) == 0){ n = (tab = resize()).length; } 实现扩容的方法为risize()方法。\n继续调试，程序会判断当前hash值对应的table索引位置上是否已经存在值，如果不存在值，就把当前Hash值的结点赋值进去。\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 然后modCount++（记录修改的次数），size++（记录已添加元素的个数）；\n倘若当前hash值对应的table索引位置上已存在值，首先会判断当前索引位置上的hash值是否与需要添加的key值对应的hash值相同且满足以下两个条件之一：\n 准备添加的key值与p指向的Node结点的key是同一个对象 p指向的Node结点的key的equals()和准备假如的key比较后相同。  如果上述条件皆成立，直接让e指向p（p为当前索引位置上的结点）,e为辅助变量\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ e = p; } 然后继续执行，把需要添加的key值对应的value值替换掉原先存在的key值的value值\nif (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 返回修改后的value值。\n倘若上述条件不成立，程序会继续进行判断，判断需要添加的结点是否为树结点\nelse if (p instanceof TreeNode){ e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); } 如果是树结点，会执行putTreeVal()方法，把需要添加的树节点添加到红黑树上。\n如果不是树节点，程序会继续调试，进入到下一个else。\nelse { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } 在此处程序会进入一个死循环，直至找到对应索引位置上的尾结点或者找到key相同的结点才会退出。详细见HashSet底层添加元素源码分析的最后一步。\n  模拟HashMap触发扩容、树化情况，并debug验证   创建测试类MapSource01\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; import java.util.Objects; public class MapSource01 { public static void main(String[] args) { Map map = new HashMap(); for (int i=0; i\u0026lt;12;i++){ map.put(new A(i),\u0026#34;hello\u0026#34;); } System.out.println(map); } } 创建A类，重写HashCode方法，让他们有统一的Hash值\nclass A{ private int no; public A(int no) { this.no = no; } public int getNo() { return no; } @Override public int hashCode() { return 100; } public void setNo(int no) { this.no = no; } @Override public String toString() { return \u0026#34;\\nA{\u0026#34; + \u0026#34;no=\u0026#34; + no + \u0026#39;}\u0026#39;; } } 运行调试，直至添加到第9个元素，因为达到树化的条件（一条链表的元素个数到达8个），但table的大小\u0026lt;MIN_TREEIFY_CAPACITY(默认是64)，所以table会扩容。\n继续调试，table再次扩容，直至table扩容到容量为64时，该链表会发生树化\n  Hashtable Hashtable的基本介绍   Hashtable存放的元素时键值对：即K-V\n  Hashtable的键和值都不能为null，否则会抛出NullPointerException\nif (value == null) { throw new NullPointerException(); }   Hashtable使用方法基本上和HashMap一样\n  Hashtable是线程安全的（synchronize），HashMap是线程不安全的\n  Hashtable底层的简单剖析\n  底层有数组 Hashtable$Entry[]，初始化大小为11\n  临界值 threshold = 8 （11*0.75）\n创建HashtableSource类调试\npackage com.conllection_.maps;\rimport java.util.Hashtable;\rpublic class HashtableSource {\rpublic static void main(String[] args) {\rHashtable hashtable = new Hashtable();\rhashtable.put(\u0026quot;john\u0026quot;,100);\rhashtable.put(\u0026quot;jack\u0026quot;,100);\rhashtable.put(\u0026quot;mary\u0026quot;,200);\rhashtable.put(\u0026quot;tom\u0026quot;,300);\rhashtable.put(\u0026quot;smith\u0026quot;,500);\rhashtable.put(\u0026quot;minster\u0026quot;,600);\rhashtable.put(\u0026quot;chris\u0026quot;,200);\rhashtable.put(\u0026quot;ssm\u0026quot;,500);\rSystem.out.println(\u0026quot;hashtable = \u0026quot; + hashtable);\r}\r}\r调试程序，我们可以发现\n  Hashtable按照自己的扩容机制进行扩容\n继续调试HashtableSource，执行put方法，可以发现该接口添加元素时执行了addEntry方法把添加的K-V封装到Entry\nprivate void addEntry(int hash, K key, V value, int index) { modCount++; Entry\u0026lt;?,?\u0026gt; tab[] = table; //当增加的元素数量大于或等于临界值时，执行rehash方法进行扩容  if (count \u0026gt;= threshold) { // Rehash the table if the threshold is exceeded  rehash(); tab = table; hash = key.hashCode(); index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry.  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; e = (Entry\u0026lt;K,V\u0026gt;) tab[index]; tab[index] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); count++; } 执行rehash方法进行扩容。下面截取部分rehash源码。\nprotected void rehash() { int oldCapacity = table.length; Entry\u0026lt;?,?\u0026gt;[] oldMap = table; // overflow-conscious code  //进行扩容  int newCapacity = (oldCapacity \u0026lt;\u0026lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets  return; newCapacity = MAX_ARRAY_SIZE; } //指向扩容后的Entry  Entry\u0026lt;?,?\u0026gt;[] newMap = new Entry\u0026lt;?,?\u0026gt;[newCapacity]; } 我们可以发现，当容量达到临界值时，rehash方法会通过 **int newCapacity = (oldCapacity \u0026laquo; 1) + 1;**这条语句进行扩容。所以hashtable第一次扩容后的容量为23（11*2+1）；\n  HashMap与Hashtable对比 Properties   Properties类继承于Hashtable类并实现了Map接口，也是使用一种键值对的形式来保存数据\n  他的使用特点和Hashtable类似\n  Properties还可以用了从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改\n  xxx.properties文件通常作为配置文件，详解见Java读取properties配置文件\nProperties的简单使用\nProperties_类\npackage com.conllection_.maps; import java.util.Properties; public class Properties_ { public static void main(String[] args) { //Properties 继承了Hashtable  //Properties 也是通过k-v存储数据，当然key与value都不能为null  Properties properties = new Properties(); //添加元素  properties.put(\u0026#34;jack\u0026#34;,1); properties.put(\u0026#34;john\u0026#34;,2); properties.put(\u0026#34;tom\u0026#34;,\u0026#34;2\u0026#34;); System.out.println(\u0026#34;properties = \u0026#34;+properties); //删除元素  properties.remove(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;properties = \u0026#34;+properties); //修改元素  properties.put(\u0026#34;jack\u0026#34;,3);//替换  System.out.println(\u0026#34;properties = \u0026#34;+properties); //查找元素  System.out.println(properties.get(\u0026#34;jack\u0026#34;)); System.out.println(properties.getProperty(\u0026#34;tom\u0026#34;)); } } 运行结果\n需要注意的是，使用getPeoperties时，当put进去的值不是String类型的时候，会返回null\n例如在Properties类中添加以下代码\nproperties.put(\u0026#34;jack\u0026#34;,1); System.out.println(properties.getProperty(\u0026#34;jack\u0026#34;)); 阅读getProperty源码，我们可以发现其中原理\npublic String getProperty(String key) { //把oval指向key对应的value  Object oval = super.get(key); //使用三目运算符，当oval是String类型时，返回强转为String类型的oval，否则为null  String sval = (oval instanceof String) ? (String)oval : null; //当sval为null，且设定了defaults的值时，返回defaultsValue，否则返回sval  return ((sval == null) \u0026amp;\u0026amp; (defaults != null)) ? defaults.getProperty(key) : sval; }   ","date":"2021-04-08T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%89/","title":"Java集合类（三）"},{"content":"Java流程控制   用户交互Scanner 顺序结构 选择结构 循环结构 break\u0026amp;continue 练习   用户交互Scanner   通过Scanner类来获取用户的输入\n  基础语法：\nScanner s = new Scanner(System.in);   通过Scanner类的next()方法获取输入的字符串，需要使用hasNext()判断是否还有输入的数据\npackage com.heng.scanner; import java.util.Scanner; public class demo01 { public static void main(String[] args) { //创建一个扫描器对象，用于接收用户输入的数据  Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;用next方式接收：\u0026#34;); //判断用户有没有输入字符串  if(scanner.hasNext()){ //使用next的方式来接收  String str = scanner.next(); System.out.println(\u0026#34;输出的内容为：\u0026#34;+str); } //凡是属于IO流的类如果不关闭就会一直浪费资源。所以要用完就关闭  scanner.close(); } } 因为使用next方法接收，所以空格后面的字符不能被str接收，因此可以使用nextLine()方法操作\n  通过nextLine()方法获取输入的字符串，需要使用hasNextLine()判断是否还有输入的数据\npackage com.heng.scanner; import java.util.Scanner; public class demo02 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;用nextLine方式接收：\u0026#34;); //判断是否还有输入  if(scanner.hasNextLine()){ //通过nextLine()方法来接收  String str = scanner.nextLine(); System.out.println(\u0026#34;输出的内容为：\u0026#34;+str); } scanner.close(); } }   next()方法与nextLine()方法都能用来接收输入的内容，大多数情况使用后者\n  scanner的进阶用法\n  scanner类中有许多个方法来接收不同的数据\n例：利用scanner类中方法来接收数字并求出其和以及平均值\npackage com.heng.scanner; import java.util.Scanner; public class demo03 { public static void main(String[] args) { //输入多个数字，求出其总和以及平均数，每输入一个数字用回车确认，通过输入非数字来结算循环  Scanner scanner = new Scanner(System.in); //用于计算总和  double sum = 0; //用于统计输入的数据个数.  int m = 0; System.out.println(\u0026#34;请输入数据:\u0026#34;); //用while循环来判断是否还有输入，并且在里面累加求和  while (scanner.hasNextDouble()){ double x = scanner.nextDouble(); m=m+1; sum = sum + x; System.out.println(\u0026#34;你输入了第\u0026#34;+m+\u0026#34;个数，当前总和sum=\u0026#34;+sum); } System.out.println(m+\u0026#34;个数的和为:\u0026#34;+sum); System.out.println(m+\u0026#34;个数的平均值为:\u0026#34;+(sum/m)); scanner.close(); } }     顺序结构  Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行 顺序结构是最基本的算法结构 顺序结构是任何一个算法都离不开的一个结构  选择结构 3.1 if单选择结构     语法结构\npackage com.heng.struct; import java.util.Scanner; public class Demo01 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入内容：\u0026#34;); String s = scanner.nextLine(); //equals:判断字符串是否相等  if(s.equals(\u0026#34;Hello\u0026#34;)){ System.out.println(s); } System.out.println(\u0026#34;END\u0026#34;); } }   3.2 if双选择结构   !if(布尔表达式){ //如果布尔表达式为true }else{ //如果布尔表达式为false }   3.3 if多选择结构   语法结构\nif(布尔表达式1){ //如果布尔表达式1的值为true 执行 }else if(布尔表达式2){ //如果布尔表达式2的值为true 执行 }else if(布尔表达式3){ //如果布尔表达式3的值为true 执行 }else { //如果以上布尔表达式都不为true 执行 }   else语句必须在所有的else if语句后面\n  if嵌套结构\nif(布尔表达式1){ if(布尔表达式2){ //执行  } }   3.4 switch选择结构   语法结构\nswitch(expression){ case value: //语句  break; case value: //语句  break; //可以有任意数量个case语句  default ://可选 一般在最后  //语句  }   switch语句中变量可以使 byte、short、int、char在jdk7之后还支持String类型\n  但字符的本质还是数字\npackage com.heng.struct; public class SwitchDemo01 { public static void main(String[] args) { String name = \u0026#34;志恒\u0026#34;; switch (name){ case \u0026#34;小胖\u0026#34; : System.out.println(\u0026#34;小胖\u0026#34;); break; case \u0026#34;志恒\u0026#34; : System.out.println(\u0026#34;志恒\u0026#34;); break; case \u0026#34;松涛\u0026#34; : System.out.println(\u0026#34;松涛\u0026#34;); break; default: System.out.println(\u0026#34;查无此人\u0026#34;); } } }   反编译 Java\u0026mdash;\u0026mdash;\u0026gt;class文件\u0026mdash;\u0026mdash;\u0026gt;反编译（IDEA实现）\n  需要注意的是case具有穿透性 如果不加break或继续执行后面的case\npackage com.heng.struct; public class SwitchDemo02 { public static void main(String[] args) { char grade = \u0026#39;B\u0026#39;; switch (grade){ case \u0026#39;A\u0026#39;: System.out.println(\u0026#34;优秀\u0026#34;); break; case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;良好\u0026#34;); case \u0026#39;C\u0026#39;: System.out.println(\u0026#34;及格\u0026#34;); case \u0026#39;D\u0026#39;: System.out.println(\u0026#34;不及格\u0026#34;); break; default: System.out.println(\u0026#34;未知等级\u0026#34;); } } }   循环结构 4.1 while循环   只要布尔表达式结果为true就会一直执行\n  用一个表达式失效的方式来结束循环\nwhile(布尔表达式){ //语句 }   4.2 do\u0026hellip;while循环   布尔表达式的值为false do\u0026hellip;while循环也会执行一次\n  do\u0026hellip;while循环至少会执行一次\ndo{ //语句 }while(布尔表达式);     while与do\u0026hellip;while的区别\n while先判断后执行；do\u0026hellip;while先执行后判断 do\u0026hellip;while总是保证循环体至少执行一次。  package com.heng.struct; public class WhileDemo01 { public static void main(String[] args) { int a= 0; while(a\u0026lt;0){ System.out.println(a); a++; } System.out.println(\u0026#34;====================\u0026#34;); do { System.out.println(a); a++; }while (a\u0026lt;0); } }   4.3 For循环   语法结构\nfor(初始化;布尔表达式;更新){ //代码语句 }   for循环数支持迭代的一种通用结构，是最有效的、最灵活的循环结构\n  用for循环打印九九乘法表\npackage com.heng.struct; public class ForDemo04 { public static void main(String[] args) { int sum = 0; for (int i = 1; i \u0026lt;= 9; i++) { for (int j = 1; j \u0026lt;= i; j++) { sum = i*j; System.out.print(j+\u0026#34;*\u0026#34;+i+\u0026#34;=\u0026#34;+sum+\u0026#34;\\t\u0026#34;); } System.out.println(); } } }   增强For循环\npackage com.heng.struct; public class ForDemo05 { public static void main(String[] args) { int [] number= {10,20,30,40,50}; //首先看基本的for循环遍历数组  for(int i=0;i\u0026lt;number.length;i++){ System.out.println(number[i]); } System.out.println(\u0026#34;===================\u0026#34;); //下面是增强型for循环遍历  for(int x:number){ System.out.println(x); } } }   break与continue 5.1 break   在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环不执行循环体的剩余语句\n  switch中的break可以避免case的穿透性\n  5.2 continue   continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定\n  java中可以使用标签（goto）\npackage com.heng.struct; public class LabelDemo { public static void main(String[] args) { //求101-150之间的质数  int count = 0; //outer为标签  outer:for (int i = 0; i \u0026lt; 101; i++) { for(int j = 2;j\u0026lt;(i/2);j++){ if(i %j==0){ continue outer;//continue直接跳出到最外面的循环  } } System.out.print(i+\u0026#34; \u0026#34;); } } }   练习   打印一个五行的三角形\npackage com.heng.struct; public class TestDemo01 { public static void main(String[] args) { //打印三角形  /* * 所打印的三角形就是用空格+“*”组成 * 所以一开始进入循环1 打印倒三角的空格 * 然后进入循环二，打印三角形的一半 * 最后进入循环三，将三角形补全 * */ for (int i = 1; i \u0026lt;= 5; i++) { for(int j=5;j\u0026gt;=i;j--){ System.out.print(\u0026#34; \u0026#34;);//循环1 打印倒三角的空格  } for (int j = 1; j \u0026lt;=i ; j++) { System.out.print(\u0026#34;*\u0026#34;);//循环2 打印了三角形的左半部分  } for (int j = 1; j \u0026lt;i ; j++) { System.out.print(\u0026#34;*\u0026#34;);//循环3 将三角形补全  } System.out.println(); } } }   ","date":"2021-04-06T16:22:25+08:00","image":"https://minster77.github.io/cover02.jpg","permalink":"https://minster77.github.io/p/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"Java流程控制"},{"content":"Java集合类(二)   Set接口和常用方法 HashSet全面说明  思考 HashSet底层解析 HashSet底层添加元素源码分析 HashSet扩容机制和转换红黑树机制源码解析 threshold补充说明   LinkedHashSet说明及源码分析  LinkedHashSet全面说明 LinkedHashSet底层机制示意图 LinkedHashSet底层源码分析     Set接口和常用方法   Set接口基本介绍\n 无序（添加和取出的顺序不一致），没有索引 不允许重复元素，所以最多包含一个null JDK API中Set接口常用的实现类有：HashSet、TreeSet等    Set接口的常用方法\n 和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。（详情见Java集合类(一)）    以Set接口的实现类HashSet来讲解Set接口的方法\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class SetMethod { public static void main(String[] args) { Set set = new HashSet(); set.add(\u0026#34;john\u0026#34;); set.add(\u0026#34;jack\u0026#34;); set.add(\u0026#34;tom\u0026#34;); set.add(\u0026#34;john\u0026#34;); set.add(null); set.add(null); System.out.println(\u0026#34;set = \u0026#34; + set); } } 运行结果：\n结论：\n set接口的实现类的对象（set接口对象），不能存放重复的元素，可以添加null set接口对象存放数据是无序（即添加的顺序和取出的顺序不一致） 取出的顺序虽然不是添加的属性，但是顺序是固定的！    Set接口的遍历方式\n同Collection的便利方式一样，因为Set接口是Collection接口的子接口。\n  使用迭代器\nSystem.out.println(\u0026#34;===迭代器遍历===\u0026#34;); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(\u0026#34;set = \u0026#34;+next); }   增强for\nSystem.out.println(\u0026#34;增强for遍历\u0026#34;); for (Object o: set) { System.out.println(\u0026#34;set = \u0026#34;+o); }   不能使用索引的方式来获取\n    HashSet全面说明   HashSet实现了Set接口\n  HashSet实际上是HashMap\npublic HashSet() { map = new HashMap\u0026lt;\u0026gt;(); }   可以存放null值，但是只能有一个\n  HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序与取出顺序一致）\n  不能有重复元素或对象\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class HashSet01 { public static void main(String[] args) { Set hashSet = new HashSet(); /*说明 * 1. 在执行add方法后，会返回一个Boolean值 * 2. 如果添加成功，返回true，否则返回false * 3. 可以通过remove指定删除哪个对象 * */ System.out.println(hashSet.add(\u0026#34;mary\u0026#34;));//T  System.out.println(hashSet.add(\u0026#34;mary\u0026#34;));//F  hashSet.add(\u0026#34;jack\u0026#34;);//可以添加  hashSet.add(\u0026#34;jack\u0026#34;);//添加失败  //由于下面每一次add都新建了一个Dog对象  //所以下面两个Dog对象都会添加成功  hashSet.add(new Dog(\u0026#34;tom\u0026#34;)); hashSet.add(new Dog(\u0026#34;tom\u0026#34;)); System.out.println(\u0026#34;HashSet = \u0026#34;+ hashSet); hashSet.remove(\u0026#34;mary\u0026#34;);//删除mary  System.out.println(\u0026#34;HashSet = \u0026#34;+ hashSet); } }   思考   下面两个String对象都会被添加到HashSet集合里面去吗？\nhashSet.add(new String(\u0026#34;czh\u0026#34;)); hashSet.add(new String(\u0026#34;czh\u0026#34;)); 运行的结果是仅有一个数据被添加，为什么呢？\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) 因为此时String类型重写的equals()方法是比较其字符串内容是否相同，所以此时添加的两个“czh”数据只有一个能被添加进去。\n而上述Dog对象的添加原理也是类似。\n下面我们通过解读HashSet的底层结构解决这个问题！\n  HashSet底层解析   因为HashSet的底层是HashMap，所以分析HashMap底层是（数组+链表+红黑树）即可\n为了更好理解HashMap的底层，下面模拟一个简单的数组+链表结构\n创建Node结点\n//结点Node，item存储数据，next指向下一个结点，可以形成链表 class Node{ Object item; Node next; public Node(Object item, Node next) { this.item = item; this.next = next; } } 创建HashSetStructure类\npackage com.conllection_.sets; public class HashSetStructure { public static void main(String[] args) { //1. 创建一个类型为Node的数组  Node[] nodes = new Node[16]; //2. 创建结点  Node john = new Node(\u0026#34;john\u0026#34;, null); nodes[2] = john; Node jack = new Node(\u0026#34;jack\u0026#34;, null); john.next = jack; Node mary = new Node(\u0026#34;mary\u0026#34;, null); jack.next = mary; Node lucy = new Node(\u0026#34;lucy\u0026#34;, null); nodes[3] = lucy; System.out.println(\u0026#34;node = \u0026#34;+nodes); } } 运行结果：\n  HashSet底层添加元素源码分析   分析HashSet添加元素的底层是如何实现的（hash()+equals()）\n HashSet底层就是HashMap 添加一个元素时，先通过hash()得到hash值，然后转换成索引值 找到存储数据表table，看这个索引位置是否已经存放了元素  如果没有，直接添加 如果有元素，调用equals比较，如果元素内容相同，就放弃添加，如果不相同，则添加到最后   在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。 当元素个数到达TREEIFY_THRESHOLD但table的大小小于MIN_TREEIFY_CAPACITY(默认64)时，系统会把table表填扩容到64，然后进行树化。    HashSet添加元素的源码解读\n创建HashSetSource类，用于debug\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class HashSetSource { public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\u0026#34;jack\u0026#34;); hashSet.add(\u0026#34;tom\u0026#34;); hashSet.add(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;set = \u0026#34; + hashSet); } }   执行构造器\npublic HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } 可以清晰地知道HashSet的底层就是HashMap\n  执行add()方法\npublic boolean add(E e) {//e=\u0026#34;jack\u0026#34;  return map.put(e, PRESENT)==null; } PRESENT是hashSet为了能使用hashMap而定义的一个常量（定值），无论添加了多少的元素它都不会变化\nprivate static final Object PRESENT = new Object();   执行put()方法\npublic V put(K key, V value) {//key = \u0026#34;jack\u0026#34;  return putVal(hash(key), key, value, false, true); } value为PRESENT,是共享的。\n  执行hash方法，计算key的hash值\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 如果key != null，程序会执行Object类中的hashCode()方法来获取key的值，并将它进行无符号右移16位（为了防止key的hashCode值发生冲突），最后得到的h为key对应的hash值。\nhash值并不是hashCode，因为(h = key.hashCode()) ^ (h \u0026raquo;\u0026gt; 16)\n  获取到hash值后，执行putVal方法（重要！）\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;//定义了辅助变量  if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 在此方法中，因为辅助变量tab的初始值为null，所以进入到resize()方法，给tab表赋予初始大小。\nif ((tab = table) == null || (n = tab.length) == 0){ n = (tab = resize()).length; } 上述代码中的table为hashMap的一个属性，类型为Node[]\n因为初始的table为null，所以执行resize()方法\n//下面代码为resize()方法的一些初始赋值 Node\u0026lt;K,V\u0026gt;[] oldTab = table;//结点oleTab表示原先的表 //oldCap表示初始表的容量大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldThr为当前表的一个临界值，当达到临界值时会扩容 int oldThr = threshold; int newCap, newThr = 0; 因为初始的table为null，所以oldCap为0，所以进入到下述语句\nelse { // zero initial threshold signifies using defaults  newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } DEFAULT_INITIAL_CAPACITY为hashMap定义的常量，大小为16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 所以newCap= 16，即第一次扩容大小为16\nnewThr为表的一个临界值，是使用负载因子DEFAULT_LOAD_FACTOR乘以初始大小等到的一个值。\n 默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\n 使用newThr是为了减少冲突，增加一个缓冲区，避免在多线程向表中增加数据时，表的内存不够而导致死锁。\n初始化tap的大小之后，会判断**(p = tab[i = (n - 1) \u0026amp; hash])**是否为null，(n - 1) \u0026amp; hash是位运算，详解见HashMap数学原理。计算出来的i为该key值在table表中的索引位置。\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 如果p=null，表示还没有存放元素，执行**tab[i] = newNode(hash, key, value, null);**创建一个Node（key=“jack\u0026quot;,value=PRESENT）把hash也放进Node是为了下次添加元素时比较。\n执行完毕，此时我们可以发现此时table表中已经在刚刚计算出来的索引值上添加了“jack”。\n到此为止，HashMap的第一次添加元素分析完毕。\n当我们向HashMap集合表再次添加数据时，系统会计算其hash值，然后通过\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 方法判断该hash值对应的索引位置上是否已经存在值，如果不存在，即把新增的key添加到表中的该索引位置上。\n此时可以发现，table表上多了一个数据\n如果该hash值对应的索引位置上已经存在值，程序会跳到下面语句\n//p为当前索引位置上对应的链表的第一个元素，即已经添加的值 //所以p.hash为已存在值得hash值，p.key为已存在值得key值 if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ e = p; } 如果当前索引位置上对应的链表的第一个元素的hash值与需要添加的key的hash值一样\n且满足以下两个条件之一：\n 准备添加的key值与p指向的Node结点的key是同一个对象 p指向的Node结点的key的equals()和准备假如的key比较后相同。  需要注意的是，此时equals()方法不能理解为只比较字符串内容是否相同，因为每一个类都会有其对应的equals()方法，所以equals()方法的比较内容可以由程序员所重写的方法来决定！\n此时说明新增加的key值已存在，所以该key值不会被添加到table中。\n若不满足上述条件，程序会继续往下走，执行下面语句。\nelse if (p instanceof TreeNode){ e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); } 上述语句会判断p是否为红黑树，如果是红黑树，就调用putTreeVal进行添加。\n如果p不是红黑树，执行以下代码\nelse { for (int binCount = 0; ; ++binCount) { //这是条件1  if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } //这是条件2  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } 因为在可以执行上述代码时，说明此时table表中是使用链表的方式来存储数据 。\n此时进入一个死循环，退出的条件：\n  条件1：在要加入的位置i = (n - 1) \u0026amp; hash处所形成的链表没有一个结点与要加入的结点相同时，退出循环，此时就加在最末尾。添加成功\n  条件2 :在要加入的位置i = (n - 1) \u0026amp; hash处所形成的链表有结点与要加入的结点相同，此时退出循环，添加失败\n  两个条件结合起来使用\n需要注意的是当我们把元素添加到聊表后，会进行以下判断\nif (binCount \u0026gt;= TREEIFY_THRESHOLD - 1){ // -1 for 1st \ttreeifyBin(tab, hash); } 判断链表是否已经达到8个结点（TREEIFY_THRESHOLD=8）。如果到达，则调用treeifyBin(tab, hash)方法对当前链表进行树化（转换成红黑树）。\n注意，在转换成红黑树时，treeifyBin(tab, hash)方法会进行判断\nif (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY){ resize(); } 判断table表大小是否\u0026lt;64，如果小于64，会先将table表进行扩容，再进行树化。\n    HashSet扩容机制和转换红黑树机制源码解析   HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）=16*负载因子（loadFactor）0.75 = 12\n  如果数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是 32 * 0.75 = 24，依次类推\n  在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），否则任然采用数组扩容机制\n创建测试类HashSetIncrement.java\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Objects; public class HashSetIncrement { public static void main(String[] args) { HashSet hashSet = new HashSet(); for (int i = 1; i \u0026lt;=12; i++) { hashSet.add(new A(i)); } System.out.println(\u0026#34;hashSet = \u0026#34;+ hashSet); } } Class A\nclass A { private int n ; public A(int n) { this.n = n; } @Override public int hashCode() { return 100; } } 在HashSetIncrement类中的for循环处加一个断点，debug。可以发现，当i=9时，即满足一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，此时触发转换红黑树机制。\n但是此时不满足table表大小\u0026gt;=64\nif (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY){ resize(); } 所以此时table表会进行扩容。\n继续执行，可以发现table再次扩容。\n再继续执行，可以发现此时链表已经发生树化（转换成红黑树）\n树化过程的源码\nelse if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } 详细解释见Jdk1.8集合框架之HashMap源码解析\n  threshold补充说明   在putVal方法中，有这么一行代码\n++modCount; if (++size \u0026gt; threshold){ resize(); } afterNodeInsertion(evict); modCount代表我们对table表修改的次数。\n其中size是每当我们加入一个结点Node(key,value,hash,next)，size++。\n所以当我们想table表中加入指定数量的Node结点是，也会触发扩容机制。\n代码演示HashSetIncrement类\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Objects; public class HashSetIncrement { public static void main(String[] args) { HashSet hashSet = new HashSet(); for (int i = 1; i \u0026lt;=7; i++) { hashSet.add(new A(i)); } for (int i = 1; i \u0026lt;=7; i++) { hashSet.add(new B(i)); } System.out.println(\u0026#34;hashSet = \u0026#34;+ hashSet); } } Class A 与 Class B\nclass B { private int n ; public B(int n) { this.n = n; } @Override public int hashCode() { return 200; } } class A { private int n ; public A(int n) { this.n = n; } @Override public int hashCode() { return 100; } } 运行调试，可以发现，虽然我们在一条链表上增加了7个元素，然后第二条链表增加到第五个元素时size=12，也触发了扩容机制\n所以触发扩容机制的前提是累积添加元素到达threshold。\n  ​\nLinkedHashSet说明及源码分析 LinkedHashSet全面说明  LinkedHashSet是HashSet的子类。 LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表。 LinkedHashSet根据元素的HashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是一插入顺序保存的。 LinkedHashSet不允许添加重复元素。  LinkedHashSet底层机制示意图   示意图\n  双向链表具体机制与LinkedList底层结构类似。\n  LinkedHashSet底层源码分析 说明\n  在LInkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n  每个节点有before和after属性，这样可以形成双向链表\n  在添加一个元素时，先求hash值，再求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加；原则跟hashset一样）\n  所以，我们遍历LinkedHash可以确定插入顺序和取出顺序一致\n创建LinkedHashSetSource类，用于分析源码\npackage com.conllection_.sets; import java.util.LinkedHashSet; import java.util.Set; public class LinkedHashSetSource { public static void main(String[] args) { Set set = new LinkedHashSet(); set.add(new String(\u0026#34;AA\u0026#34;)); set.add(456); set.add(456); set.add(123); set.add(\u0026#34;czh\u0026#34;); System.out.println(\u0026#34;LinkedHashSet = \u0026#34; + set); } } 可以知道，添加第一次时，系统会将数组table扩容到16，存放的结点类型是LinkedHashMap$Entry\n为什么数组时HashMap$Node[]类型，而存放的元素/数据却是LinkedHashMap$​​​​Entry呢？\n下面我们查看LinkedHashMap底层源码来解决这个问题。\nstatic class Entry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { Entry\u0026lt;K,V\u0026gt; before, after; Entry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } } 我们可以发现上面这个在LinkedHashMap源码中的静态内部类Entry继承了HashMap.Node。即数组的多态。双向链表实现的关键也是在这里。\n继续往下调试\n此时的map与hashSet的不一样，多了几个属性。其中head表示双向链表中的头结点，tail表示尾结点。\n而每一个结点又有before与after属性，指向上一个结点与下一个结点。\n所以LinkedHashSet可以实现按顺序插入及取出。\n进入add()方法\npublic boolean add(E e) { return map.put(e, PRESENT)==null; } 可以知道LinkedHashSet添加元素底层就是HashSet添加元素的底层（因为LinkedHashSet是HashSet的实现子类）\n  ","date":"2021-04-06T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/","title":"Java集合类（二）"},{"content":"Java集合类（一）    集合的概念\n  Collection接口和常用方法\n  List接口和常用方法\n  ArrayList底层源码即注意事项\n  Vector底层结构和源码解析\n  LinkedList底层结构和源码解析\n   集合的概念   由于前面保存多个数据使用的是数组，而数组保存数据会有一些不足的地方。\n 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型的元素 使用数组进行增加元素/删除会比较麻烦    若使用集合来处理数据的话，这类问题将会减少。集合的好处如下：\n 可以动态保存任意多个对象，使用比较方便！ 提供了一系列方便操作对象的方法：add、remove、set、get等 使用集合添加、删除新元素的代码更加简洁了    集合的框架体系\nCollection接口实现子类：\nMap接口实现子类：\n  集合主要有两种（单列集合，双列集合）\n  Collection接口有两个重要的子接口List、Set，他们的实现子类都是单列集合\nArrayList arrayList = new ArrayList(); arrayList.add(\u0026#34;jack\u0026#34;); arrayList.add(\u0026#34;tom\u0026#34;);   Map接口的实现子类是双列集合，即以K-V形式存放数据的\nHashMap hashMap = new HashMap(); hashMap.put(\u0026#34;No1\u0026#34;,\u0026#34;jack\u0026#34;); hashMap.put(\u0026#34;No2\u0026#34;,\u0026#34;tom\u0026#34;);     Collection接口和常用方法   Collection接口的特征\n  Collection实现子类可以存放多个元素，每个元素可以是Object\n  有些Collection的实现类，可以存放重复的元素，有些不可以\n  Collection实现类有些是有序的（List），有些不是有序的（Set）\n  Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的\n    Collection接口的常用方法\n add：添加单个元素 remove：删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：增加多个元素 containsAll：查找多个元素是否都存在 removeAll：删除多个元素  以Collection的实现子类演示上述方法\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class Collecyion_ { @SuppressWarnings({\u0026#34;all\u0026#34;}) public static void main(String[] args) { List List = new ArrayList(); //add：添加单个元素  List.add(10); List.add(\u0026#34;java\u0026#34;); List.add(true); System.out.println(\u0026#34;List=\u0026#34;+List); //remove：删除指定元素  List.remove(true); System.out.println(\u0026#34;List=\u0026#34;+List); //contains：查找元素是否存在  System.out.println(List.contains(10)); //size：获取元素个数  System.out.println(List.size()); //isEmpty：判断是否为空  System.out.println(List.isEmpty()); //clear：清空  List.clear(); System.out.println(\u0026#34;List=\u0026#34;+List); //addAll:增加多个元素  List List2 = new ArrayList(); List2.add(\u0026#34;红楼梦\u0026#34;); List2.add(\u0026#34;三国演义\u0026#34;); List2.add(\u0026#34;水浒传\u0026#34;); List.addAll(List2); System.out.println(\u0026#34;List=\u0026#34;+List); //containsAll：查找多个元素是否都存在  System.out.println(List.containsAll(List2)); //removeAll：删除多个元素  List.removeAll(List2); System.out.println(\u0026#34;List=\u0026#34;+List); } }   Collection接口使用Iterator(迭代器)遍历元素\n Iterator对象称为迭代器，主要用于遍历Collection集合中的元素 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器 Iterator仅用于遍历集合，Iterator本身并不存放对象 hasNext()：判断是否还有下一个元素 next()：将下移以后集合位置上的元素返回  代码演示：\nCollection_Book类\npackage com.conllection_; public class Collection_Book { private String name; private String author; private double price; public Collection_Book(String name, String author, double price) { this.name = name; this.author = author; this.price = price; } @Override public String toString() { return \u0026#34;Collection_Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, author=\u0026#39;\u0026#34; + author + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } Collection_Iterator类\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import com.conllection_.Collection_Book; public class Collection_Iterator { public static void main(String[] args) { Collection col =new ArrayList(); col.add(new Collection_Book(\u0026#34;三国演义\u0026#34;,\u0026#34;罗贯中\u0026#34;,10.1)); col.add(new Collection_Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,15.1)); col.add(new Collection_Book(\u0026#34;小李飞刀\u0026#34;,\u0026#34;古龙\u0026#34;,8.1)); //创建col对应的迭代器  Iterator iterator = col.iterator(); //使用while遍历循环  while (iterator.hasNext()){ //因为迭代器取到的数据可以是任意类型的，所以用Object  Object obj= iterator.next(); System.out.println(obj); } } } 运行结果\n hasNext()的返回值为Boolean，\nnext()的返回值可以为任意类型\n 注意：当退出while循环后，这是iterator迭代器指向最后一个元素，此时再使用iterator.next()系统会报错。\n如果要再次遍历，我们需要重置迭代器：\niterator = col.iterator();//重置迭代器   在IDEA中可以使用itit快捷生成\nwhile (iterator.hasNext()){ Object obj= iterator.next(); System.out.println(obj); }   ctrl+j可以看到所有快捷键\n  Collection接口使用增强for循环来遍历元素\n 增强for就是简化版的iterator，本质一样，只能用于遍历集合或素组  基本语法\nfor(Object object : col){ System.out.println(object); } 代码演示\nCollection_For类\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; public class Collection_For { public static void main(String[] args) { Collection col =new ArrayList(); col.add(new Collection_Book(\u0026#34;三国演义\u0026#34;,\u0026#34;罗贯中\u0026#34;,10.1)); col.add(new Collection_Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,15.1)); col.add(new Collection_Book(\u0026#34;小李飞刀\u0026#34;,\u0026#34;古龙\u0026#34;,8.1)); for(Object object : col){ System.out.println(object); } } } 运行结果与使用迭代器的一致。\n我们在**for(Object object : col)**这行代码加一个断点，通过Debug，可以发现增强for会依次调用迭代器的底层方法！\npublic Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } public boolean hasNext() { return cursor != size; } public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 所以，我们可以得知，增强for的底层仍然是迭代器！\n  List接口和常用方法 List接口是Collection接口的子接口\n  List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复\n  List集合中的每个元素都有其对应的顺序索引，即支持索引\n  List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n  List接口常用的实现类有:ArrayList、LinkedList、Vector\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class List_ { public static void main(String[] args) { List list = new ArrayList(); //1. List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复  list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;mary\u0026#34;); list.add(\u0026#34;heng\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;list=\u0026#34;+list); //2. List集合中的每个元素都有其对应的顺序索引，即支持索引  // 索引从0开始  System.out.println(list.get(3)); } }   List接口的常用方法\n  void add(int index,Object ele)：在index位置插入ele元素。\n  bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。\n  Object get(int index)：获取指定index位置的元素。\n  int indexOf(Object obj)：返回obj在集合中首次出现的位置。\n  int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。\n  Object remove(int index)：移除指定index位置的元素，并返回此元素。\n  Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。\n  List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。\n代码演示：\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class ListMethod { public static void main(String[] args) { List list1 = new ArrayList\u0026lt;\u0026gt;(); list1.add(\u0026#34;tom\u0026#34;); list1.add(\u0026#34;cat\u0026#34;); list1.add(\u0026#34;jack\u0026#34;); list1.add(\u0026#34;mary\u0026#34;); list1.add(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 1. void add(int index,Object ele)：在index位置插入ele元素。  list1.add(2,\u0026#34;nancy\u0026#34;); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 2. bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。  List list2 = new ArrayList(); list2.add(\u0026#34;heng\u0026#34;); list2.add(\u0026#34;minster\u0026#34;); System.out.println(\u0026#34;list2 = \u0026#34;+list2); list1.addAll(3,list2); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 3. Object get(int index)：获取指定index位置的元素。  System.out.println(list1.get(3)); // 4. int indexOf(Object obj)：返回obj在集合中首次出现的位置。  System.out.println(list1.indexOf(\u0026#34;tom\u0026#34;)); // 5. int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。  System.out.println(list1.lastIndexOf(\u0026#34;tom\u0026#34;)); // 6. Object remove(int index)：移除指定index位置的元素，并返回此元素。  System.out.println(list1.remove(0)); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 7. Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。  //index必须是存在的下标，越界会报错！  //返回被替换的值  System.out.println(list1.set(3,\u0026#34;rui\u0026#34;)); System.out.println(\u0026#34;list1 = \u0026#34;+ list1); // 8. List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。  //返回的子集合为前闭后开区间！ forIndex \u0026lt;= subList \u0026lt; toIndexE  System.out.println(list1.subList(2,4)); } }     List的三种遍历方式\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ListFor { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;成志恒\u0026#34;); list.add(1); System.out.println(\u0026#34;====迭代器遍历====\u0026#34;); // 1.迭代器遍历  Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(\u0026#34;obj = \u0026#34;+obj); } System.out.println(\u0026#34;====增强for遍历====\u0026#34;); // 2.增强For  for (Object o : list){ System.out.println(\u0026#34;obj = \u0026#34;+o); } System.out.println(\u0026#34;====普通For遍历====\u0026#34;); // 3.普通For  for (int i =0; i\u0026lt; list.size();i++){ System.out.println(\u0026#34;obj = \u0026#34;+list.get(i)); } } } List的其他实现子类（LinkedList、Vector）也可以使用上述三种方式进行遍历\n  练习：Book类：\npackage com.conllection_.lists; public class Book { private String name; private double price; private String author; public Book(String name, String author,double price) { this.name = name; this.author = author; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } @Override public String toString() { return \u0026#34;名称：\u0026#34;+name+\u0026#34;\\t\\t价格：\u0026#34;+price+\u0026#34;\\t\\t作者：\u0026#34;+author; } } ListExercise02类：\npackage com.conllection_.lists; import java.util.*; public class ListExercise02 { public static void main(String[] args) { List list = new Vector(); list.add(new Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,100)); list.add(new Book(\u0026#34;三国\u0026#34;,\u0026#34;罗贯中\u0026#34;,80)); list.add(new Book(\u0026#34;西游记\u0026#34;,\u0026#34;吴承恩\u0026#34;,90)); list.add(new Book(\u0026#34;水浒传\u0026#34;,\u0026#34;施耐庵\u0026#34;,9)); //list.add(new Book(\u0026#34;西游记\u0026#34;,\u0026#34;吴承恩\u0026#34;,90));  for (Object o : list){ System.out.println(o.toString()); } sort(list); System.out.println(\u0026#34;==排序后==\u0026#34;); for (Object o : list){ System.out.println(o.toString()); } } public static void sort(List list){ int listSize = list.size(); for (int i = 0; i \u0026lt;listSize-1 ; i++) { for (int j = 0; j \u0026lt; listSize-1-i; j++) { //取出对象Book  Book book1 = (Book) list.get(j); Book book2 = (Book) list.get(j+1); if(book1.getPrice() \u0026gt; book2.getPrice()){ list.set(j,book2); list.set(j+1,book1); } } } } } 运行结果：\n  ArrayList底层源码及注意事项   注意事项\n  ArrayList可以加入任意元素，包括null（或者是多个null）。\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class ArrayListDetail { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(null); arrayList.add(\u0026#34;jack\u0026#34;); arrayList.add(null); System.out.println(\u0026#34;list = \u0026#34; + arrayList); } }   ArrayList是由数组来实现数据存储的\n  ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList。\nArrayList.add() 源码：\n//ArrayList.add()的源码没有修饰词synchronized public boolean add(E e) { //Increments modCount!!  ensureCapacityInternal(size + 1); elementData[size++] = e; return true; } 由于该集合的方法没有用synchronized修饰，我们可以知道ArrayList是线程不安全的！下面可以跟Vector的源码进行比较\nVector.add() 源码：\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; }     ArrayList的底层源码分析（先说结论，再分析源码）\n  ArrayList中维护了一个Object类型的数组elementData。\n//transient 表示瞬间，短暂的，表示该属性不会被序列化 transient Object[] elementData;   当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍（即初始化数组elementData的大小为0，初次添加数据时扩容成10，等到添加的数据达到容量极限时，继续扩容为elementData的1.5倍）。\n  如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容则直接扩容elementData为1.5倍\n    扩容机制源码分析\n  创建ArrayListSource类。\npackage com.conllection_.lists; import java.util.ArrayList; public class ArrayListSource { public static void main(String[] args) { //利用无参构造创建了ArrayList  ArrayList arrayList = new ArrayList(); //利用有参构造创建了ArrayList  //ArrayList list = new ArrayList(8);  for (int i = 0; i \u0026lt; 10; i++) { arrayList.add(i); } for (int i = 11; i \u0026lt; 15 ; i++) { arrayList.add(i); } arrayList.add(100); arrayList.add(200); arrayList.add(null); } }   在ArrayList arrayList = new ArrayList();出添加断点，debug。\npublic ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组，其定义：\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 可以知道此时创建了一个空的elementData数组={}！\n  下一步 执行arrayList.add()。add源码如下\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; }   先确定是否需要扩容（ensureCapacityInternal） 然后再执行，赋值     进入ensureCapacityInternal方法。\nprivate void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity( calculateCapacity(elementData, minCapacity)); } 该方法调用了ensureExplicitCapacity与calculateCapacity方法。\ncalculateCapacity方法源码：\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { //DEFAULT_CAPACITY为常量，定义为10  //minCapacity为集合所需的最小容量  return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } ensureExplicitCapacity方法源码：\nprivate void ensureExplicitCapacity(int minCapacity) { // modCount为当前集合被修改的次数  //用来防止多个线程操作产生的异常。  modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } ensureCapacityInternal方法在这一步中首先调用了calculateCapacity方法来确定minCapacity(最小容量)然后把最小容量返回到ensureExplicitCapacity方法中，判断elementData的大小是够足够，如果不够会使用grow()方法去扩容。\n  然后通过调用grow方法 完成扩容。grow源码：\nprivate void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; //按原来大小的1.5倍扩容  int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //初始值扩容  if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; //判断容量是否超过数组最大容量  if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  // Arrays.copyOf可以把原先数组copy到新的elementData！  elementData = Arrays.copyOf(elementData, newCapacity); } 在这一步完成了：\n 实现扩容 使用扩容机制来确定要扩容到多大 第一次newCapacity = 10 第二次及其以后，按照1.5倍扩容 扩容使用的是Arrays.copyOf()实现，可以把原来elementData的数据copy到扩容后的elementData中 完成后把扩容后的数组逐层返回到add方法里面  扩容后的elementData：\n    当使用有参构造器创建与使用ArrayList时，扩容机制与上述基本一致。\npublic ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } this.elementData = new Object[initialCapacity]创建了指定大小的elementData数组。\ninitialCapacity为构造器传入的初始参数，即为elementData数组的初始大小。\n需要注意的是，有参构造器扩容时第一次扩容为elementData的1.5倍，并不是初始为10！\n 因为calculateCapacity方法中只有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时才会把常量DEFAULT_CAPACITY的值返回到ensureExplicitCapacity。而DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组。由于有参构造创建的elementData必不为空，所以初次扩容时的newCapaCity为elementData大小的1.5倍。\n if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } 扩容后的elementData：\n剩下的扩容步骤与无参的一样！\n    Vector底层结构和源码解析   Vector的定义：\npublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable   ector底层也是一个数组，protected Object[] elementData；\n  Vector是线程同步的，即线程安全，Vector类的操作方法都带有synchronize\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; }   Vector与ArrayList比较\n  Vector扩容的底层源码\n创建Vector_类，使用无参构造器来创建Vector。\npackage com.conllection_.lists; import java.util.Vector; public class Vector_ { public static void main(String[] args) { Vector vector = new Vector(); for (int i = 0; i \u0026lt; 10; i++) { vector.add(i); } vector.add(100); } } Vecto的无参创建初始化elementData大小为10\npublic Vector() { this(10); } 进入到add方法，通过ensureCapacityHelper判断是否需要扩容。\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } ensureCapacityHelper方法：\nprivate void ensureCapacityHelper(int minCapacity) { // overflow-conscious code  //如果最小容量大于数组的实际长度，则扩容  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } 如果minCapacity - elementData.length \u0026gt; 0满足，则通过grow方法扩容\nprivate void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 又因为capacityIncrement=0，所以newCapacity=oldCapacity+oldCapacity，即为原来的两倍！\n扩容后的Vector：\n  ​\nLinkedList底层结构和源码解析  LinkedList底层实现了双向链表和双端队列特点 可以添加任意元素（元素可以重复），包括null LinkedList也是线程不安全的，没有实现同步    LinkedList的底层操作机制\n  LinkedList底层维护了一个双向链表。\n  LinkedList中维护了两个属性first和last分别指向首节点和尾结点。\n  每个节点（Node对象），里面又包含prev、next、item三个属性，其中通过prev指向前一个节点，通过next指向后一个节点。最终实现双向链表。\n  所以LinkedList的元素添加和删除，不是通过数组完成的，相对来说效率较高。\n  LinkedList链表示意图：\n    双向链表的创建使用演示\n创建Note类\npackage com.conllection_.lists; //定义一个Note类，Note对象表示双向链表的一个节点。 public class Note { public Object item;//存放数据  public Note pre;//指向上一个节点  public Note next;//指向下一个节点  public Note(Object name){ this.item=name; } @Override public String toString() { return \u0026#34;Note{\u0026#34; + \u0026#34;name=\u0026#34; + item + \u0026#39;}\u0026#39;; } } 在LinkedList类中模拟建立一个双向链表\npackage com.conllection_.lists; public class LinkedList01 { public static void main(String[] args) { //模拟一个简单的双向链表  //首先创建三个结点 jack、mary、tom  Note jack = new Note(\u0026#34;jack\u0026#34;); Note mary = new Note(\u0026#34;mary\u0026#34;); Note tom = new Note(\u0026#34;tom\u0026#34;); //连接三个结点形成双向链表  //jack-\u0026gt;mary-\u0026gt;tom  jack.next = mary; mary.next = tom; //tom-\u0026gt;mary-\u0026gt;jack  tom.pre = mary; mary.pre = jack; //创建头结点与尾结点  //让first引用指向jack，就是双向链表的头结点  Note first = jack; //让last引用指向tom，就是双向链表的尾结点  Note last = tom; } } 利用头结点遍历，遍历链表\n//头结点遍历 System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 利用尾结点遍历，遍历链表\nSystem.out.println(\u0026#34;==尾结点遍历==\u0026#34;); while(true){ if(last == null){ break; } System.out.println(last); last = last.pre; } 在mary结点与tom结点之间增加一个smith结点\n//在mary与tom之间增加一个smith结点  Note smith = new Note(\u0026#34;smith\u0026#34;); smith.pre = mary; smith.next = tom; mary.next = smith; tom.pre = smith; first = jack; //头结点遍历  System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 删除smith结点\n//删除smith结点  System.out.println(); System.out.println(\u0026#34;删除smith结点\u0026#34;); mary.next = tom; tom.pre = mary; first = jack; //头结点遍历  System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 运行结果：\n  利用LinkedList的CRUD来查看其底层源码\nLinkedListCRUD.java\npackage com.conllection_.lists; import java.util.LinkedList; public class LinkedListCRUD { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); linkedList.add(100); linkedList.add(200); } } 在LinkedList linkedList = new LinkedList();处添加断点，debug。\n可以知道此时LinkedList只初始化了一个空的linkedList\npublic LinkedList() {} 此时linkedList的属性 first = null，last = null\n然后查看add方法的源码，我们可以发现add方法调用了方法linkLast\npublic boolean add(E e) { linkLast(e); return true; } 查看linkLast方法的源码，我们可以发现此时创建了一个newNode结点，并将其加入到双向链表的最后。\nvoid linkLast(E e) { //初始last为null，所以l=null  final Node\u0026lt;E\u0026gt; l = last; final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } 因为是第一个结点，所以newNode的next与last均为空。此时LinkedList的first与last均指向了newNode。此时链表的状态为：\n当我们再次往LinkedList集合中添加元素时，会再次进入到底层的linkLast方法。\nvoid linkLast(E e) { //l = last 即指向了第一个newNode  final Node\u0026lt;E\u0026gt; l = last; //此时新的newNode有prev = l 即新的newNode指向了第一个结点！  final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; //因为l = last 所以l不为null  if (l == null) first = newNode; else l.next = newNode; size++; //modCount记录集合修改的次数  modCount++; } 因为此时的last不再为空，所以结点l指向了last结点，即第一个newNode。此时链表的状态为：\n  上述代码为LinkedList集合添加元素时的源码展示，下面我们看一下LinkedList集合删除指定索引的元素时的源码：\nLinkedListCURD类\npackage com.conllection_.lists; import java.util.LinkedList; public class LinkedListCRUD { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); linkedList.add(100); linkedList.add(200); linkedList.add(300); System.out.println(\u0026#34;linkedList = \u0026#34; + linkedList); linkedList.remove(1); System.out.println(\u0026#34;linkedList = \u0026#34; + linkedList); } } 查看linkedList.remove(int index)方法。\npublic E remove(int index) { checkElementIndex(index); return unlink(node(index)); } 我们可以知道该方法首先通过checkElementIndex(index);检查索引是否合法，不合法会抛出异常。\ncheckElementIndex(index);方法源码：\nprivate void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 上述isElementIndex方法的作用用来判断元素的索引范围\nprivate boolean isElementIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; } 当索引在元素的合法范围时，进入到了node(int index)方法。该方法可以返回指定元素索引处的（非空）结点。\nNode\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); \t//如果index小于size的一半，从头到尾遍历  if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { //如果index大于size的一半，从尾到头遍历  Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } 然后再通过unlink(Node x)方法删除指定索引集合元素。\nE unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null;  //把要删除的元素数据赋值给element，以便删除后返回  final E element = x.item; //新建一个结点next指向x.next  final Node\u0026lt;E\u0026gt; next = x.next; //新建一个结点prev指向x.prev  final Node\u0026lt;E\u0026gt; prev = x.prev; //如果prev == null 说明x结点为头结点。  //此时把first指向next，即说明x的下一个结点为新的头结点  if (prev == null) { first = next; } else {//否则x的上一个节点的next值指向x的下一个结点  prev.next = next; //因为x已经删除，所以把prev置为null  x.prev = null; } //如果next == null 说明该节点为尾结点  //此时吧last指向prev，即说明x的上一个结点为新的尾结点  if (next == null) { last = prev; } else {//否则把x的下一个结点的prev指向x的上一个结点  next.prev = prev; //因为x已经删除，next  x.next = null; } x.item = null; //集合的大小减一  size--; //修改次数+1次  modCount++; //最后返回被删除的元素  return element; } 下面为删除two结点的图解\n删除后的链表状态为\n  ArrayList和LinkedList比较\n  如何选择ArrayList和LinkedList\n 如果我们改查的操作多，就选ArrayList 如果我们增删操作多，就选择LinkedList 一般来说，在程序中，80%—90%都是查询，因此大部分情况下会选择ArrayList 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另一个模块使用的是LinkedList    ","date":"2021-04-05T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/","title":"Java集合类（一）"},{"content":"多线程详解   进程与线程简介 创建线程 线程状态 线程同步 线程协作 线程池   进程与线程简介   进程（Process）：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——系统资源分配的最小单位。\n  线程（Thread）：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。\n  两者之间的区别见下图\n可以发现，进程是由（线程+内存+文件/网络句柄）等元素构成的\n  注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。\n  普通方法调用和多线程\n  核心概念\n 线程就是独立的执行路径 在程序执行时，即使没有自己创建1线程，后台也会有多个线程，如主线程，gc线程(垃圾回收线程)。 main()称之为主线程，为系统的入口，用于执行整个程序 在一个程序中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。 线程会带来额外的开销，如CPU调度时间；并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。    创建线程 三种创建方式\n  继承Thread创建线程\n 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程  创建TestThread01类，实现继承Thread类创建线程\npackage com.thread_; //创建线程类方式一：继承Thread类，重写run方法，在主线程调用start开启线程。 public class TestThread01 extends Thread{ //run方法线程体  @Override public void run() { for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;我在看代码！\u0026#34;+i); } } //主方法，main线程  public static void main(String[] args) { //创建一个线程对象  TestThread01 testThread01 = new TestThread01(); //调用start开启线程  testThread01.start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;我在学习线程\u0026#34;+i); } } } 运行结果：\n需要注意的是，线程开启不一定立即执行，由CPU的调度执行\n  实现多线程进行网络图片下载\n首先我们需要引入commons-io包，并且把它导入到项目下的lib包中\n再创建下载器WebDownLoader类用于下载网络图片\nclass WebDownLoader{ //下载方法  public void downLoader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\u0026#34;DownLoader方法出现异常\u0026#34;); } } } 创建线程类TestThread02\npackage com.thread_; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; public class TestThread02 extends Thread{ //创建属性url与name，用于接收网络图片地址和保存文件名  private String url; private String name; //创建TestThread02的构造器  public TestThread02(String url,String name){ this.url = url; this.name = name; } //重写run方法，下载图片的线程执行体  @Override public void run() { WebDownLoader webDownLoader = new WebDownLoader(); webDownLoader.downLoader(url,name); System.out.println(\u0026#34;DownLoader Image \u0026#34; + name); } public static void main(String[] args) { TestThread02 t1 = new TestThread02(\u0026#34;https://github.com/minster77/minster77.github.io/blob/master/JavaBase.jpg\u0026#34;,\u0026#34;1.jpg\u0026#34;); TestThread02 t2 = new TestThread02(\u0026#34;https://github.com/minster77/minster77.github.io/blob/master/JavaCollection.jpg\u0026#34;,\u0026#34;2.jpg\u0026#34;); TestThread02 t3 = new TestThread02(\u0026#34;https://github.com/minster77/minster77.github.io/blob/master/JavaThink.jpg\u0026#34;,\u0026#34;3.jpg\u0026#34;); t1.start(); t2.start(); t3.start(); } } 主目录下我们可以发现图片以及下载完成\n而控制台也输出了以下结果\n我们可以发现，三个图片并没有按照我们调用start方法的顺序下载完成。这就是我们所说的多线程执行了。\n  实现Runnable接口创建线程\n 定义一个实现类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程  package com.thread_; public class TestThread03 implements Runnable{ //run方法线程体  @Override public void run() { for (int i = 0; i \u0026lt; 50; i++) { System.out.println(\u0026#34;我在看代码！\u0026#34;+i); } } //主方法，main线程  public static void main(String[] args) { TestThread03 testThread03 = new TestThread03(); //下面两句等价于 new Thread(testThread03).start();  Thread thread = new Thread(testThread03); thread.start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;我在学习线程\u0026#34;+i); } } }  其实实现Runnable接口创建线程与继承Thread类创建线程的方法步骤是一样的，但是由于继承Thread类创建是单继承，具有局限性。所以开始时推荐选择实现Runnable接口创建多线程\n   小结\n继承Thread类\n 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用继承Thread类创建线程，因为面向对象单继承具有局限性  实现Runnable接口\n 实现Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用Runnable接口创建线程，因为可以避免单继承局限性，灵活方便，方便同时一个对象被多个线程使用。    实现Callable接口创建线程\n 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行：Futureresult1 = ser.submit(t1)； 获取结果：boolean r1 = result.get() 关闭服务：ser.shutdownNow()；    Callable的好处\n 可以定义返回值 可以返回异常    线程状态   线程具有五个状态，分别是创建状态、就绪状态、阻塞状态、运行状态、死亡状态。\n关系图如下\n线程状态转换细节\n线程方法\n setPriority(int newPriority)：更改线程的优先级 static void sleep(long millis)：在指定的毫秒数内让当前正在执行的线程体休眠 void join()：等待该线程终止 static void yield()：暂停当前正在执行的线程对象，并执行其他线程 void interrupt()：中断线程。不建议使用！ boolean isAlive()：测试线程是否处于活动状态   不建议使用JDK提供的stop()、destory()方法[已废弃！]。\n推荐让线程自己停下来。\n或者使用一个标志位进行终止变量，当flag=false时，则终止线程运行。\n 设置标志位让线程停止的代码演示：\npackage com.lambda; public class TestStop implements Runnable{ //1.设置一个标志位  private boolean flag = true; @Override public void run() { int i = 0; while (flag){ System.out.println(\u0026#34;run Thread...\u0026#34;+i++); } } //2.设置一个对外提供的方法停止线程，转换标志位  private void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;main = \u0026#34;+i); if (i==900){ //调用stop方法切换标志位，让线程停止；  testStop.stop(); System.out.println(\u0026#34;线程停止了！\u0026#34;); } } } }   线程休眠\n sleep(time)指定当前线程阻塞的毫秒数； sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等。 每一个对象都有一个锁，sleep不会释放锁   模拟网络延时：可以放大问题的发生性。\n 模拟倒计时\npackage com.lambda; import java.text.SimpleDateFormat; import java.util.Date; public class TestSleep { public static void main(String[] args) throws InterruptedException { timeDown(); } public static void timeDown() { int n = 10; while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(n--); if (n\u0026lt;=0){ break; } } } } 打印出当前系统时间\npackage com.lambda; import java.text.SimpleDateFormat; import java.util.Date; public class TestSleep { public static void main(String[] args) throws InterruptedException { //获取系统当前时间  Date startDate = new Date(System.currentTimeMillis()); while (true){ Thread.sleep(1000); System.out.println(new SimpleDateFormat(\u0026#34;HH:mm:ss\u0026#34;).format(startDate)); startDate = new Date(System.currentTimeMillis()); } } }   线程礼让\n 线程礼让，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态，让CPU重新调度，礼让不一定成功！看CPU心情  创建测试类TestYield\npackage com.lambda; public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\u0026#34;a\u0026#34;).start(); new Thread(myYield,\u0026#34;b\u0026#34;).start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\u0026#34;线程开始了\u0026#34;); Thread.yield(); System.out.println(Thread.currentThread().getName()+\u0026#34;线程停止了\u0026#34;); } } 礼让成功：\n礼让失败：\n  Join方法：Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞。（就是强制插队，不建议使用！）\npackage com.lambda; public class TestJoin implements Runnable{ public static void main(String[] args) throws InterruptedException { TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); for (int i = 0; i \u0026lt; 1000; i++) { if(i == 200){ thread.join(); } System.out.println(\u0026#34;main = \u0026#34; + i); } } @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;我来插队了！\u0026#34;); } } }   观察测试线程的状态\npackage com.lambda; public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 5; i++) { try { //调用sleep方法，进入阻塞状态  Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;///////\u0026#34;); }); //调用getState方法，观察线程状态  Thread.State state = thread.getState(); System.out.println(state);//NEW  thread.start(); state = thread.getState(); System.out.println(state);//RUNNABLE  //只要线程不终止，就一直输出  while (state != Thread.State.TERMINATED){ Thread.sleep(100); state = thread.getState();//更新线程状态  System.out.println(state); } } } 运行结果：\n  线程优先级   Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。\n  线程的优先级用数字表示，范围从1~10\n Thread.MIN_PRIORITY = 1; Thread.MAX_PRIORITY = 10; Thread.NORM_PRIORITY = 5;    使用以下方式可以改变或获取优先级\n getPriority()，setPriority(int xxx);  代码演示\npackage com.thread_; public class TestPriority { public static void main(String[] args) { //main线程的默认优先级为5  System.out.println(Thread.currentThread().getName() + \u0026#34;--\u0026gt;\u0026#34; + Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); //优先级设定在start()调度前  //默认是5  t1.start(); t2.setPriority(3); t2.start(); t3.setPriority(6); t3.start(); t4.setPriority(Thread.MAX_PRIORITY);//MAX_PRIORITY = 10;  t4.start(); t5.setPriority(Thread.NORM_PRIORITY); t5.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + \u0026#34;--\u0026gt;\u0026#34; + Thread.currentThread().getPriority()); } } 运行结果：\n可以发现，优先级高的线程不一定先执行。\n   优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了；这都是看CPU的调度的。（性能倒置）\n 守护线程   线程分为用户线程和守护线程\n  虚拟机必须确保用户线程执行完毕\n  虚拟机不用等待守护线程执行完毕\n  常见的守护现场有：后台记录操作日志，监控内存，垃圾回收等等\u0026hellip;\n  测试守护线程\npackage com.thread_; public class TestDaemon { public static void main(String[] args) { God god = new God(); People people = new People(); Thread thread = new Thread(god); //默认false表示是用户线程，正常线程都是用户线程  //设置为true表示该线程为守护线程  thread.setDaemon(true); //启动守护线程  thread.start(); new Thread(people).start(); } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(\u0026#34;上帝守护着你！\u0026#34;); } } } class People implements Runnable{ @Override public void run() { for (int i = 0; i \u0026lt; 36500; i++) { System.out.println(\u0026#34;你开心的活着\u0026#34;); } System.out.println(\u0026#34;GoodBye world\u0026#34;); } }   线程同步 并发问题的引出\n  并发：同一个对象被多个线程同时操作\n  当我们使用多线程操作一个对象时，容易发生并发问题，下面我们举一个买火车票的例子来引出并发问题\npackage com.thread_.syn; public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,\u0026#34;jack\u0026#34;).start(); new Thread(buyTicket,\u0026#34;tom\u0026#34;).start(); new Thread(buyTicket,\u0026#34;mary\u0026#34;).start(); } } class BuyTicket implements Runnable{ private int ticketNum = 10; private boolean flag =true; @Override public void run() { while (flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } public void buy() throws InterruptedException { if(ticketNum\u0026lt;=0){ flag = false; return; } Thread.sleep(100); System.out.println(Thread.currentThread().getName() + \u0026#34;抢到了第\u0026#34; + ticketNum-- + \u0026#34;票\u0026#34;); } } 运行结果：\n我们可以发现，有一些票被重复拿了！多个线程操作一个资源的情况下，线程不安全，数据紊乱。这就是我们所说的线程并发问题。\n利用线程的同步可以解决上述的问题！\n  线程同步介绍\n ​\t由于统一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制-synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待；使用后释放锁即可。\n 使用锁会存在以下问题\n 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。（性能倒置问题）    同步方法\n  由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制1就是synchronized关键字。它包括两种用法：synchronized方法和synchronized块\n//同步方法 public synchronized void method(int args){ }   synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行\n 缺陷：若将一个大的方法申明为synchronized将会影响效率\n   方法里需要修改的内容才需要锁，锁太多了会浪费资源。\n  所以在上面买火车票的案例中，我们只需要对buy方法加上修饰符synchronized即可以解决并发问题！\npublic synchronized void buy() throws InterruptedException { if(ticketNum\u0026lt;=0){ flag = false; return; } Thread.sleep(100); System.out.println(Thread.currentThread().getName() + \u0026#34;买到了第\u0026#34; + ticketNum-- + \u0026#34;票\u0026#34;); } 运行结果：\n  同步块\nsynchronized(Obj){ } Obj称之为同步监视器\n Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身。或者是class[反射中讲解]  同步监视器的执行过程\n 第一个线程访问，锁定同步监视器，执行其中代码。（第一个人上厕所，把厕所门关上） 第二个线程访问，发现同步监视器被锁定，无法访问。（第二个人去上厕所，发现有人在厕所里面，进不去，就走了） 第一个线程访问完毕，解锁同步监视器。（第一个人上完厕所，打开门） 第二个线程访问，发现同步监视器没有锁，然后锁定并访问。（第二个人又来上厕所，发现没人，便进去了且关上厕所门）     注意：synchronized方法默认锁的是当前对象（加了修饰符的类 即this），而synchronized(Obj){}同步块是可以指定对象锁定的（锁的对象便是变化的量，需要增删改的对象）\n   完成银行取款案例，利用同步块确保线程安全性\npackage com.thread_.syn; public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100, \u0026#34;银行卡\u0026#34;); Drawing drawing1 = new Drawing(account,50,\u0026#34;jack\u0026#34;); Drawing drawing2 = new Drawing(account,100,\u0026#34;mary\u0026#34;); drawing1.start(); drawing2.start(); } } class Account{ int money; String name; public Account(int money, String name) { this.money = money; this.name = name; } } class Drawing extends Thread{ Account account; int drawingMoney; int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱  @Override public void run() { synchronized (account){ if(account.money-drawingMoney\u0026lt;0){ System.out.println(Thread.currentThread().getName()+\u0026#34;取钱，余额不足\u0026#34;); return; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额  account.money = account.money - drawingMoney; nowMoney = nowMoney + drawingMoney; System.out.println(account.name + \u0026#34;余额为：\u0026#34;+ account.money); System.out.println(this.getName() + \u0026#34;手里的余额为\u0026#34; + nowMoney); } } }   死锁\n​\t多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一同步块同时拥有“两个以上对象的锁时”，就可能会发生死锁的问题\n 死锁：多个线程互相抱着对方需要的资源，然后形成僵持\n   产生死锁的四个必要条件：\n 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系   上面列出了死锁的四个必要条件，我们只需要破坏其中的任意一个或多个条件即可避免死锁发生。例如：银行家算法避免死锁\n   Lock(锁)\n 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁  利用ReentrantLock解决买票的并发问题\npackage com.thread_.lock; import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNum = 10; //定义Lock锁  ReentrantLock lock = new ReentrantLock(); @Override public void run() { try { //加锁  lock.lock(); while (true){ if (ticketNum \u0026gt; 0 ){ System.out.println(ticketNum--); }else { break; } } }finally { //解锁  lock.unlock(); } } }   synchronized与Lock的对比\n Lock是显式锁（手动开启和关闭锁，一定要关闭锁！）；synchronized是隐式锁，出了作用域便会自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（Lock锁提供更多的子类） 优先使用顺序  Lock\u0026gt;同步代码块\u0026gt;同步方法      线程协作   生产者和消费者模式（问题）\n  分析\n这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。 在生产者消费者问题中，仅有synchronized是不够的！  synchronized可阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（线程通信）    Java提供了几个方法来解决线程之间的通信问题\n wait()：表示线程会一直等待，直到其他线程通知，与sleep不同，该方法会释放锁 wait(long timeout)：指定等待的毫秒数 notify()：唤醒一个处于等待状态的线程 notifyAll()：唤醒同一个对象上所以调度wait()方法的线程，优先级别高的线程优先调度   注意！上述方法均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常\n   利用管程法解决生产者消费者问题\n  生产者：负责生产数据的模块（可能是方法，对象，线程，进程）；\n  消费者：负责处理数据的模块（可能是方法，对象，线程，进程）；\n  缓冲区：消费者不能直接使用生产者的数据，他们之间有一个缓冲区；生产者将生产好的数据放入缓冲区，消费者从缓冲区中拿出数据\n  package com.thread_.lock; //管程法解决生产者消费者问题 //需要的对象：生产者，消费者，缓冲区，产品 public class TestPC { public static void main(String[] args) { SynContainer synContainer = new SynContainer(); Producer producer = new Producer(synContainer); Customer customer = new Customer(synContainer); new Thread(producer).start(); new Thread(customer).start(); } } //产品 class Chicken { int id; public Chicken(int id) { this.id = id; } } //生产者 class Producer extends Thread{ SynContainer synContainer; public Producer(SynContainer synContainer){ this.synContainer = synContainer; } @Override public void run() { for (int i = 1; i \u0026lt; 50; i++) { try { synContainer.push(new Chicken(i)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产了第\u0026#34;+i+\u0026#34;只鸡\u0026#34;); } } } //消费者 class Customer extends Thread{ SynContainer synContainer; public Customer(SynContainer synContainer){ this.synContainer = synContainer; } @Override public void run() { for (int i = 1; i \u0026lt; 50; i++) { try { System.out.println(\u0026#34;消费了第\u0026#34; + synContainer.pop().id+\u0026#34;只鸡\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } } } } //缓冲区 class SynContainer{ //规定容器的容量  Chicken[] chickens = new Chicken[10]; private int count; //生产者把产品放入到缓冲区  public synchronized void push(Chicken chicken) throws InterruptedException { //如果容器满了，等待消费者消费，停止生产  if (count == chickens.length){ //线程阻塞，等待消费者通知  this.wait(); System.out.println(\u0026#34;缓冲区满了，消费者消费\u0026#34;); } //如果没有满，就需要丢入产品  chickens[count] = chicken; count++; //有产品了，通知消费者消费  this.notify(); } //消费者消费产品  public synchronized Chicken pop() throws InterruptedException { //判断能否消费  if (count == 0){ //没产品了，等待生产者生产  this.wait(); } //如果可以消费  count--; Chicken chicken = chickens[count]; //通知生产者拿走了鸡  this.notify(); return chicken; } }   利用信号灯法解决生产者消费者问题\npackage com.thread_.lock; import javafx.stage.Stage; //信号灯法：利用标志位解决 public class TestPC2 { public static void main(String[] args) { StageShow stageShow = new StageShow(); Player player = new Player(stageShow); Watcher watcher = new Watcher(stageShow); new Thread(player).start(); new Thread(watcher).start(); } } //生产者 -\u0026gt;演员 class Player extends Thread { StageShow stage; public Player(StageShow stage) { this.stage = stage; } @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { if(i%2 ==0){ try { this.stage.Play(\u0026#34;海贼王\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } }else { try { this.stage.Play(\u0026#34;火影忍者\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } } } } } //消费者 -\u0026gt;观众 class Watcher extends Thread { StageShow stage; public Watcher(StageShow stage) { this.stage = stage; } @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { stage.Watch(); } } } //缓冲区 -\u0026gt;舞台 class StageShow { String voice; boolean flag = true; //演员表演，观众等待  public synchronized void Play(String voice) throws InterruptedException { if (flag != true) { this.wait(); } System.out.println(\u0026#34;演员表演了：\u0026#34; + voice); this.voice = voice; this.flag = !this.flag; //表演完成，唤醒观众  this.notifyAll(); } public synchronized void Watch() { if (flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;观众观看了：\u0026#34; + voice); this.flag = !this.flag; //观看完成，唤醒演员  this.notifyAll(); } }   线程池 ​\t如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。\n  思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完毕后放回池中，可以避免频繁的创建销毁、实现重复利用。类似于生活中的交通工具\n  好处：\n 提高了响应速度（减少创建新线程的时间） 降低资源的消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理  corePoolSize：管理核心池（线程池）的大小 maximumPoolSize：管理最大线程数 keepAliveTime：管理线程没有任务时最多保持多少时间后悔终止      JDK5.0起提供了线程池相关API：ExecutorService和Executors\n  ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor\n void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable Future submit (Callabletask)：执行任务/命令，有返回值，一般用来执行Callable void shundown()：关闭连接池    Executors：工具类、线程池工厂类，用于创建并返回不同类型的线程池\n  线程池创建的演示\npackage com.thread_.lock; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; public class TestPool { public static void main(String[] args) { //1.创建服务，创建指定大小的线程池  ExecutorService service = Executors.newFixedThreadPool(10); //2.执行  service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //3.关闭线程池  service.shutdownNow(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } }    总结：ExecutorService通过Executors方法创建线程池，然后执行execute方法或submit 方法来执行服务。\n ","date":"2020-09-02T16:22:25+08:00","permalink":"https://minster77.github.io/p/javathread/","title":"JavaThread"},{"content":"List list = new ArrayList();与ArrayList list = new ArrayList()\n​\tList是一个接口，而ArrayList是一个类ArrayList继承并实现了List。\n​\tList list = new ArrayList();这句话创建了一个ArrayList的对象后上溯到了List。此时它是一个List对象了，有一些ArrayList有但是List没有的属性和方法，它就不能再用了。而ArrayList alist = new ArrayList();创建了一对象则保留了ArrayList的所有属性。\n为什么一般都使用List list= new ArrayList()，而不是后者呢\n​\t问题在于List有多个实现类，如常用的LinkedList或者Vector等等，现在你用的是ArrayList，也许哪一天你需要换成其他的实现类的时候，你只需要改变：List list = new ArrayList()；这一行就可以了，其他使用了List接口的代码根本不需要改动。\n​\t假如你开始使用了ArrayList alist = new ArrayList()；你要换成其他实现类的时候，你需要把全部实现了ArrayList的代码模块都进行修改，尤其是使用了ArrayList特有的方法和属性时！\n​\t所以如果没有特别需求的话，最好使用List list = newArrayList()；这样可以便于程序代码的重构，这就是面向接口编程的好处。\n","date":"2020-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%B8%80/","title":"Java编程思想集合篇（一）"},{"content":"Java基础语法   注释、标识符、关键字 数据类型 类型转换 变量常量 运算符 包机制、JavaDoc   注释、标识符、关键字 1.注释（注释不会被执行）\n 单行注释：用\u0026quot;//\u0026ldquo;表示 多行注释：”/* */“表示 JavaDoc文档注释：用/** */表示  2.标识符\n 标识符以字母、美元符($)、下划线(_)开头 首字符之后可以是字母、美元符($)、下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或方法名 标识符是大小写敏感的 String不是关键字，是一个类  Java数据类型   整数类型\n Byte占1个字节范围-128-127 short占2个字节范围 int占四个字节范围 long占8个字节范围（Long类型要在数字后面加个L）    浮点类型\n float占4个字节范围（float类型要在数字后面加个F） double占8个字节    字符类型：char占2个字节\n  Boolean类型：占一位 其真值只有true和Flase两个\n  浮点数拓展\nfloat a1 = 0.1f;//0.1  double a2 = 1.0/10;//0.1  System.out.println(a1==a2);//此处输出为false  System.out.println(a1); System.out.println(a2); float a3 = 2121213121212f; float a4 = a3+1; System.out.println(a3==a4);//此处输出为true 因为float的有限性、离散性、舍入误差，所以以上代码比较结果如下\n    避免使用浮点数进行比较\n  字符拓展\n//字符拓展  char a1 = \u0026#39;a\u0026#39;; char a2 = \u0026#39;中\u0026#39;; System.out.println(a1); System.out.println((int)a1);//强制转换  System.out.println(a2); System.out.println((int)a2);//强制转换   输出结果为\n  所有字符的本质都是数字，所有所有字符都有对应的Unicode编码\n  Unicode的编码方式：\nchar a3 = \u0026#39;\\u0061\u0026#39;; System.out.println(a3);   类型转换   Java是强类型转换语言，所以在进行运算时，需要把不同类型的数据转换成同一类型再进行运算\n  类型优先级\n  int i = 128; double d = i;//自动转换  byte b = (byte)i;//强制转换，注意数据溢出  System.out.println(i); System.out.println(d); System.out.println(b); /** * 注意点： * 不能对布尔型进行转换 * 不能把对象类型转换为不相干的类型 * 在把高容量转换成低容量的时候，强制转换 * 转换的时候可能存在内存1溢出，或者是精度问题*/ 输出结果：\n! 因为Byte类型取值范围为-128-127所以数据溢出了。 \u0026ldquo;强制转换\u0026quot;时需要注意数据溢出； 转换方式: (类型)变量名 优先级高\u0026ndash;低时使用 自动转换：优先级低\u0026ndash;高时自动使用  数据溢出问题：\n//操作比较大的数据时 注意溢出问题  //JDK7新特性 数字之间可以用下划线_分割  int money = 10_0000_0000;//新特性  int years = 20; int total1 = money*years;//-1474836480,计算的时候已经溢出  System.out.println(money); System.out.println(years); System.out.println(total1); long total2 = money*years;//先计算再赋值，所以数据转换前已经溢出了  System.out.println(total2); long total3 = money*((long)years);//先把一个数转换成long 计算后的结果的类型即为long类型  System.out.println(total3); 输出结果：\n变量、常量、作用域   类变量\n  静态代码块（static）\n 静态代码块只会被执行一次 静态类可以被局部对象调用 静态变量可以被执行多次  public class demo5 { static int i=1; static { System.out.println(\u0026#34;a\u0026#34;); i++; } public demo5(){ System.out.println(\u0026#34;b\u0026#34;); i++; } //在此之前i已被调用两次，i的值为2  public static void main(String[] args) { demo5 d1 = new demo5();//i在次被调用，i+1，此时i=3  System.out.println(d1.i); demo5 d2 = new demo5();//i在次被调用，i+1，此时i=4  System.out.println(d2.i); } } 输出结果：\n  实例变量：从属于对象，如果不自动化初始化，这个类型的默认值为0/0.0\n  布尔值：默认是false\n  除了基本类型，其余的默认值都是null；\n    常量\n 常量定义通过final实现 一般使用大写字母表示 修饰符不存在先后顺序    变量命名规则\n  基本运算符  Java语言支持如下运算符    当java进行除法运算时，需要进行类型强转换\npackage JavaSEbase; public class demo6 { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b);//结果为0.5  System.out.println(a/(double)b); } } 显然加了强转double的表达式输出了正确的结果\n  在整数的运算过程中，有long类型则结果为long类型，其余都为int类型\npackage JavaSEbase; public class demo7 { public static void main(String[] args) { long a = 123132132132132L; int b = 123; short c = 10; byte d =8; System.out.println(a+b+c+d);//long  System.out.println(b+c+d);//int  System.out.println(c+d);//int  } }   一元运算符：自增与自减\npackage JavaSEbase; public class demo8 { public static void main(String[] args) { int a = 3; int b = a++;//先把a赋值给b再自增  //a=a+1  System.out.println(a);//此时a=4  //a=a+1  int c = ++a;//先自增再把a赋值给c  System.out.println(a);//此时a=5  System.out.println(b); System.out.println(c); } }   逻辑运算符\n  逻辑与\u0026amp;\u0026amp;：有假就假，全真才真\n  逻辑或||：有真就真，全假才假\n  逻辑与的短路运算\npackage JavaSEbase; public class demo9 { public static void main(String[] args) { //短路运算：即使用逻辑与运算时，假设前面的值为假，则运算符后面的运算不会执行  int c = 5; boolean d = (c\u0026lt;4)\u0026amp;\u0026amp;(c++\u0026lt;4);//因为c\u0026lt;4为假，所以后面c++不会被执行  System.out.println(d); System.out.println(c); } }     位运算：针对二进制数据进行的运算\n \u0026amp;：同位比较，全1才1，有0则0 |：同位比较，全0才0，有1则1 ^：同位比较，相同为0，不同位1 ~：取反符号。  package JavaSEbase; public class demo10 { public static void main(String[] args) { /* * A = 0011 1100 * B = 0000 1101 * ----------------------- * A\u0026amp;B = 0000 1100 * A|B = 0011 1101 * A^B = 0011 0001 * ~B = 1111 0010 * ----------------------- * */ } }   三元运算符\npackage JavaSEbase; public class demo11 { public static void main(String[] args) { //x ? y : z  //如果x为真，则结果为y，否则结果为z  int score = 50; String type = score \u0026lt; 60 ? \u0026#34;不及格\u0026#34;:\u0026#34;及格\u0026#34;; } }   +号运算符的特殊之处（运算符）\npackage JavaSEbase; public class demo10 { public static void main(String[] args) { int a = 10; int b = 20; a+=b;//相当于a = a+b  a-=b;//相当于a = a-b  System.out.println(a); //当+号前面有String 则自动把后面的运算也转换成String、  System.out.println(\u0026#34;\u0026#34;+a+b); System.out.println(a+b+\u0026#34;\u0026#34;); } }   包机制  命名规范  JavaDoc  https://blog.csdn.net/vbirdbest/article/details/80296136  ","date":"2020-03-28T16:22:25+08:00","image":"https://minster77.github.io/cover.jpg","permalink":"https://minster77.github.io/p/javase01/","title":"JavaSE01"},{"content":"JVM   概述 ​\t对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要想C/C++程序开发程序员那样为每一个new操作去写对于的delete/free操作，不容易出现内存泄漏和内存溢出问题。正是因为Java程序员把内存控制权力交给Java虚拟机，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那么排查错误将是一个非常艰巨的任务。\n运行时数据区域 Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK1.8和之前的版本若有不同。\nJDK1.8之前：\nJDK1.8：\n JDK1.8把线程共享的内存中的方法区移到了本地内存，变成了元空间\n 线程是共享的：\n **方法区：**存储虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态常量，即时编译后的代码等数据，也可能会抛出OutOfMemoryError异常。 **堆：**java虚拟机最大的内存区域，存放对象实例，也是垃圾收集器管理的主要区域，分为新生代（由Eden 与Survivor Space 组成）和老生代，可能会抛出OutOfMemoryError异常 直接内存（非运行时数据区的一部分）：jdk1.4中增加了NIO，可以分配堆外内存（系统内存替代用户内存），提高了性能。  线程是私有的：\n 程序计数器：程序计数器(处于线程独)占区是一个非常小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器 **虚拟机栈：**虚拟机栈描述的是Java方法执行的动态内存模型 **本地方法栈：**本地方法栈为虚拟机执行native方法服务  程序计数器 ​\t程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时可以通过改变这个程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成\n​\t另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有“的内存\n通过上面的介绍，我们可以知道程序计数器的两个作用：\n 字节码编译器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现了对程序流程的控制。如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了。  注意：程序计数器是唯一一个不会出现OutOfMemoryError（内存溢出异常）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\nJava虚拟机栈 ​\t与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描写的是Java方法执行的内存模型，每次方法调用数据都是通过栈传递的。\n​\tJava内存可以粗糙的分为堆内存和栈内存，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\n**栈帧：**每个方法执行时都要创建一个栈帧，方法执行完毕，栈帧销毁。栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等。\n局部变量表：局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），局部变量表的大小在编译期便已经可以确定，在运行时期不会发生改变。\nJava 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。\n StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常  Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。\n扩展：那么方法/函数如何调用？\nJava 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。\nJava 方法有两种返回方式：\n return 语句。 抛出异常。  不管哪种返回方式都会导致栈帧被弹出。\n本地方法栈 ​\t和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n​\t本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n​\t方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\n堆 ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""},{"content":"网络编程   概述   计算机网络：计算机网络是指将地理位置不同的具有独立功能的多态计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。\n​\t计算机网络是指两台或更多的计算机组成的网络，在一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。\n​\t那什么是互联网呢？互联网互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。\n​\t对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。\n​\tTCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。\n  网络通信中的要素   IP地址\n​\t在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。\n​\tIP地址分为IPv4（4个字节组成）和IPv6（8个无符号整数）两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。\n  域名\n​\t因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。\n 有一个特殊的本机域名localhost，它对应的IP地址总是本机地址127.0.0.1\n   网络模型\n​\t由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：\n 应用层，提供应用程序之间的通信； 表示层：处理数据格式，加解密等等； 会话层：负责建立和维护会话； 传输层：负责提供端到端的可靠传输； 网络层：负责根据目标地址选择路由来传输数据； 链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等    TCP协议和UDP协议\n TCP是专门设计用于在因特网上提供可靠的端到端的字节流通信的协议。它是一种面向连接的协议。TCP连接是字节流而非报文流（如银行转账系统）。 UDP是向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接（如语音、视频、游戏）。    ","date":"0001-01-01T00:00:00Z","permalink":"https://minster77.github.io/p/","title":""}]