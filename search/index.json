[{"content":"Java编程思想集合篇（二） Java HashMap为什么通过(n - 1) \u0026amp; hash 获取哈希桶数组下标？\n看过HashMap源码人应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，就是通过(n - 1) \u0026amp; hash来计算的，那么为什么用的是位运算而不是取模运算(hash % n)呢？\n获取hash桶数组下标源码\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 一. 位运算与取模运算时间比较\npackage com.polymorphic; public class Test { int a = 1; int number = 100000; // 数据集数量，初始定义为十万  // 位运算  public long bitwise() { long start = System.currentTimeMillis(); //从十万开始，一直到Integer的最大值，计算所需时间  for (int i = number; i \u0026gt; 0; i++) { a \u0026amp;= i; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\u0026#34;位运算时间为：\u0026#34; + time + \u0026#34;ms\u0026#34;); return time; } // 取模运算  public long module() { long start = System.currentTimeMillis(); for (int i = number; i \u0026gt; 0; i++) { a %= i; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\u0026#34;取模运算时间为：\u0026#34; + time + \u0026#34;ms\u0026#34;); return time; } public static void main(String[] args) { Test t = new Test(); t.bitwise(); t.module(); } } 运行结果为\n从测试结果我们可以看出，如果数据集足够的大，那么取模运算的时间将会是位运算时间的十几倍。这只是一方面，如果数据集足够大的话，HashMap的初始容量肯定不够，这也触发了HashMap的扩容机制。所以采用二进制位操作 \u0026amp;，相对于%能够提高运算效率\n二.位运算是如何保证索引不越界\n讲到这，我们也就要想想为什么HashMap的容量是2的n次幂？两者之间有着千丝万缕的联系。\n当 n 是2的次幂时， n - 1 通过 二进制表示即尾端一直都是以连续1的形式表示的。当(n - 1) 与 hash 做与运算时，会保留hash中 后 x 位的 1，这样就保证了索引值 不会超出数组长度。\n同时当n为2次幂时，会满足一个公式：(n - 1) \u0026amp; hash = hash % n。\n","date":"2021-08-01T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%BA%8C/","title":"Java编程思想集合篇（二）"},{"content":"编译类型、运行类型及多态的区别 Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态。\n 因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋值给一个父类引用变量，无须任何转型，或者被称为向上转型，由系统自动完成。  测试代码\n  Father类\npackage com.polymorphic; public class Father { public Father(){ System.out.println(\u0026#34;Father的构造方法\u0026#34;); } public void doWork(){ System.out.println(\u0026#34;Father Do Work!\u0026#34;); } }   Son类\npackage com.polymorphic; public class Son extends Father{ public Son(){ System.out.println(\u0026#34;Son的构造方法\u0026#34;); } public void doWork(){ System.out.println(\u0026#34;Son Do Work!\u0026#34;); } }   Test类\npackage com.polymorphic; public class Test { public static void main(String[] args) { Father child = new Son(); son.doWork(); } }   运行结果\n在测试类中：\nFather child = new Son(); 在这里我们声明了一个Father的引用变量，指向了Son类的一个实例，我们可以得知child这个引用变量的Father类就是编译类型，而new Son()中的Son类就是运行类型。\n  由运行结果可知：程序在运行时，首先会调用父类的构造器，然后再调用子类的构造器，接下来：在编译过程中，就会自动检查引用变量child的编译类型中，是否包含doWork方法，很明显，在父类中有doWork方法（如果没有会报错），但是，在JVM运行时，由于在子类中覆盖了doWork方法，所以child实际运行时，是调用了子类的doWork方法，而不是父类的，这也就是多态的一种（运行时多态）。\n  什么是编译类型和运行类型呢？\n ​\t引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法（意思是说：编写代码时，只能调用父类中具有的方法，如果子类重写了该方法，运行时实际调用的是运行时类型的该方法。程序在编译时，会在编译类型中检查是否具有所调用的方法，如果编写代码时，使用引用变量调用子类中的特有方法，或者调用了重载父类中的方法，而父类中找不到该方法，则会编译报错），因此，编写Java代码时，引用变量只能调用声明该变量所用类里包含的方法。与方法不同的是，对象的属性则不具备多态性。通过引用变量来访问其包含的实例属性时，系统总是访问它编译时类所定义的属性，而不是它运行时所定义的属性(属性无多态，方法具有多态)。\n​\t要访问子类中特有的方法和属性，在编写代码时，必须进行类型转换。\n——以上摘自《疯狂Java讲义》\n   什么是多态？\n 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n 在测试类中：\n//编译时类型 引用变量 运行时类型  Father child = new Son(); 这行代码编译时类型和运行时类型不一致(父类引用指向子类)，同时Son继承了Father并且重写了Father的doWork方法，这就是所谓的多态。\n  代码演示方法具有多态，属性无多态\nClass A\npackage com.polymorphic; public class A { String a = \u0026#34;This is A!\u0026#34;; public String getString(){ return this.a; } } **Class B **\npackage com.polymorphic; public class B extends A{ String a = \u0026#34;This is B!\u0026#34;; public String getString(){ return this.b; } } Test\npackage com.polymorphic; public class Test { public static void main(String[] args) { A a1 = new A(); System.out.println(a1.getClass()+\u0026#34; \u0026#34;+a1.getString()+\u0026#34; \u0026#34;+a1.a); B b1 = new B(); System.out.println(b1.getClass()+\u0026#34; \u0026#34;+b1.getString()+\u0026#34; \u0026#34;+b1.a); a1 = b1; System.out.println(a1.getClass()+\u0026#34; \u0026#34;+a1.getString()+\u0026#34; \u0026#34;+a1.a); b1 = (B)a1; System.out.println(b1.getClass()+\u0026#34; \u0026#34;+b1.getString()+\u0026#34; \u0026#34;+b1.a); A a2 = new B(); System.out.println(a2.getClass()+\u0026#34; \u0026#34;+a2.getString()+\u0026#34; \u0026#34;+a2.a); } } 运行结果\n ​\t从这个结果可以看出类继承时，子类会覆盖与父类相同的属性。总结一点就是：对象访问变量看声明，访问方法看实际对象类型（new出来的类型）。也可以说：属性无多态，而方法具有多态。\n   ","date":"2021-06-28T16:22:25+08:00","permalink":"https://minster77.github.io/p/polymorphic/","title":"polymorphic"},{"content":"JavaIO流2   BufferedReader与BufferedWriter 使用字节流实现对二进制文件复制 对象流 标准输入输出流 转换流 打印流 Properties类   BufferedReader与BufferedWriter   BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的。\n  关闭处理流的时候，只需要关闭外层流即可\n演示bufferedReader的使用\npackage com.java_io; import java.io.BufferedReader; import java.io.FileReader; public class BufferedReaderTest { public static void main(String[] args) throws Exception{ String path = \u0026#34;E://note.txt\u0026#34;; //创建BufferedReader对象  BufferedReader bufferedReader = new BufferedReader(new FileReader(path)); //按行读取，提高效率  String line; /* * bufferedReader.readLine()是按行读取文件的 * 当返回null时，表示已读取完毕 */ while ((line =bufferedReader.readLine())!=null){ System.out.println(line); } bufferedReader.close(); } }   需要注意的是，关闭流时只需要关闭BufferedReader。因为底层会自动关闭节点流\n底层代码\npublic void close() throws IOException { synchronized (lock) { if (in == null) return; try { in.close(); } finally { in = null; cb = null; } } }   演示BufferedWriter\npackage com.java_io; import java.io.BufferedWriter; import java.io.FileWriter; public class BufferedWriterTest { public static void main(String[] args) throws Exception{ String path = \u0026#34;E://a.txt\u0026#34;; //创建对象，把FileWriter的Boolean值置为true可以实现追加功能  //默认为false，会覆盖原来的内容  BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(path,true)); bufferedWriter.write(\u0026#34;hello,成志恒\u0026#34;); //插入一个当前系统的换行符  bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;hello2,成志恒\u0026#34;); bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;hello3,成志恒\u0026#34;); bufferedWriter.newLine(); bufferedWriter.close(); } }   使用bufferd进行文件拷贝\npackage com.bufferd; import java.io.*; public class BufferedCopy_ { public static void main(String[] args) { String path1 = \u0026#34;e://a.txt\u0026#34;; String path2 = \u0026#34;e://a1.txt\u0026#34;; BufferedReader br = null; BufferedWriter bw = null; String line; try { br = new BufferedReader(new FileReader(path1)); bw = new BufferedWriter(new FileWriter(path2)); while ((line = br.readLine())!=null){ bw.write(line); bw.newLine(); } } catch (IOException e) { e.printStackTrace(); } finally { try { if(br != null){ br.close(); } if(bw != null){ bw.close(); } } catch (Exception e) { e.printStackTrace(); } } } } 使用说明：\n BufferedReader和BufferedWriter是按照字符操作的 如果去操作二进制文件（声音，视频，doc，pdf），可能造成文件损坏    使用字节流实现对二进制文件复制   BufferedOutputstream和BufferedInputStream结合实现对图片的拷贝\npackage com.bufferd; import com.sun.xml.internal.ws.api.ha.StickyFeature; import java.io.*; public class BufferedOutputStream_ { public static void main(String[] args) { String path1 = \u0026#34;e://567.jpg\u0026#34;; String path2 = \u0026#34;e://678.jpg\u0026#34;; BufferedInputStream bis = null; BufferedOutputStream bos = null; try { bis = new BufferedInputStream(new FileInputStream(path1)); bos = new BufferedOutputStream(new FileOutputStream(path2)); byte[] b = new byte[1024]; int len; while((len = bis.read(b))!=-1){ bos.write(b,0,len); } System.out.println(\u0026#34;拷贝成功...\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { if(bis!=null){ bis.close(); } if (bos!=null){ bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } }   字节流可以操作二进制文件，也可以操作文本文件\n  对象流   序列化和反序列化\n 序列化就是在保存数据时，保存数据的值和数据类型 反序列化就是在恢复数据时，恢复数据的值和数据类型 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，改类必须实现两个接口之一：  Serializable //这是一个标记接口，没有方法 Externalizable //该接口有方法需要实现，一般不使用      ObjectOutputStream提供序列化功能\n  序列化后保存的文件格式不是纯文本的，而是按照序列化的格式来保存\n  常用的几种基本类型都实现了Serializable接口，所以可以直接保存其数据类型\n  如果需要实例化某个类的对象，该类需要实现Serializable\n  代码演示\npackage com.outputstream; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class ObjectOutputStream_ { public static void main(String[] args) throws Exception{ String filePath = \u0026#34;e:\\\\a.bat\u0026#34;; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); oos.write(100);//int -\u0026gt; Integer(实现了Serializable接口)  oos.writeBoolean(true);//boolean -\u0026gt; Boolean(实现了Serializable接口)  oos.writeChar(\u0026#39;a\u0026#39;);//char -\u0026gt; Character(实现了Serializable接口)  oos.writeUTF(\u0026#34;成志恒\u0026#34;);//string -\u0026gt; String(实现了Serializable接口)  oos.writeDouble(9.5);//double -\u0026gt; Double(实现了Serializable接口)  //保存一个dog对象  oos.writeObject(new Dog(\u0026#34;dog\u0026#34;,10)); oos.close(); System.out.println(\u0026#34;保存成功...\u0026#34;); } } class Dog implements Serializable { public Dog(String name, int age) { this.name = name; this.age = age; } private String name; private int age; }   ObjectInputStream提供反序列化功能\n 读取（反序列化）的顺序需要和你保存数据（序列化）的顺序一致 在反序列化的时候，如果需要调用对象（dog）的方法，则需要向下转型，而实现向下转型的关键是当前类可以引用dog类，即在当前类下引用类。  代码演示\npackage com.inputstream_; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import com.outputstream.Dog;8//引用dog类  public class ObjectInputStream_ { public static void main(String[] args) throws IOException, ClassNotFoundException { String filePath = \u0026#34;e:\\\\a.bat\u0026#34;; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readUTF()); System.out.println(ois.readDouble()); Object dog = ois.readObject(); System.out.println(\u0026#34;类型为:\u0026#34;+dog.getClass()); System.out.println(dog); //向下转型  Dog dog1 = (Dog)dog; System.out.println(dog1.getAge()); ois.close(); System.out.println(\u0026#34;反序列成功\u0026#34;); } }   注意事项和细节说明\n  读写顺序要一致\n  要求实现序列化或反序列化对象，需要实现Serializable接口\n  序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性\n//SerialVersionUID序列化的版本号，可以提高兼容性 private static final long serialVersionUID = 1L;   序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员\n//下面两个属性都不会被序列化 private static String color; private transient String nation;   序列化对象时，要求里面属性的类型也需要实现序列化接口\n代码演示\nMaster类\npackage com.outputstream; public class Master { } Dog类新增加一个Master类型的属性\nprivate Master master = new Master(); 此时运行ObjectOutputStream_系统会报错\n如果要解决上述问题，需要Master类实现Serializable接口\npackage com.outputstream; import java.io.Serializable; public class Master implements Serializable { } 此时再运行ObjectOutoutStream_，保存成功\n  序列化具备可继承性，也就是如果某类已经 实现了序列化，则它的所有子类也已经默认实现了序列化\n    标准输入输出流   System.in(标准输入：键盘)\n 该流为System类中的public final static InputStream in = null; 编译类型：InputStream 运行类型：BufferedInputStream    System.out(标准输出：显示器)\n 该流为System类中的public final static PrintStream out = null; 编译类型：PrintStream 运行类型：PrintStream    代码演示\npackage com.standard; import java.util.Scanner; public class OutAndIn { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入数据\u0026#34;); String next = scanner.next(); System.out.println(\u0026#34;next=\u0026#34;+next); } }   转换流   在读取文件内容时，会默认文件为utf-8方式编码的，一旦文件编码方式改变了，所读取到的信息就会产生乱码，所以有转换流的出现\n  转换流可以把一个字节流转换成字符流，而字节流读取文件信息可以按照其编码方式来读取，所以能很好解决乱码问题\n  转换流有InputStreamReader与OutputStreamWriter\n  InputStreamReader：Reader的子类，可以将InputStream包装成Reader\n  OutputStreamWriter：Writer的子类，可以将OutputStream包装成Writer\n  当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\n  可以在使用是指定编码格式（比如utf-8，gbk，gb2312等）\n    演示使用InputStreamReader转换流解决中文乱码问题\n将字节流FileInputStream转换成字符流InputStreamReader，指定编码gbk/utf-8\npackage com.inputstream_; import java.io.*; public class InputStreamReader_ { public static void main(String[] args) throws IOException { String filePath = \u0026#34;e:\\\\a.txt\u0026#34;; //1.将FieleInputStream转换成InputStreamReader，编码方式为gbk  InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath),\u0026#34;gbk\u0026#34;); //2.将InputStreamReader传入BufferedReader  BufferedReader br = new BufferedReader(isr); //3.读取文件  String s = br.readLine(); //4.打印文件内容  System.out.println(s); //5.关闭流  br.close(); } } 为了减少代码行数，在开发中经常把1和2合在一起写\nBufferedReader br = new BufferedReader( new InputStreamReader( new FileInputStream(filePath),\u0026#34;gbk\u0026#34;));   OutStreamWriter同理\npackage com.outputstream; import java.io.BufferedWriter; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; public class OutStreamWriter_ { public static void main(String[] args) throws IOException { String filePath = \u0026#34;e:\\\\a.txt\u0026#34;; String charSet = \u0026#34;utf-8\u0026#34;; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(filePath),charSet); osw.write(\u0026#34;hello,成志恒11\u0026#34;); osw.close(); } }   打印流   打印流只有输出流没有输入流\n  PrintStream(字节打印流)\n在默认情况下，PrintStream输出数据的位置是标准输出（显示器）\n演示代码\npackage com.print; import java.io.PrintStream; public class PrintStream_ { public static void main(String[] args) { PrintStream printStream = System.out; printStream.println(\u0026#34;hello,word\u0026#34;); printStream.close(); } } 通过查看Print的底层源码\npublic void print(String s) { if (s == null) { s = \u0026#34;null\u0026#34;; } write(s); } 可以知道print底层使用的是write，所以我们可以直接调用write进行打印/输出\nprintStream.write(\u0026#34;hello,word\u0026#34;,getBytes()); 所得运行结果跟上述一样。\n另外，通过System.setOut()方法可以将内容输出到指定的的设备上\nString filePath = \u0026#34;e:\\\\a.txt\u0026#34;; System.setOut(new PrintStream(filePath)); System.out.println(\u0026#34;hi，word！\u0026#34;); 运行结果\n  PrintWriter(字符字符打印流)\n PrintWriter使用完之后必须关闭流，否则写入的内容不会刷新  使用PrintWriter将内容输出到指定设备\npackage com.print; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class PrintWriter_ { public static void main(String[] args) throws IOException { PrintWriter printWriter = new PrintWriter(new FileWriter(\u0026#34;e:\\\\a.txt\u0026#34;)); printWriter.print(\u0026#34;hello.word!!!\u0026#34;); //必须关闭流！  printWriter.close();//相当于flush+关闭流  } }   Properties类   Properties类主要用于读取Java的配置文件。\n  传统的读取配置文件信息的方法\n代码演示\npackage com.properties; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class Properties_ { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(\u0026#34;src\\\\mysql.properties\u0026#34;)); String line = \u0026#34;\u0026#34;; while((line = br.readLine()) != null){ //利用split将等号前后的内容划分成两个数组  String[] split = line.split(\u0026#34;=\u0026#34;); System.out.println(split[0]+\u0026#34;值为\u0026#34;+split[1]); } } } 如果我们使用传统方法获取指定的ip值，会有很多问题，所以一般使用Properties类去读取配置文件\n  Properties类读取配置文件\n  该类是专门用于读取配置文件的集合类，配置文件的格式需要按照一下格式编写：\n 键=值\n键=值\n   注意：键值对不需要有空格，值不需要用引号括起来，默认类型为String\n  Properties的常见方法\n load：加载配置文件的键值对到Priperties对象 list：将数据显示到指定设备 getProperty(key)：根据键获取值 setProperty(key,value)：设置键值对到Properties对象 store：将Properties中的键值对存储到配置文件。在idea中，保存信息到配置文件，如果信息含有中文，会存储为Unicode码 http://tool.chinaz.com/tools/unicode/aspx Unicode码查询工具    代码演示\npackage com.properties; import java.io.FileReader; import java.io.IOException; import java.util.Properties; public class Properties_01 { public static void main(String[] args) throws IOException { //1.创建Properties对象  Properties properties = new Properties(); //2.加载指定文件  properties.load(new FileReader(\u0026#34;src\\\\mysql.properties\u0026#34;)); //3.把k-v输出到控制台  properties.list(System.out); //4.根据key值获取相对应的value  String user = properties.getProperty(\u0026#34;user\u0026#34;); System.out.println(\u0026#34;用户名=\u0026#34;+user); } } 运行结果\n  使用Properties类来创建配置文件\npackage com.properties; import java.io.FileWriter; import java.io.IOException; import java.util.Properties; public class Properties_02 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.setProperty(\u0026#34;charset\u0026#34;,\u0026#34;utf8\u0026#34;); properties.setProperty(\u0026#34;user\u0026#34;,\u0026#34;志恒\u0026#34;);//中文保存为Unicode码  properties.setProperty(\u0026#34;pwd\u0026#34;,\u0026#34;11111\u0026#34;); properties.store(new FileWriter(\u0026#34;src\\\\mysql2.properties\u0026#34;),null); System.out.println(\u0026#34;保存成功\u0026#34;); } } 运行结果\n  使用Properties来修改文件内容\n 如果该文件没有key，就会自动创建 如果该文件有key，就会修改  properties.setProperties(\u0026#34;pwd\u0026#34;,888888);   Properties父类是Hashtable，所以其核心代码底层就是Hashtable 的核心方法\npublic synchronized V put(K key, V value) { // Make sure the value is not null  if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable.  Entry\u0026lt;?,?\u0026gt; tab[] = table; int hash = key.hashCode(); int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; entry = (Entry\u0026lt;K,V\u0026gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) \u0026amp;\u0026amp; entry.key.equals(key)) { V old = entry.value; entry.value = value;//如果key存在，就替换  return old; } } addEntry(hash, key, value, index);//如果是新的值，就addEntry  return null; } ​\n  ","date":"2021-06-19T16:22:25+08:00","permalink":"https://minster77.github.io/p/java_io%E6%B5%81_2/","title":"Java_IO流_2"},{"content":"Java IO流1（概念及节点流）   文件 IO流原理及流的分类 InputStream的子类及使用 OutputStream的子类及使用 利用FileInputStream及FileOutputStream进行文件copy Reader与Writer的子类及使用 节点流和处理流   文件   文件是保存数据的地方，例如word文档，txt文档等都是文件。\n  文件流\n文件在程序中是以流的形式来操作的\n 流：数据在数据源(文件）和程序（内存）之间经历的路径 输入流：数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径    常用的文件操作\n    使用new File（String pathname）创建\npackage com.java_io; import org.junit.Test; import java.io.File; import java.io.IOException; public class FileCreate1 { public static void main(String[] args) { } //方法1：使用new File(filePath)创建文件  @Test public void createFile01() throws IOException { //创建的文件路径名称  String filePath = \u0026#34;e:\\\\news1.txt\u0026#34;; File file = new File(filePath); try { file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } }   使用new File(File parent,String child)创建\n@Test public void createFile02(){ File parentFile = new File(\u0026#34;e:\\\\\u0026#34;); String fileName = \u0026#34;news2.txt\u0026#34;; //此时的file对象在Java程序(内存)中只是一个对象而已  //只有执行了createNewFile方法才会真正在磁盘创建文件  File file = new File(parentFile,fileName); try { //此时在磁盘中创建了文件  file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } }   使用new File(String parent,String child)创建\n@Test public void createFile03(){ String parentPath = \u0026#34;e:\\\\\u0026#34;; //String parentPath = \u0026#34;e:/\u0026#34;; 也可以  String fileName = \u0026#34;new3.txt\u0026#34;; File file = new File(parentPath,fileName); try { file.createNewFile(); System.out.println(\u0026#34;文件创建成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } }   获取文件信息\n getName()：获取文件名字 getAbsolutePath()：获取文件绝对路径 getParent()：获取父级目录 length()：获取文件大小(字节) exists()：查看文件是否存在 isFile()：检测是不是一个文件 isDirectory()：检测是不是一个目录  代码演示\npackage com.java_io; import org.junit.Test; import java.io.File; public class fileInformation { public static void main(String[] args) { } @Test public void fileInformation(){ //先创建文件对象  File file = new File(\u0026#34;e:\\\\news1.txt\u0026#34;); //调用对应的方法，得到相应的信息  System.out.println(\u0026#34;文件名字=\u0026#34;+file.getName()); System.out.println(\u0026#34;文件绝对路径=\u0026#34;+file.getAbsolutePath()); System.out.println(\u0026#34;文件父级目录=\u0026#34;+file.getParent()); System.out.println(\u0026#34;文件大小（字节）=\u0026#34;+file.length()); System.out.println(\u0026#34;文件是否存在=\u0026#34;+file.exists()); System.out.println(\u0026#34;是不是一个文件=\u0026#34;+file.isFile()); System.out.println(\u0026#34;是不是一个目录=\u0026#34;+file.isDirectory()); } }   目录的操作\n delete()：删除目录。 mkdir()：创建一级目录 mkdirs()：创建多级目录  代码示例\n//检查目录下是否存在news2.txt文件，若存在则删除  @Test public void m1(){ File file = new File(\u0026#34;e:\\\\news2.txt\u0026#34;); if (file.exists()) { if (file.delete()) { System.out.println(\u0026#34;删除成功\u0026#34;); }else { System.out.println(\u0026#34;删除失败\u0026#34;); } }else { System.out.println(\u0026#34;找不到改文件...\u0026#34;); } } } 创建目录\n//检查e:\\\\demo\\\\a\\\\b\\\\c是否存在，若不存在则创建  @Test public void m2(){ String directoryPath = \u0026#34;e:\\\\demo\\\\a\\\\b\\\\c\u0026#34;; File file = new File(directoryPath); if (file.exists()) { System.out.println(\u0026#34;改目录存在...\u0026#34;); }else { if (file.mkdirs()) { System.out.println(directoryPath+\u0026#34;目录创建成功\u0026#34;); }else { System.out.println(directoryPath+\u0026#34;目录创建失败\u0026#34;); } } }   IO流原理及流的分类   输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中\n  输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中\n  流的分类\n 按操作数据单位不同分为：  字节流（8bit）：二进制文件使用 字符流（按字符）：文本文件使用   按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：字节流，处理流/包装流  而Java IO流有四个抽象基类\n    字节流 字符流     输出流 OutputStream Writer   输入流 InputStream Reader    其他的流都是继承于这四大基类的。下图是Java IO流的整体架构图\n所理解的流就像快递小哥，在物流中心和客户之间做传递作用\n  InputStream的子类及使用   InputStream的常用子类\n FileInputStream：文件输入流 BufferedInputStream：缓冲字节输入流 ObjectInoutStream：对象字节输入流    使用FileInputStream读取文件\nread()读取单个字节\npackage com.java_io; import org.junit.Test; import java.io.FileInputStream; import java.io.IOException; public class FileInputStreamTest { public static void main(String[] args) { } @Test public void InputStream(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; FileInputStream fileInputStream = null; int readFile = 0; try { //创建FileInputStream对象，用于读取文件  fileInputStream = new FileInputStream(filePath); //read()：从输入流中读取一个字节的数据，如果没有输入，则被阻止  //如果返回-1.则表示读取完毕  while ((readFile = fileInputStream.read())!=-1){ System.out.print((char) readFile); } } catch (Exception e) { e.printStackTrace(); }finally { //关闭文件流，释放资源  try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } read(byte[b])缓冲区读取b个字节\n@Test public void InputStream02(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; byte [] buf = new byte[8];//每次读取8个字节的数据  FileInputStream fileInputStream = null; int readLen = 0;//记录读取的字节数  try { fileInputStream = new FileInputStream(filePath); /* * 创建FileInputStream对象，用于读取文件 * 从输入流读取最多buf.length字节数据到字节数组，若没有输入，则阻塞此方法 * 如果返回值为-1，表示读取完毕 * 如果读取正常则返回读取的字节数*/ while((readLen = fileInputStream.read(buf))!=-1){ //new Sting(buf,0,len):把一个字节数组从0取到len构造成一个新的String  System.out.print(new String(buf,0,readLen)); } } catch (IOException e) { e.printStackTrace(); } finally { try { //关闭流，释放资源  fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 需要注意的是使用FileInputStream读取文件时，读取到的字符是乱码的\n    OutputStream的子类及使用   FileOutputStream\n演示使用FileOutputStream。将数据写到文件中，如果该文件不存在，则创建该文件。\npackage com.java_io; import org.junit.Test; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class FileOutputStreamTest { public static void main(String[] args) { } @Test public void fileOutputStream(){ String filePath = \u0026#34;e:\\\\hello.txt\u0026#34;; FileOutputStream fileOutputStream = null; try { //创建FileOutputStream对象，对文件操作  fileOutputStream = new FileOutputStream(filePath,true); //向文件写入一个字节的数据  fileOutputStream.write(\u0026#39;H\u0026#39;); //向文件写入字符串  //str.getBytes()将字符串转换为字节数组  String str = \u0026#34;Hello,Word!\u0026#34;; fileOutputStream.write(str.getBytes()); System.out.println(\u0026#34;写入成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } }   若需要写入指定的字符，使用\n//write(byte[] b,int off,int len); fileOutputStream.write(str.getBytes(),0,str.length()); 可以将len字节从偏移量off的指定字节数组写入此文件输入流\n  需要注意的是，如果使用\nfileOutputStream = new FileOutputStream(File file,boolean append); 时没有将append设置为true的话，系统会默认append的值为false，则会清空记事本再写入新的内容（覆盖之前的内容）。\n若需要换行或者添加制表符输入，使用其转义字符即刻\nfileOutputStream.write(\u0026#34;\\n\u0026#34;.getBytes());//换行 fileOutputStream.write(\u0026#34;\\t\u0026#34;.getBytes());//增加制表符     利用FileInputStream及FileOutputStream进行文件Copy   思路分析\n 创建文件的输入流，将文件读到程序中 创建文件的输出流，将读取到的文件输入写到指定的文件中    代码演示\npackage com.java_io; import org.junit.Test; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopy { public static void main(String[] args) { } /* * 将\u0026#34;e:\\\\567.jpg\u0026#34;复制到\u0026#34;d:\\\\567.jpg\u0026#34;*/ @Test public void fileCopy(){ String srcPath = \u0026#34;e:\\\\567.jpg\u0026#34;; String destPath = \u0026#34;d:\\\\567.jpg\u0026#34;; //创建输入流及输出流对象  FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try { //定义字节数组接收，提高效率  byte [] buf = new byte[1024]; int readlen = 0; fileInputStream = new FileInputStream(srcPath); fileOutputStream = new FileOutputStream(destPath); while ((readlen = fileInputStream.read(buf))!=-1){ fileOutputStream.write(buf,0,readlen); } System.out.println(\u0026#34;写入成功！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { try { //关闭输入输出流，释放资源  if(fileInputStream==null){ fileInputStream.close(); } if(fileOutputStream==null){ fileOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 需要注意的是，写入文件时，必须使用\nwrite(byte[],0,readLength) 写入。readLength为读入数据的长度，这样写可以避免byte数组过大时把其余子集读入造成文件损失\n  Reader与Writer的子类及使用   FileReader的相关方法：\n new FileReader(File/String)：创建对象 read()：每次读取单个字符并返回，如果到文件末尾，返回-1 read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾则返回-1。  相关API\n new String(char[])：将char[] 转换成String new String(char[],off,len)：将char[]的指定部分转换成String  代码演示\npackage com.java_io; import org.junit.Test; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class FileReaderTest { public static void main(String[] args) { } @Test public void FileReaderTest(){ String filePath = \u0026#34;e:\\\\story.txt\u0026#34;; FileReader fileReader = null; char [] chars = new char[1024]; try { //新建对象  fileReader = new FileReader(filePath); try { while ((fileReader.read(chars))!=-1){ System.out.println(chars); } } catch (IOException e) { e.printStackTrace(); } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { if(fileReader==null){ //关闭流，释放资源  fileReader.close(); } } catch (IOException e) { e.printStackTrace(); } } } }   FileWriter的相关方法\n new FileWriter(File/String)：覆盖模式，相当于流的指针在首端 new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端 write(int)：写入单个字符 write(char[])：写入指定数组 write(char[],off,len)：写入指定数组的指定部分 write(String)：写入整个字符串 write(String,off,len)：写入字符串的指定部分  相关API\n toCharArray：将String转换成char[];  注意：\n  FileWriter使用后，必须关闭(close)或刷新(flush),否则写入不到指定的文件\n  FileWriter的类图如下\n  FileWriter的使用\npackage com.java_io; import org.junit.Test; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; public class FileWriterTest { public static void main(String[] args) { } @Test public void FileWriter(){ String filePath = \u0026#34;e:\\\\note.txt\u0026#34;; FileWriter fileWriter = null; String str = \u0026#34;AD\u0026#34;; char [] chars ={\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}; int writerLen = 3; try { fileWriter = new FileWriter(filePath,true); fileWriter.write(\u0026#39;H\u0026#39;); fileWriter.write(\u0026#34;\\n\u0026#34;);//换行  fileWriter.write(str); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(chars); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(chars,0,writerLen); fileWriter.write(\u0026#34;\\n\u0026#34;); fileWriter.write(str,0,1); } catch (IOException e) { e.printStackTrace(); } finally { try { fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } }   如果需要换行或者输入制表符则可以\nfileWriter.write(\u0026#34;\\n\u0026#34;);//换行 fileWriter.write(\u0026#34;\\t\u0026#34;);//制表符     节点流和处理流   节点流可以从一个特定的数据源读写数据\n  处理流(包装流)是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter\n  分析BufferedReader处理流\n查看BufferedReader的源码可以知道，BufferedReader中定义了一个Reader属性，即他可以封装任意一个节点流，所以使用BufferedReader去操作的时候，其可以访问各种不同的数据源。其功能更为强大\nBufferedWriter同理。\n  节点流与处理流的区别和联系\n 节点流是底层流/低级流，直接跟数据源相接。 处理流(包装流)包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出 处理流(包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连    模拟装饰者设计模式来理解处理流BufferedReader/BufferedWriter\n创建Reader抽象类(Reader_)\npackage com.decorator_pattern; public abstract class Reader_ { public void readString(){ } public void readFile(){ } } 创建节点流子类FileReader_\npackage com.decorator_pattern; public class FileReader_ extends Reader_{ public void readFile(){ System.out.println(\u0026#34;readFile\u0026#34;); } } 创建节点流子类StringReader_\npackage com.decorator_pattern; public class StringReader_ extends Reader_{ public void readString(){ System.out.println(\u0026#34;readString\u0026#34;); } } 创建处理流BufferedReader_\npackage com.decorator_pattern; public class BufferedReader_ extends Reader_{ private Reader_ reader_;//属性时Reader_类型  public BufferedReader_(Reader_ reader_) { this.reader_ = reader_; } //封装方法  public void readFile(){ reader_.readFile(); } //装饰者模式的特性：增加新功能  public void readStrings(int num){ for (int i = 0; i \u0026lt; num; i++) { reader_.readString(); } } } Test类\npackage com.decorator_pattern; public class Test { public static void main(String[] args) { //新建bufferedReader_对象，把FileReader_传进去，使方法可以对文件操作  BufferedReader_ bufferedReader_1 = new BufferedReader_(new FileReader_()); bufferedReader_1.readFile(); //必须是相应的对象的方法才会有用  bufferedReader_1.readStrings(10);//无效  //新建bufferedReader_对象，把StringReader_传进去，使方法可以对字符串操作  BufferedReader_ bufferedReader_2 = new BufferedReader_(new StringReader_()); bufferedReader_2.readStrings(10); } } 测试结果\n通过上述设计模式可以让BufferedReader包装其他节点流，这样子就能提高对数据源操作的效率\n可以使用统一的一个read方法来优化上述代码。如：\n在Reader_抽象类中使用抽象方法read\npackage com.decorator_pattern; public abstract class Reader_ { public abstract void read(); } 然后子类实现此方法即可\npackage com.decorator_pattern; public class FileReader_ extends Reader_{ public void read(){ System.out.println(\u0026#34;readFile\u0026#34;); } } 此时，想要操作相应的数据则需要利用对象的动态绑定机制，绑定到对应的实现子类即可\t。\n所以Test中的\n//多态性，因为bufferedReader_1是new了FileReader_对象，所以去找FileReader_对象  bufferedReader_1.readStrings(10); 能输出readFile。\n  处理流的功能\n 性能的提高：主要以增加缓冲的方式来提高输入输出的效率 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便    ","date":"2021-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java_io%E6%B5%81/","title":"Java_IO流"},{"content":"单例设计模式 什么是设计模式  静态方法和属性的经典实用 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索  什么是单例模式   单例：就是单个的实例\n  所谓的类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法\n  单例模式有两种方式：\n  饿汉式（只有类被加载了，该对象就会被创建）\n 将构造器私有化 在类的内部之间创建（该对象是static） 提供一个公共的static方法，返回对象  例如，我们规定一个人必须专一，只能有一个女朋友！\npackage com.singleton; public class SingleTon { public static void main(String[] args) { GirlFriend instance = GirlFriend.getInstance(); System.out.println(instance); //无论你怎么创建，该对象都是同一个  GirlFriend instance1 = GirlFriend.getInstance(); System.out.println(instance1); //返回结果为True  System.out.println(instance==instance1); } } class GirlFriend{ private String name ; //在类内部创建了对象，加static是为了可以在静态方法中返回girlFriend对象  private static GirlFriend girlFriend = new GirlFriend(\u0026#34;小红\u0026#34;); //构造器私有化  private GirlFriend(String name){ this.name = name; } public static GirlFriend getInstance(){ return girlFriend; } @Override public String toString() { return \u0026#34;GirlFriend{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 由于类被加载之后，对象无论如何都会被创建，会造成资源的浪费。\npackage com.singleton; public class SingleTon { public static void main(String[] args) { System.out.println(GirlFriend.n); } } class GirlFriend{ private String name ; public static int n = 100; //对象，通常是重量级的对象，饿汉模式可能造成创建了对象，但没有使用  private static GirlFriend girlFriend = new GirlFriend(\u0026#34;小红\u0026#34;); //构造器私有化  private GirlFriend(String name){ System.out.println(\u0026#34;构造器被调用了\u0026#34;); this.name = name; } public static GirlFriend getInstance(){ return girlFriend; } @Override public String toString() { return \u0026#34;GirlFriend{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 使用懒汉式可以很好的解决这个问题\n  懒汉式（不调用就不会创建对象）\n 将构造器私有化 定义一个static静态属性对象 提供一个public的static方法，可以返回一个对象  懒汉式：只有当用户使用getInstance时才会返回一个对象。后面再调用时，会返回上次创建的对象\npackage com.singleton; public class SingleTon01 { public static void main(String[] args) { System.out.println(Cat.n); System.out.println(\u0026#34;================\u0026#34;); Cat cat = Cat.getInstance(); System.out.println(cat); } } class Cat{ private String name; public static int n = 100; private static Cat cat; private Cat(String name){ System.out.println(\u0026#34;构造器被调用\u0026#34;); this.name = name; } public static Cat getInstance(){ //判断有没有创建Cat对象  if(cat == null){ cat = new Cat(\u0026#34;miao\u0026#34;); } return cat; } @Override public String toString() { return \u0026#34;Cat{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }     饿汉式VS懒汉式\n 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例而懒汉式是在使用时才创建 饿汉式不存在线程安全问题，懒汉式存在线程安全问题 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。 在我们的JavaSE标准类中，java.lang.Runtime就是经典的单例模式    ","date":"2021-05-28T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"Java单例模式"},{"content":"JavaInterface   接口的基本介绍 接口的注意事项及使用细节 接口实现与类的继承 接口的多态性   接口基本介绍   接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。\n接口的定义：\ninterface 接口名{ //属性  //方法 } 类实现接口:\nclass ClassName implements Interface { //自己的属性  //自己的方法  //必须实现的接口的抽象方法 }   在jdk7前，接口里的所以方法都没有方法体，即都是抽象方法。\n  jdk8后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。但默认方法需要使用default关键字修饰\n  在接口中，定义抽象方法时可以省略abstract关键字。如果一个类实现了接口，则需要把接口的所有抽象方法都实现。\n代码演示\n创建接口Interface01\npackage com.interface_; public interface Interface01 { //定义属性  public int n =1; //定义抽象方法  public void A(); //定义默认方法  default public void B(){ System.out.println(\u0026#34;我是默认方法\u0026#34;); } //定义静态方法  public static void C(){ System.out.println(\u0026#34;我是静态方法\u0026#34;); } } 创建实现类InterfaceImp01\npackage com.interface_; public class InterfaceImp01 implements Interface01{ @Override public void A() { System.out.println(\u0026#34;实现抽象方法\u0026#34;); } @Override public void B() { Interface01.super.B(); } } 创建测试类InterfaceTest\npackage com.interface_; public class InterfaceTest { public static void main(String[] args) { InterfaceImp01 interfaceImp01 = new InterfaceImp01(); interfaceImp01.A(); interfaceImp01.B(); //调用静态方法  Interface01.C(); } } 输出结果：\n  对于初学者来说，接口的概念不难理解。难的是不知道什么时候使用接口，下面例举应用场景来理解接口的使用：\n 现在要制作战斗机，武装直升机。专家只需要把飞机需要的功能/规格定下来即可，然后让工程师来实现 现在有一个项目经理，管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员来实现。    接口的注意事项与使用细节   接口不能被实例化\n  接口中所有的方法都是public，接口中的抽象方法可以不用abstract修饰\ninterface Interface{ void say(); //相当于  public abstract void say(); }   一个普通类实现接口，就必须将该接口的所有方法都实现(可以使用alt+enter来解决)\n  抽象类去实现接口时，可以不实现接口的抽象方法\n  一个类可以同时实现多个接口。\n创建接口Interface01\ninterface Interface01{ say(); } 创建接口Interface02\ninterface Interface02{ hi(); } 实现类dog\nclass dog implements Interface01,Interface02{ @Override public void hi(){ } @Override public void say(){ } }   接口中的属性只能是final，而且是public static final修饰符。属性的访问形式为接口名.属性名\ninterface Interface01{ int n = 1; //实际上是  public static final int n = 1;//必须初始化值 } 证明：创建测试类InterfaceTest\npackage com.interface_; public class InterfaceTest { public static void main(String[] args) { //此处可以直接调用接口Interface01的属性，证明该属性为static  Interface01.n; Interface01.n = 10;//系统会报错，证明该属性被final修饰  } }   接口不能继承其他的类，但是可以继承其他接口。\ninterface Interface03 extends Interface01,Interface02{ } 而且继承其他接口时不用实现其他接口的方法。\n  接口的修饰符与类一样，只能是public或者是默认\n  思考题：下面程序是否正确，正确的话输出什么？\n//创建接口 public interface Interface02 { int a = 23; } //创建接口实现类 public class InterfaceImp02 implements Interface02{ } //创建测试类 public class InterfaceTest { public static void main(String[] args) { InterfaceImp02 imp02 = new InterfaceImp02(); System.out.println(imp02.a); //因为InterfaceImp02实现了接口Interface02 所以也可以成功输出  System.out.println(InterfaceImp02.a); //a为static属性，所以可以输出  System.out.println(Interface02.a); } } 代码正确，输出结果为\n  接口实现与类继承   当子类继承了父类，就会**自动的拥有父类的功能(方法)。**而如果子类需要拓展功能，可以通过实现接口的方式拓展\n  可以理解成实现接口就是对Java单继承机制的一种补充\n下面举个例子理解接口实现与类继承\n例：假如有一只小猴子悟空，他继承了父亲的爬树技能。当他看到鱼儿在游泳时，就跟鱼儿学习了游泳技能；当他看到鸟儿在飞翔时，就跟鸟儿学习了飞翔技能\u0026hellip;\n代码演示：\n创建猴子父类 Monkey\npackage com.interface_; public class Monkey { private String name; public Monkey(String name) { this.name = name; } public void climbing(){ System.out.println(name + \u0026#34;在爬树\u0026#34;); } } 子类LittleMonkey\npackage com.interface_; public class LittleMonkey extends Monkey{ public LittleMonkey(String name) { super(name); } } 此时，LittleMonkey继承了Monkey，所以很自然的会爬树\n因为悟空需要拓展技能，我们创建接口FishAble和BirdAble\npackage com.interface_; public interface FishAble { public void Swimming(); } package com.interface_; public interface BirdAble { public void flying(); } 而且LittleMonkey也实现了FishAble与BirdAble\npackage com.interface_; public class LittleMonkey extends Monkey implements BirdAble,FishAble{ public LittleMonkey(String name) { super(name); } @Override public void flying() { System.out.println(this.getName()+\u0026#34;通过学习，学会了飞翔\u0026#34;); } @Override public void Swimming() { System.out.println(this.getName()+\u0026#34;通过学习，学会了游泳\u0026#34;); } } 最终，悟空学会了飞翔与游泳\npublic class InterfaceTest { public static void main(String[] args) { LittleMonkey wuKong = new LittleMonkey(\u0026#34;悟空\u0026#34;); wuKong.climbing(); wuKong.flying(); wuKong.Swimming(); } }   实现接口VS继承类\n接口和继承解决的问题不同\n 继承的价值主要在于：解决代码的复用性和可维护性 接口的价值主要在于：设计好各种规范（方法），让它的实现类去实现这些方法。更加的灵活  接口比继承更加灵活\n  继承是满足is-a的关系，而接口只需满足like-a的关系即可。\n比如：猫它是动物(is-a)，而猫像鱼一样会游泳(like-a)\n  接口在一定程度上实现代码解耦（即：接口的规范性+动态绑定机制）\n  接口的多态性   接口类型的变量可以指向实现了接口类的对象实例\npackage com.interface_; public class InterfacePolyParameter { public static void main(String[] args) { //接口的多态体现  IF if01 = new Monster(); if01 = new Car(); } } interface IF{} class Monster implements IF{} class Car implements IF{}     多态参数的体现\n演示一个案例：有一个接口UsbInterface usb，既可以接收手机对象，又可以接收相机对象，就体现了接口的多态（接口引用可以指向实现了接口的类的对象）\n创建接口UsbInterface\npackage com.interface_; public interface UsbInterface { void start(); void stop(); } 创建接口实现类Phone1\npackage com.interface_; public class Phone1 implements UsbInterface{ @Override public void start() { System.out.println(\u0026#34;Phone开始工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Phone停止工作\u0026#34;); } } 创建接口实现类Camera1\npackage com.interface_; public class Camera1 implements UsbInterface{ @Override public void start() { System.out.println(\u0026#34;Camera开始工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Camera停止工作\u0026#34;); } } 创建类Computer01\npackage com.interface_; public class Computer01 { //1. UsbInterface usbInterface 说明Work的形参类型是UsbInterface  //2. 这个参数可以接收实现了UsbInterface接口的类的对象实例  public void Work(UsbInterface usbInterface){ usbInterface.start(); usbInterface.stop(); } } Tset\npackage com.interface_; public class InterfaceTest02 { public static void main(String[] args) { //创建手机对象，Phone1实现了UsbInterface接口  Phone1 phone1 = new Phone1(); //创建相机对象，Camera1实现了UsbInterface接口  Camera1 camera1= new Camera1(); //创建计算机对象  Computer01 computer01 = new Computer01(); //把手机接入电脑  computer01.Work(phone1); System.out.println(\u0026#34;===============\u0026#34;); //把相机接入电脑  computer01.Work(camera1); } } 运行结果\n  多态数组的体现\n演示一个案例：给定Usb数组中，存放Phone和Camera对象，Phone类还有一个特有的方法call()，请遍历Usb数组，如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用Phone特有方法call。\n创建接口Usb\ninterface Usb{ void Work(); } 创建接口实现类Phone2与Camrea2\nclass Phone2 implements Usb{ @Override public void Work() { System.out.println(\u0026#34;Phone工作了\u0026#34;); } public void call(){ System.out.println(\u0026#34;Phone打电话\u0026#34;); } } class Camera2 implements Usb{ @Override public void Work() { System.out.println(\u0026#34;Camera工作了\u0026#34;); } } 创建测试类InterfacePolyAry\npackage com.interface_; public class InterfacePolyAry { public static void main(String[] args) { //多态数组 -\u0026gt;接口类型数组  Usb[] usbs = new Usb[2]; usbs[0] = new Phone2(); usbs[1] = new Camera2(); for (int i = 0; i\u0026lt;usbs.length; i++){ usbs[i].Work();//多态绑定  //需要进行类型的向下转型  if(usbs[i] instanceof Phone2){ ((Phone2) usbs[i]).call(); } } } } 运行结果\n    接口存在多态传递现象（代码演示）\n创建接口InterfacePoly1\ninterface InterfacePoly1{ void hi(); } 创建接口InterfacePoly2继承了接口创建接口InterfacePoly1\ninterface InterfacePoly2 extends InterfacePoly1{ } 创建接口实现类InterfacePolyImp\nclass InterfacePolyImp implements InterfacePoly2{ @Override public void hi() { System.out.println(\u0026#34;hi\u0026#34;); } } 创建测试类InterfacePolyPass\npackage com.interface_; public class InterfacePolyPass { public static void main(String[] args) { //接口类型的变量可以指向实现了该接口的对象实例  InterfacePoly2 interfacePoly2 = new InterfacePolyImp(); //如果InterfacePoly2继承了InterfacePoly1接口，而InterfacePolyImp实现了InterfacePoly2接口  //那么实际上就相当于InterfacePolyImp实现了InterfacePoly1接口  //这就是所谓的接口多态传递现象  InterfacePoly1 interfacePoly1 = new InterfacePolyImp(); } }   ","date":"2021-05-04T16:22:25+08:00","permalink":"https://minster77.github.io/p/javainterface/","title":"JavaInterface"},{"content":"JavaException   什么是异常 异常体系结构 Java异常处理机制 自定义异常 总结   1、什么是异常   软件程序在运行过程中，非常可能遇到一些异常问题，在Java中称为异常。\n  异常指程序运行中出现的不期而至的各种状况，如文件找不到、网络连接错误等。\n  需要掌握的三种类型的异常\n 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常：运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。 错误ERROR：错误不是异常，而是脱离程序员控制的问题。    2、异常体系结构   在Exception分支中有一个重要的子类RuntimeException(运行时异常)\n ArrayIndexOutOfBoundsException(数组下标越界异常) NullPointerException(空指针异常) ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFountException（找不到类）  等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。\n  这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n  Exception与Error的区别\n Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程 Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能去处理这些异常    3、异常处理机制   当编写的代码出现异常时，程序会自动报出现异常错误\npackage com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; System.out.println(a/b); } } 控制台会报出Exception\n  在代码中加入了try\u0026hellip;catch\u0026hellip;finally异常处理机制\npackage com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; try{//监控区域  System.out.println(a/b); }catch (ArithmeticException e){//catch 捕获异常  System.out.println(\u0026#34;程序出现错误，变量b不能为0\u0026#34;); }finally {//处理后续工作  System.out.println(\u0026#34;finally\u0026#34;); } } } finally在异常捕获块中主要用于一些IO流及资源的关闭工作，可以不写。\ncatch里面的参数表示想要捕获的异常类型，Throwable为最高异常\n  假设要捕获多个异常，需要从小到大的去捕获\n  throw与throws主动抛出异常，前者用在方法中，后者用在方法上\npackage com.exception; public class Throw { public static void main(String[] args) { try { new Throw().test(1,0); } catch (ArithmeticException e) { e.printStackTrace(); } } //假设在方法中，处理不了这个异常，就用throws在方法上抛出  public void test(int a,int b)throws ArithmeticException{ if(b==0){ throw new ArithmeticException(); } } }   4、自定义异常   使用Java内置的异常类可以描述在编程中出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即刻。\n  在程序中自定义异常类，大体可以分为一次啊几个步骤：\n 创建自定义异常类 在方法中通过throw关键字抛出异常对象 如果在抛出异常的方法中处理异常，可以使用try\u0026hellip;catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续下一步操作 在出现异常方法类的调用中捕获并处理异常。  创建MyException异常类\npackage com.exception.demo02; //自定义异常类 public class MyException extends Exception{ int a = 5; public MyException(int a){ this.a = a; } @Override public String toString() { return \u0026#34;MyException{\u0026#34; + \u0026#34;a=\u0026#34; + a + \u0026#39;}\u0026#39;; } } 测试类Test\npackage com.exception.demo02; import com.oop.Tset; public class Test { public static void test(int a) throws MyException { System.out.println(\u0026#34;传递的参数为\u0026#34;+a); if(a\u0026gt;5){//如果参数大于5，抛出异常  throw new MyException(a); } System.out.println(\u0026#34;OK\u0026#34;); } public static void main(String[] args) { try { test(10); } catch (MyException e) {//捕获异常  System.out.println(e); } } }   5、总结  处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 对于不确定的代码，也可以加上try-catch处理潜在的异常 尽量去处理异常，切记知识简单地调用printStackTrace去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句去释放占用的资源  ","date":"2021-05-03T16:22:25+08:00","image":"https://minster77.github.io/Java_Exception.jpg","permalink":"https://minster77.github.io/p/javaexception/","title":"JavaException"},{"content":"Java内部类   内部类的基本介绍 局部内部类 匿名内部类 成员内部类 静态内部类   内部类基本介绍   一个类的内部又完整的嵌套了另一个类结构。被嵌套的类又称为内部类，嵌套其他类的类称为外部类。是类的五大成员之一（属性、方法、构造器、代码块、内部类）。\n  内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\n  基本语法\nclass Outer{//外部类  class Inner{//内部类  } } class Other{//外部其他类  }   内部类的分类\n 定义在外部类的局部位置上（比如方法内）：  局部内部类（有类名） 匿名内部类（没有类名，重点！）   定义在外部类的成员位置上：  成员内部类（没用static修饰） 静态内部类（使用static修饰）      局部内部类 说明：局部内部类是定义在外部类的局部位置上的，通常在方法中，并且有类名。\n  可以直接访问外部类的所有成员，包含私有的\n  不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final。（使用了final说明该内部类不能被继承！）\n  作用域：仅仅在定义它的方法或代码块中。\n  局部内部类访问外部类的成员（访问方式：直接访问）\n  外部类访问局部内部类的成员（访问方式：创建对象，再访问[注意，必须在作用域内！]）\n代码演示\npackage com.innerclass; public class LocalInnerClass { public static void main(String[] args) { Outer01 outer01 = new Outer01(); outer01.m2(); } } class Outer01{ private int n = 100; private void m1(){ System.out.println(\u0026#34;m1\u0026#34;); } public void m2(){ //定义为final就不能被继承  //作用域：定义它的方法或代码块中  final class Inner01{//局部内部类  public void f1(){ //访问外部类的成员属性n与m1  System.out.println(\u0026#34;n = \u0026#34;+ n); m1(); } } //外部类调用必须在内部类的作用域内！  Inner01 inner01 = new Inner01(); inner01.f1(); } }     外部其他类不能访问局部内部类！因为局部内部类是一个局部变量\n  如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想要访问外部类的成员，则可以使用(外部类目.this.成员)去访问。\nSystem.out.println(\u0026#34;OuterClass的n2 = \u0026#34;+ OuterClass.this.n2); OuterClass.this本质就是外部类的对象，即哪个对象调用了内部类作用域的方法，OuterClass.this就是哪个对象\n  匿名内部类 说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名（系统的底层有给他分配名字）。\n  匿名内部类的基本语法\nnew 类或接口(参数列表){ //类体 };   匿名内部类的本质（代码演示）\n有一个需求，想要使用AnonInterface接口，并创建对象。\n传统的方式是写一个类，实现该接口，并创建其对象。\nAnonmousInterface接口\ninterface AnonInterface{ public void cry(); } Tiger类\nclass Tiger implements AnonInterface{ public void cry(){ @Override System.out.println(\u0026#34;Titge 在叫\u0026#34;); } } 然后在main函数创建其对象即可\npackage com.innerclass; public class AnonymousInnerClass { public static void main(String[] args) { AnonInterface tiger = new Tiger(); tiger.cry(); } } 如果我们现在的需求改为Tiger类只使用一次，后面不再使用时。我们可以使用匿名内部类来简化开发。\nAnonInterface接口\ninterface AnonInterface{ public void cry(); } 外部类Outer02\nclass Outer02{ private int n = 10; public void method(){ //使用匿名内部类  AnonInterface tiger = new AnonInterface(){ @Override public void cry() { System.out.println(\u0026#34;tiger 在叫\u0026#34;); } }; tiger.cry(); } } main\npackage com.innerclass; public class AnonymousInnerClass { public static void main(String[] args) { Outer02 outer02 = new Outer02(); outer02.method(); } } 上述代码与传统方式均实现了需求，而且上面的代码，Tiger类只使用了一次。这就是匿名内部类的奇妙之处！\n思考：上述外部类Outer02中，Tiger的编译类型及运行类型分别是什么？\n  Tiger的编译类型为接口AnonInterface\n  Tiger的运行类型为匿名内部类 Outer02$1\n其实在使用匿名内部类时，底层是给该内部类分配了名字的\nClass Outer02$1 implements AnonInterface{ @Override pubilc void cry(){ System.out.println(\u0026#34;Tiger 在叫\u0026#34;); } } 我们通过getclass()方法可以验证上述代码。\nSystem.out.println(tiger.getClass()); 而且，在外部类Outer02中，AnonInterface tiger = new AnonInterface()这条语句的执行，jdk底层会在创建匿名内部类Outer02$1时，立刻创建Outer02$1实例，并且把地址返回给tiger\n  需要注意的是：匿名内部类Outer02$1是只使用一次，就不能再使用。而对象Tiger能重复使用！\n基于类构建的匿名内部类也与上述大体一致。\n  匿名内部类的细节\n  匿名内部类的语法比较奇特，需要注意的是，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征。因此可以直接调用匿名内部类的方法。\n代码演示：\n创建Person类\nclass Person{ public void hi(){ System.out.println(\u0026#34;hi\u0026#34;); } public void sayHi(String name){ System.out.println(\u0026#34;Hi \u0026#34;+name); } } 创建外部类Outer03\nclass Outer03{ private int i = 10; public void f1(){ Person person = new Person(){ @Override public void hi() { System.out.println(\u0026#34;匿名内部类重写了Hi方法\u0026#34;); } }; //动态绑定，person的运行类型是Outer03$1  person.hi(); //因为匿名内部类返回的是一个对象（new），所以可以直接调用方法  //在底层 class 匿名内部类 extends Person  new Person(){ @Override public void sayHi(String name) { super.sayHi(name); } }.sayHi(\u0026#34;jack\u0026#34;); } } 创建AnonymousInnerClassDetail\npackage com.innerclass; public class AnonymousInnerClassDetail { public static void main(String[] args) { Outer03 outer03 = new Outer03(); outer03.f1(); } } 输出结果：\n  外部其他类不能访问匿名内部类\n    匿名内部类的实践\n匿名内部类可以当做实参直接传递，简洁高效，避免硬编码\n创建接口InterfaceExercise\ninterface InterfaceExercise{ public void show(); } 创建InnerClassExercise01\npackage com.innerclass; public class InnerClassExercise01 { public static void main(String[] args) { //匿名内部类做形参，简洁高效。  f1(new InterfaceExercise(){ @Override public void show() { System.out.println(\u0026#34;这是一幅名画...\u0026#34;); } }); } //静态方法，参数是接口类型  public static void f1(InterfaceExercise iE){ iE.show(); } } 如果使用实现类实现该接口，那修改一个实现类的对象时会影响到其他的实现类对象。而使用匿名内部类，可以避免这个问题，并且这个类只使用一次即可。\n  成员内部类 说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。\n  可以直接访问外部类的所有成员，包含私有的\n  可以添加任意访问修饰符(public,protected,默认,private)，因为它的地位就是一个成员。\n代码演示：\n创建外部类Outer05\nclass Outer05{ private int i = 10; //定义在成员位置上，可以添加修饰符！  public class Inner04{ public void say(){ //可以访问外部类的私有属性  System.out.println(\u0026#34;成员内部类 i = \u0026#34;+i); } } //因为作用域是方法或代码块内，所以需要写一个方法来使用内部类  public void t1(){ Inner04 inner04 = new Inner04(); inner04.say(); } } 创建测试类MemberInnerClass\npackage com.innerclass; public class MemberInnerClass { public static void main(String[] args) { Outer05 outer05 = new Outer05(); outer05.t1(); } } 运行结果：\n  作用域与外部类的其他成员一样，为整个类体。比如上述案例，在外部类的成员方法中创建成员内部类对象，再调用方法。\n  外部其他类可以访问成员内部类\n外部其他类使用成员内部类的两种方式\n第一种方式\n//第一种方式 //outer05.new Inner04();相当于把 new Inner04()当做是outer05的成员 Outer05.Inner04 inner04 = outer05.new Inner04(); 第二种方式\n//在外部类中编写一个方法，可以返回一个Inner04的值 Outer05.Inner04 getInner04 = outer05.getInner04(); 外部类Outer05中\n//该方法返回一个成员内部类 Inner04 getInner04(){ return new Inner04(); }   静态内部类 说明：静态内部类定义在外部类的成员位置，并且有static修饰\n  可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问非静态成员\n  可以添加任意访问修饰符(public,protected,默认,private)，因为它的地位就是一个成员。\n  作用域：同其他成员，为整个类体\n代码演示\n创建Outer06类\nclass Outer06{ private int n1 = 10; private static int n2 = 100; static class Inner06{ void say(){ System.out.println(\u0026#34;hi n = \u0026#34; + n2); } } void t1(){ Inner06 inner06 = new Inner06(); inner06.say(); } } 创建测试类StaticInnerClass\npackage com.innerclass; public class StaticInnerClass { public static void main(String[] args) { Outer06 outer06 = new Outer06(); outer06.t1(); } } 运行结果：\n  静态内部类要访问外部类的话，可以访问其全部静态成员。\n  外部类访问静态内部类，需要先创建对象，再访问。\n  外部其他类使用静态内部类的方式有两种，与成员内部类的一样。\n  ","date":"2021-05-03T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E5%86%85%E9%83%A8%E7%B1%BB/","title":"Java内部类"},{"content":"深入面向对象   面向对象三大特性 static关键字详解 抽象类和接口 内部类及OOP实战   面向对象三大特性 封装   我们在程序设计中要追求“高内聚，低耦合”。\n 高内聚：就是类的内部数据操作细节由自己完成，不允许外部干涉 仅暴露少量的方法给外部使用    所以在设计时需要把一些数据与方法封装起来（数据的隐藏）\n  属性私有，get/set调用\n  作用\n 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 增加了系统可维护性    代码演示\nStudent类\npackage com.oop.demo02; //学生类 public class Student { private String name; private int age; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } Test类\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Student s1 = new Student(); s1.setName(\u0026#34;成志恒\u0026#34;); s1.setAge(21); s1.setSex(\u0026#34;男\u0026#34;); System.out.println(s1.getName()+\u0026#34; \u0026#34;+s1.getAge()+\u0026#34; \u0026#34;+s1.getSex()); } }   继承   继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\n  JAVA中类只有单继承，没有多继承\n  在java中，所有类都默认直接或者间接继承Object类\n继承使用关键字extends来表示，代码示例如下\nPerson类\npackage com.oop.demo03; public class Person { public int money = 10000; public String name = \u0026#34;mayun\u0026#34;; } Person类为父类，只定义了两个属性\nStudent类\npackage com.oop.demo03; public class Student extends Person{ public void print(){ System.out.println(this.money+\u0026#34; \u0026#34;+this.name); } } Student类为子类，继承了父类的属性与方法\nTest类\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); student.print(); } } 结果：\n由此可见，在Java中通过extends实现继承关系，而子类可以使用父类中的属性与方法（私有的不能调用）。\n  在继承中，当子类中有与父类相同的属性或方法时，可以使用super关键字来调用父类的属性或方法\n  super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。\n代码示例：\nPerson类\npackage com.oop.demo03; public class Person { public int money = 10000; public String name = \u0026#34;Person\u0026#34;; public void print(){ System.out.println(\u0026#34;Person调用了\u0026#34;); } } Student类\npackage com.oop.demo03; public class Student extends Person{ public int money = 50000; public String name = \u0026#34;Student\u0026#34;; public void print(){ System.out.println(\u0026#34;Student调用了\u0026#34;); } public void test(String name){ System.out.println(name); System.out.println(this.name); System.out.println(super.name); } public void test1(){ print();//子类的方法  this.print();//子类的方法  super.print();//父类的方法  } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); student.test(\u0026#34;成志恒\u0026#34;); System.out.println(); student.test1(); } } 运行结果:\n可以看到，this调用的是Student类中本身的值，super调用了Person类中的值。方法亦如此\n  super调用构造器\nPerson类\npackage com.oop.demo03; public class Person { public Person(){ System.out.println(\u0026#34;Person无参执行了\u0026#34;); } } Student类\npackage com.oop.demo03; public class Student extends Person{ public Student(){ System.out.println(\u0026#34;Student无参执行了\u0026#34;); } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { Student student = new Student(); } } 由此可见在Student类中的无参构造器默认调用了Person类中的无参构造器，即隐藏使用了super()方法。\n需要注意的是，super()方法必须要在子类构造器的第一行，否则系统会报错\n  super的注意点\n super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super与this不能同时调用构造方法    super与this的对比\n  代表的对象不同\nthis：本身调用者这个对象\nsuper：代表父类对象的应用\n  前提\nthis：没有继承也可以使用\nsuper：只能在继承条件才可以使用\n  构造方法\nthis()：本类的构造\nsuper()：父类的构造\n    方法的重写(父类的功能，子类不一定需要，所以要重写)\n 需要有继承关系，子类重写父类的方法，与属性无关 重写只跟非静态方法有关，方法名必须相同 参数列表必须相同 子类的方法必须要和父类的一致，方法体不同 IDEA快捷键：Alt+Insert ：override；  代码：\n父类B\npackage com.oop.demo03; public class B { public static void test1(){ System.out.println(\u0026#34;B==\u0026gt;test\u0026#34;); } public void test2(){ System.out.println(\u0026#34;B==\u0026gt;test\u0026#34;); } } 子类A\npackage com.oop.demo03; public class A extends B { public static void test1(){ System.out.println(\u0026#34;A==\u0026gt;test\u0026#34;); } @Override//注解（重写用）  public void test2() { System.out.println(\u0026#34;A==\u0026gt;test\u0026#34;); } } Test\npackage com.oop.demo03; public class Test { public static void main(String[] args) { A a = new A(); //父类的引用指向了子类  B b = new A(); a.test1(); b.test1(); System.out.println(\u0026#34;==============\u0026#34;); a.test2();//子类重写了父类的方法  b.test2(); } }   静态方法和非静态方法的区别\n 静态方法：方法的调用只与左边定义的数据类型有关 非静态：重写    多态   即同一方法可以根据发送对象的不同而采用多种不同的行为方式\n  一个对象的实际类型是确定的，但可以指向对象的引用类型有很多\n  对象能执行哪些方法，主要看左边的类型，与右边关系不大\n  多态存在的条件\n 有继承关系 子类重写父类的方法 父类引用子类对象  代码示例\nPerson类\npackage com.oop.demo04; public class Person { public void run(){ System.out.println(\u0026#34;run\u0026#34;); } } Student类\npackage com.oop.demo04; public class Student extends Person{ } Test\npackage com.oop.demo04; public class Test { public static void main(String[] args) { //一个对象的实际类型是可以确定的  //new Student  //new Person  //但可以指向的引用类型就不确定了：父类的引用指向子类  Student s1 = new Student(); Person s2 = new Student(); Object s3 = new Student(); s1.run(); s2.run(); } } 可以知道虽然s1，s2，s3的对象都是Student，但是它可以有不同的父类的引用，这就是方法的多态。\n如果子类重写了父类的方法，则执行子类的方法\n在Studunt类中重写run方法\npackage com.oop.demo04; public class Student extends Person{ @Override public void run() { System.out.println(\u0026#34;son run\u0026#34;); } } 运行结果：\n 假如在子类中写一个独有的方法，s2可以调用吗？\nStudent类\npackage com.oop.demo04; public class Student extends Person{ @Override public void run() { System.out.println(\u0026#34;son run\u0026#34;); } public void eat(){ System.out.println(\u0026#34;eat\u0026#34;); } } 在Student类中加了一个eat方法\n如果使用Test类中的s2调用这个方法，系统会报错\n所以父类可以指向子类，但是不能调用子类独有的方法\n  多态的注意事项：\n 多态是方法的多态，属性没有多态性 父类和子类需要有联系，不然会有类型转换异常(ClassCastException)    instanceof 是 Java 的一个二元操作符，类似于 ==，\u0026gt;，\u0026lt; 等操作符。\n  instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。\npackage com.oop.demo05; public class Test { public static void main(String[] args) { //Object \u0026gt; String  //Object \u0026gt; Person \u0026gt; Student  //Object \u0026gt; Person \u0026gt; Teacher  Object object = new Student(); System.out.println(object instanceof Student); System.out.println(object instanceof Person); System.out.println(object instanceof Object); System.out.println(object instanceof String); System.out.println(object instanceof Teacher); } }   ​\t需要注意的是若比较的两个类毫无联系，编译器会报错\n​\t  类型转换\n 父类引用指向子类的对象 把子类转换为父类：向上转型 把父类转换为子类：向下转型，强制转换  package com.oop.demo05; public class Test { public static void main(String[] args) { Student student = new Student(); student.run();//子类能直接调用父类的方法  Person person = student; ((Student)person).eat();//父类调用子类的方法需要强制转换  } }   Static关键字详解   static标注的属性或方法为静态属性或方法。\n  static(静态)方法只会在类加载的时候执行一次。\npackage com.oop.demo06; public class Person { //先与构造方法执行，可以用来定义常量  { System.out.println(\u0026#34;匿名代码块\u0026#34;); } //最先执行，但只执行一次  static { System.out.println(\u0026#34;静态代码块\u0026#34;); } //最后执行  Person(){ System.out.println(\u0026#34;构造方法\u0026#34;); } public static void main(String[] args) { Person person = new Person(); System.out.println(\u0026#34;================\u0026#34;); Person person1 = new Person(); } }   static关键字还可以用来静态导入包\n正常来说要使用Math类的方法每一次都需要在方法前面加\u0026quot;Math.\u0026quot;\nSystem.out.println(Math.random()); 否则会报错\n但是如果通过static导入包的话，就可以直接使用了\npackage com.oop; import static java.lang.Math.random; public class Tset { public static void main(String[] args) { System.out.println(random()); } }   抽象类和接口 抽象类   abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法，如果修饰类，那么该类就是抽象类\npackage com.oop.demo08; //抽象类 public abstract class Action { //抽象方法  public abstract void run(); }   抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类\npackage com.oop.demo08; public abstract class Action { public abstract void run(); public void go(){ System.out.println(\u0026#34;go\u0026#34;); } }   抽象类不能new 只能靠子类去实现它\n  抽象类存在的意义：在一些复杂的项目中，把公有属性抽象出来，再使用时只需要继承这个抽象类即可，提高开发效率。\n  接口   接口就是规范，定义的是一组规则，体现了现实世界中“如果你是\u0026hellip;则必须能\u0026hellip;”的思想。\n  接口的本质是契约。\n  接口中的所有定义的方法都是public abstract的；属性为常量。\n  接口定义的关键字为interface，接口都需要有实现类\n接口UserService\npackage com.oop.demo09; public interface UserService { void add(String name); void delete(String name); void update(String name); void query(String name); } 实现类UserServiceImp\npackage com.oop.demo09; //实现了接口的类就必须要实现接口中的所有方法 public class UserServiceImp implements UserService{ @Override public void add(String name) { } @Override public void delete(String name) { } @Override public void update(String name) { } @Override public void query(String name) { } }   利用接口可以实现多继承！\n接口TimeService\npackage com.oop.demo09; import java.sql.Time; public interface TimeService { Time timer(); } 接口RunService\npackage com.oop.demo09; public interface RunService { void run(); } 实现类TestImp\npackage com.oop.demo09; import java.sql.Time; public class TestImp implements TimeService,RunService{ @Override public void run() { } @Override public Time timer() { return null; } }   内部类  内部类就是在一个类的内部再定义一个类  成员内部类 静态内部类 局部内部类 匿名内部类    ","date":"2021-05-02T16:22:25+08:00","image":"https://minster77.github.io/Java_OOP_02.jpg","permalink":"https://minster77.github.io/p/javaoop_02/","title":"JavaOOP_02"},{"content":"初识面向对象   初识面向对象 方法回顾和加深 对象的创建分析   初识面向对象   面向过程思想\n 步骤清晰简单，第一步做什么，第二部做什么\u0026hellip;. 面向过程适合处理一些较为简单的问题    面向对象思想\n 物以类聚，分类的思想模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！    对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。\n  面向对象编程的本质就是：以类的方式组织代码，以对象的形式组织(封装)数据\n  面向对象的三大特性\n 封装：封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。 继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 多态：多态是同一个行为具有多个不同表现形式或形态的能力。    回顾方法和加深   静态方法与非静态方法的调用\n 静态方法定义： 在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。  Student类\npackage com.oop.demo01; public class Student { //静态方法  public static void eat(){ System.out.println(\u0026#34;kazikazi\u0026#34;); } //非静态方法  public void say(){ System.out.println(\u0026#34;hello\u0026#34;); } } Demo01类\npackage com.oop.demo01; public class Demo01 { public static void main(String[] args) { //调用静态方法可以直接调用  Student.eat(); System.out.println(\u0026#34;========================\u0026#34;); //调用非静态方法时需要实例化对象 new  //对象类型 对象名字 = new 对象值；  Student student = new Student(); student.say(); } } 运行结果\n可以知道，静态方法在main方法中调用可以直接调用，非静态方法则需要先实例化类(new一个对象)才能调用\n  值传递\npackage com.oop.demo01; public class Demo02 { public static void main(String[] args) { int a = 1; System.out.println(a);//1  change(a);//实参  System.out.println(a);//1  } //返回值为空  public static void change(int a){//形参  a = 10; } } 上述代码中a的值没有改变是因为实参传递给形参的是值 形参和实参在内存上是两个独立的变量 对形参做任何修改不会影响实参\n 通俗来说就是：小明去餐厅看到别人桌子上的糯米鸡好吃，然后小明就叫服务员点了一份糯米鸡，小明吃完了，别人桌上的却不受影响，因为他们吃的不是同一份糯米鸡。\n   引用传递\npackage com.oop.demo01; public class Demo04 { public static void main(String[] args) { Person person = new Person(); person.name = \u0026#34;高佬\u0026#34;; System.out.println(person.name); Demo04.change(person); System.out.println(person.name); } public static void change(Person person){ //person是一个对象，指向了一个对象  person.name=\u0026#34;志恒\u0026#34;; } } class Person{ String name; } 实参传递给形参的是参数对于 堆内存上的引用地址 实参和 形参在内存上指向 了同一块区域 对形参的修改会影响实参\n  对象的创建分析 对象的创建   对象可以通过new关键字来创建，示例如下\n创建一个Student类\npackage com.oop.demo02; //学生类 public class Student { //属性  String name; int age; //方法  public void print(){ System.out.println(this.name+\u0026#34;学生在学习\u0026#34;); } } Test类\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { /* 类：抽象的，需要实例化 * 类实例化之后会返回一个自己的对象 * student对象就是一个Student类的具体实例 * */ Student student1 = new Student(); Student student2 = new Student(); //给对象赋值  student1.name = \u0026#34;小明\u0026#34;; student1.age = 10; System.out.println(student1.name); System.out.println(student1.age); System.out.println(student2.name); System.out.println(student2.age); } } 运行结果：\n  使用new关键字创建的时候，除了分配空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用。\n  构造器   构造器又叫构造方法，在进行创建对象的时候必须要调用的。并且构造器有一下两个特点：\n 必须和类的名字相同 必须没有返回类型，也不能写void  作用\n 使用new关键字，本质就是在调用构造器 初始化对象的值  注意点\n 定义有参构造之后，如果想使用无参构造，就必须显示的定义一个无参的构造   ait+Insert IDEA生成构造器的快捷键\n   构造器代码示例：\nPerson类：\npackage com.oop.demo02; public class Person { //一个类即使什么都不写，它都会存在一个方法（构造器）  //显示的定义构造器  String name; int age; //无参构造  public Person() { } //有参构造：一旦定义了有参构造，无参就必须显示定义  public Person(String name,int age) { this.name = name; this.age = age; } } Test类：\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Person person = new Person(\u0026#34;minster\u0026#34;,21); System.out.println(person.name+\u0026#34; \u0026#34;+person.age); } }   对象的内存分析   首先先创建一个简单的Pet类\npackage com.oop.demo02; public class Pet { String name; int age; public Pet() { } public Pet(String name, int age) { this.name = name; this.age = age; } public void shout(){ System.out.println(this.name+\u0026#34;在叫\u0026#34;); } } Tset\npackage com.oop.demo02; //一个项目只能有一个main方法 public class Test { public static void main(String[] args) { //new 实例化一个对象  Pet dog = new Pet(\u0026#34;旺财\u0026#34;,3); Pet cat = new Pet(\u0026#34;cat\u0026#34;, 3); dog.shout(); cat.shout(); } } 内存分析图\n在内存中，创建一个对象，栈空间中存放的是对象的引用，而堆空间中存放的是new出来的东西，栈、堆两个空间通过一个内存地址相互连接。\n  ","date":"2021-05-01T16:22:25+08:00","image":"https://minster77.github.io/Java_OOP_01.jpg","permalink":"https://minster77.github.io/p/javaoop_01/","title":"JavaOOP_01"},{"content":"Java数组   数组概述 数组声明创建 java内存分析 数组使用 多维数组 Arrays类 冒泡排序 稀疏数组   数组概述  数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 每一个数据称作一个数组元素，数组元素可以通过一个下标来访问  数组声明与创建   首先必须声明数组变量，才能在程序中使用数组(声明时数组并不存在)。声明方法：\ndataType[] arrayRefvar;\t//首选方法 dataType addayRefvar[];\t//效果相同，但不是首选方法   java语言使用new操作符来创建方法(创建后数组就存在了)，语法如下：\ndataType[] arrayRefvar = new dataType[arraySize];   数组的元素是通过索引访问的，数组索引从0开始\n  获取数组长度：arrays.length\n  联系：给数组赋值并累加求值\npackage com.heng.array; public class Demo01 { public static void main(String[] args) { int[] arrays = new int[10]; int sum = 0; for (int i = 0; i \u0026lt;arrays.length ; i++) { arrays[i] = i; } for (int i = 0; i \u0026lt;arrays.length ; i++) { sum+=arrays[i]; } System.out.println(sum); } }   初始化\npackage com.heng.array; public class Demo02 { public static void main(String[] args) { //静态初始化:创建+赋值  int[] a = {1,2,3,4}; Demo01[] demo01s = {new Demo01(),new Demo01()}; //动态初始化  int[] b = new int[10]; } }   数组的四个基本特点\n 数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同的数据类型，不允许出现混合类型 数组中的元素可以是任何类型，包括基本类型和引用类型 数组可以看做一个对象，Java对象是在堆中的，数组对象本身是在堆中的。    数组边界\n数组的合法区间：[0,length-1],如果越界就就会报错！\npackage com.heng.array; public class Demo03 { public static void main(String args[]){ int[] a = new int[2]; System.out.println(a[2]);//越界！  } }   Java内存分析   堆\n 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用    栈\n 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址）    方法区\n 可以被所有的线程共享 包含了所有的class和static变量    java内存分析图示\n  数组使用   For-Each循环\npackage com.heng.array; public class Demo04 { public static void main(String[] args) { int[] array = {1,2,3,4,5}; for (int i : array) { System.out.println(i); } } }   数组作为参数\npackage com.heng.array; public class Demo05 { public static void main(String[] args) { int[] arrays = {1,2,3,4,5}; printArrays(arrays); } public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } } }   数组做返回值\npackage com.heng.array; public class Demo05 { public static void main(String[] args) { int[] arrays = {1,2,3,4,5}; int[] reverse = reverse(arrays); printArrays(reverse); } //反转数组  public static int[] reverse(int[] arrays){ int[] result = new int[arrays.length]; for (int i = 0,j=result.length-1; i \u0026lt; arrays.length; i++,j--) { result[j] = arrays[i]; } return result; } //打印数组  public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } } }   多维数组   多维数组可以看成是数组的数组。例如一个二维数组就是一个特殊的一维数组，每一个元素都是一个一维数组\n  多维数组的组成\npackage com.heng.array; public class Demo06 { public static void main(String[] args) { //创建一个二维数组  int[][] arrays = {{1,2},{3,4},{5,6},{7,8}}; /* * 相当于一个四行二列 [4][2] * {1,2} arrays[0] * {3,4} arrays[1] * {5,6} arrays[2] * {7,8} arrays[3] * */ //打印arrays[0]所得的结果为arrays[0]的地址  System.out.println(arrays[0]); System.out.println(\u0026#34;==================\u0026#34;); //但是通过printArrays函数打印就能把arrays[0]的值打印出来  printArrays(arrays[0]); System.out.println(\u0026#34;==================\u0026#34;); //或者用二维数组打印方式打印  System.out.println(arrays[0][0]+\u0026#34; \u0026#34;+arrays[0][1]); } public static void printArrays(int[] arrays){ for (int i = 0; i \u0026lt; arrays.length; i++) { System.out.print(arrays[i]+\u0026#34; \u0026#34;); } System.out.println(); } }   Arrays类   数组的工具类java.util.Arrays\n  该类包含用于操作数组的各种方法（如排序和搜索）。\npackage com.heng.array; import java.util.Arrays; public class Demo07 { public static void main(String[] args) { int[] a = {2,4,5,6,71,1,15,48,89,12,545}; System.out.println(Arrays.toString(a)); Arrays.sort(a);//排序方法 ：升序  System.out.println(Arrays.toString(a)); } }   冒泡排序   冒泡排序是最常用的八大排序算法之一，通过嵌套循环实现\n  冒泡排序的原理\n 比较数组中两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置 每一次比较都会产生一个最大或者最小的数字 下一轮则可以少一次排序 一次循环，直到结束    示例代码\npackage com.heng.array; import java.util.Arrays; public class Demo08 { public static void main(String[] args) { int[] a = {1,5,10,55,2,444,64,50}; System.out.println(Arrays.toString(a));\tSystem.out.println(\u0026#34;=================\u0026#34;); int[] sort = sort(a); //调用完排序方法后，返回一个排序后的数组  System.out.println(Arrays.toString(a)); } public static int[] sort(int[] array){ //临时变量  int temp = 0; //外层循环，判断我们要走多少次  for (int i = 0; i \u0026lt; array.length-1; i++) { //通过flag标识减少没有意义的比较  boolean flag = false; //内层循环，比较判断两个数，交换位置  for (int j = 0; j \u0026lt; array.length-1-i; j++) { if(array[j+1]\u0026gt;array[j]){ temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; flag = true; } } if(flag==false){ break; } } return array; } }   稀疏数组   稀疏数组就是一种数据结构\n  当一个数组中大部分元素为0，或者为同一值得数组时，可以使用稀疏数组来保存该数组。\n  稀疏数组的处理方式是：\n 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序的规模    原始数组转换成稀疏数组\npackage com.heng.array; public class Demo09 { public static void main(String[] args) { //五子棋游戏：创建一个二维数组 11*11 0：没有旗子 1：黑棋 2：白棋  int[][] array1 = new int[11][11]; array1[1][2] = 1; array1[2][3] = 2; //输出原始的数组  System.out.println(\u0026#34;输出原始的数组\u0026#34;); for (int[] ints:array1) { for (int anInt:ints) { System.out.print(anInt+\u0026#34;\\t\u0026#34;); } System.out.println(); } //转换为稀疏数组  //获取有效值的个数  int sum = 0; for (int i = 0; i \u0026lt; 11; i++) { for (int j = 0; j \u0026lt; 11; j++) { if(array1[i][j]!=0){ sum++; } } } System.out.println(\u0026#34;有效值为：\u0026#34;+sum); //创建一个稀疏数组  int[][] array2 = new int[sum+1][3]; array2[0][0] = 11; array2[0][1] = 11; array2[0][2] = sum; //遍历二维数组，将非0的值存放到稀疏数组中  int count = 0; for (int i = 0; i \u0026lt; array1.length; i++) { for (int j = 0; j \u0026lt; array1[i].length; j++) { if(array1[i][j]!=0){ count++; array2[count][0] = i; array2[count][1] = j; array2[count][2] = array1[i][j]; } } } //输出稀疏数组  System.out.println(\u0026#34;输出稀疏数组\u0026#34;); for (int i = 0; i \u0026lt; array2.length; i++) { System.out.println(array2[i][0]+\u0026#34;\\t\u0026#34; +array2[i][1]+\u0026#34;\\t\u0026#34; +array2[i][2]+\u0026#34;\\t\u0026#34;); } } }   稀疏数组还原\n//输出稀疏数组  System.out.println(\u0026#34;输出稀疏数组\u0026#34;); for (int i = 0; i \u0026lt; array2.length; i++) { System.out.println(array2[i][0]+\u0026#34;\\t\u0026#34; +array2[i][1]+\u0026#34;\\t\u0026#34; +array2[i][2]+\u0026#34;\\t\u0026#34;); } System.out.println(\u0026#34;=======================\u0026#34;); System.out.println(\u0026#34;还原\u0026#34;); //稀疏数组转换成原始数组  //1.读取稀疏数组  int[][] array3 = new int[array2[0][0]][array2[0][1]]; //2.给其中的元素还原值  for (int i = 1; i \u0026lt; array2.length; i++) { array3[array2[i][0]][array2[i][1]] = array2[i][2]; } System.out.println(\u0026#34;输出还原后的数组\u0026#34;); for (int[] ints:array1) { for (int anInt:ints) { System.out.print(anInt+\u0026#34;\\t\u0026#34;); } System.out.println(); }   ","date":"2021-04-20T16:22:25+08:00","image":"https://minster77.github.io/cover04.jpg","permalink":"https://minster77.github.io/p/javaarray/","title":"JavaArray"},{"content":"Java集合类(四)   开发中如何选择集合实现类 TreeSet底层源码剖析 TreeMap底层源码剖析 Collections工具类 集合章节练习题   开发中如何选择集合实现类  在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：   先判断存储的类型（一组对象[单列]或一组键值对[双列]） 一组对象[单列]：Collection接口  允许重复：List  增删多：LinkedLike（底层维护了一个双向链表） 改查多：ArrayList（底层维护了Object类型的可变数组）   不允许重复：Set  无序：HashSet（底层是HashMap，维护了一个哈希表【数组+链表+红黑树】） 排序：TreeSet 插入和取出顺序一致：LinkeHashSet（底层是LinkedHashMap），维护了数组+双向链表     一对键值对：Map  键无序：HashMap（底层是哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树） 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap（底层是HashMap） 读取文件：Properties    TreeSet底层源码剖析   TreeSet的底层就是TreeMap\n key不允许重复。    TreeSet可以实现有序排序，但是当我们使用其无参构造器时，仍然是无序的。要使用TreeSet提供的一个构造器，传入一个比较器（匿名内部类）才能实现排序\n下面使用TreeSet对数据进行排序（按字符串长度比较）\n创建测试类TreeSet_\npackage com.conllection_.sets; import java.util.Comparator; import java.util.TreeSet; public class TreeSet_ { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度进行比较  return ((String)o1).length() - ((String)o2).length(); } }); treeSet.add(\u0026#34;jack\u0026#34;); treeSet.add(\u0026#34;tom\u0026#34;); treeSet.add(\u0026#34;a\u0026#34;); treeSet.add(\u0026#34;ha\u0026#34;); treeSet.add(\u0026#34;xiaohu\u0026#34;); System.out.println(\u0026#34;treeSet = \u0026#34; +treeSet); } } debug调试，我们可以看到TreeSet此时使用的构造器\npublic TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } 可以发现，该构造器把我们的一个比较器（匿名内部类）对象传到了TreeSet的底层TreeMap\npublic TreeMap(Comparator\u0026lt;? super K\u0026gt; comparator) { this.comparator = comparator; } 并且把比较器对象赋给了TreeMap的属性comparator。\n在调用treeSet.add(\u0026ldquo;tom\u0026rdquo;);时，在底层会执行put的方法\npublic boolean add(E e) { return m.put(e, PRESENT)==null; } 继续往下走，可以发现程序执行以下代码\nint cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths //cpr为我们传进去的匿名内部类 Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; //动态绑定到我们的匿名内部类对象，且调用了其compare方法。  cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else//如果两个元素比较后相等，即返回0，这个key就不能加入进去  return t.setValue(value); } while (t != null); } 此时的treeSet集合如下\n运行结果\n需要注意的是，排序规则可以自己定义，按照需求来定义。\n  TreeMap底层源码剖析   TreeMap机制与TreeSet大体一致，但TreeMap是键值对方式存储数据\n  TreeMap底层实现的是Entry数组\n创建TreeMap_测试类\npackage com.conllection_.maps; import java.util.Comparator; import java.util.TreeMap; public class TreeMap_ { public static void main(String[] args) { //使用有参构造，重写比较器  TreeMap treeMap = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { //按照字符串长度进行比较  return ((String)o1).length()-((String)o2).length(); } }); treeMap.put(\u0026#34;jack\u0026#34;,\u0026#34;杰克\u0026#34;); treeMap.put(\u0026#34;tom\u0026#34;,\u0026#34;汤姆\u0026#34;); treeMap.put(\u0026#34;xiaohu\u0026#34;,\u0026#34;小虎\u0026#34;); treeMap.put(\u0026#34;mary\u0026#34;,\u0026#34;玛丽\u0026#34;);//替换杰克  System.out.println(\u0026#34;treeMap = \u0026#34;+ treeMap); } } 调试程序，执行put方法，首次添加时会进行初始化\nEntry\u0026lt;K,V\u0026gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check  root = new Entry\u0026lt;\u0026gt;(key, value, null); size = 1; modCount++; return null; } 因为此时只有一个元素，不能进行比较，所以就直接添加到Entry里面了\n继续添加元素，程序执行以下代码\nint cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } 此时会调动到比较器进行比较，与TreeSet不同的是当key值比较结果相同时，程序会把新增的key的value值替换掉原来的key的value值。\n需要注意的是，key不能为null\n  Collections工具类   Collections是一个操作Set、List和Map等集合的工具类\n  Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n  排序操作（均为static方法）\n reverse(List)：反转List中元素的顺序 shuffle(List)：对List集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定List集合元素按升序排序 sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序 swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换  代码演示\n创建Collections01测试类\npackage com.collections_; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Collections02 { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;smith\u0026#34;); list.add(\u0026#34;h\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 1. reverse(List)：反转List中元素的顺序  Collections.reverse(list); System.out.println(\u0026#34;将list反转后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 2. shuffle(List)：对List集合元素进行随机排序  Collections.shuffle(list); System.out.println(\u0026#34;将list元素进行随机排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 3. sort(List)：根据元素的自然顺序对指定List集合元素按升序排序  Collections.sort(list); System.out.println(\u0026#34;自然排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 4. sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序  Collections.sort(list, new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度排序  //可以加入一些校验代码，提高严谨性  return ((String)o1).length()-((String)o2).length(); } }); System.out.println(\u0026#34;按字符串长度排序后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); // 5. swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换  Collections.swap(list,1,3); System.out.println(\u0026#34;将下标为1的元素与下标为3的元素互换\u0026#34;); System.out.println(\u0026#34;list = \u0026#34;+list); } } 运行结果：\n  查找、替换\n Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素 Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素 int frequency(Collection,Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值  代码演示\n创建Collections02测试类\npackage com.collections_; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Collections02 { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;smith\u0026#34;); list.add(\u0026#34;h\u0026#34;); System.out.println(\u0026#34;List = \u0026#34;+list); // 1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素  System.out.println(\u0026#34;返回自然顺序中的最大元素\u0026#34;); System.out.println(\u0026#34;然顺序中的最大元素是\u0026#34;+Collections.max(list)); // 2. Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素  System.out.println(\u0026#34;返回Comparator指定的顺序中的最大元素\u0026#34;); //比如返回字符串长度最长元素  Object maxObject = Collections.max(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String)o1).length() - ((String) o2).length(); } }); System.out.println(\u0026#34;字符串长度最长元素是\u0026#34; + maxObject); // 3. Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 // 4. Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素 // 5. int frequency(Collection,Object)：返回指定集合中指定元素的出现次数  System.out.println(\u0026#34;tom出现的次数为\u0026#34; + Collections.frequency(list, \u0026#34;tom\u0026#34;)); // 6. void copy(List dest,List src)：将src中的内容复制到dest中  ArrayList dest = new ArrayList(); for (int i = 0; i \u0026lt; list.size(); i++) { dest.add(\u0026#34;\u0026#34;); } Collections.copy(dest,list); System.out.println(\u0026#34;dest = \u0026#34;+ dest); // 7. boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值  Collections.replaceAll(list,\u0026#34;tom\u0026#34;,\u0026#34;汤姆\u0026#34;); System.out.println(\u0026#34;替换后\u0026#34;); System.out.println(\u0026#34;list = \u0026#34; + list); } } 运行结果：\n需要注意的是，使用copy时，dest数组的大小必须大于src数组，否则会报数组越界异常\nint srcSize = src.size(); if (srcSize \u0026gt; dest.size()){ throw new IndexOutOfBoundsException(\u0026#34;Source does not fit in dest\u0026#34;); }   本章练习题   试分析HashSet和TreeSet分别如何实现去重的\n  HashSet去重机制：HashSet是通过hashCode()+equals()方法实现去重的。底层先通过hashCode方法计算出key对应的hash值，然后通过hash值查找在table表上对应索引位置上是否已经存在值。如果该位置上不存在值，则直接把key添加进去。否则通过equals方法遍历比较新增的key与已存在的key是否相同，相同就把key加入到已存在的key的后面，否则不添加。equals方法可以自定义比较的内容。\n  TreeSet去重机制：如果你在定义TreeSet时传入了一个Comparator匿名内部类（比较器），就使用该比较器中定义的compare方法实现去重。如果返回是0，则说明添加元素相同，不添加。如果你没有传入一个Comparator匿名内部类，系统会通过你添加的对象实现的Comprareable接口的compareTo实现去重。\nelse { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //把k指向key对象的类型实现的Comparable接口  Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; //动态绑定compareTo方法  cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); }     分析下面代码运行会不会抛出异常，并从源码层面说明原因\nTreeSet treeSet = new TreeSet(); treeSet.add(new Person()); class Person{ } 会抛出ClassCastException异常\n因为在定义TreeSet时没有传进去一个Comparator匿名类，所以在执行add的时候，程序会进入下述代码中\nelse { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //把k指向key对象的类型实现的Comparable接口  Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; //动态绑定compareTo方法  cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } 又因为Person类并没有实现Comparable接口，所以运行到第6行代码处时会抛出ClassCastException异常。\n  已知：Person类按照id和name重写了hashCode与equals方法。下面代码会输出什么？\nExercises04测试类\npackage com.collections_; import java.util.HashSet; import java.util.Objects; public class Exercises04 { public static void main(String[] args) { Person p1 = new Person(1001,\u0026#34;AA\u0026#34;); Person p2 = new Person(1002,\u0026#34;BB\u0026#34;); HashSet set = new HashSet(); set.add(p1); set.add(p2); System.out.println(set); p1.name = \u0026#34;CC\u0026#34;; set.remove(p1); System.out.println(set); set.add(new Person(1001,\u0026#34;CC\u0026#34;)); System.out.println(set); set.add(new Person(1001,\u0026#34;AA\u0026#34;)); System.out.println(set); } } Person类\nclass Person{ public int id; public String name; public Person(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(id, name); } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 输出结果为\n为什么set.remove(p1);执行了却没有remove成功呢？\n因为在执行remove方法之前，我们把p1的name值改变了**p1.name = \u0026ldquo;CC\u0026rdquo;;**而且我们在Person类中重写了hashCode方法，所以我们把name值改变的同时导致p1对应的hash值也发生改变。而我们观看remove的源码可以知道\nfinal Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) 此处传进去的hash值为p1更改后hash值而辅助变量p却指向了table表中的p1，即hash值为table的hash值\nif ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) 因为两个hash值不同，所以在接下来的几个if判断中结果都为false\nfinal Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, index; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) { Node\u0026lt;K,V\u0026gt; node = null, e; K k; V v; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))//False  node = p; else if ((e = p.next) != null) {//False  if (p instanceof TreeNode) node = ((TreeNode\u0026lt;K,V\u0026gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } //False  if (node != null \u0026amp;\u0026amp; (!matchValue || (v = node.value) == value || (value != null \u0026amp;\u0026amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 所以最后只能return null；然后回到remove方法\npublic V remove(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } 因为removeNode方法return null，所以返回到remove也只能return null 即修改失败。\n而后面添加\nset.add(new Person(1001,\u0026#34;CC\u0026#34;)); set.add(new Person(1001,\u0026#34;AA\u0026#34;)); 可以成功，原理跟上述图示一样\n因为后面添加的Person(1001,\u0026ldquo;AA\u0026rdquo;)同上面一样是指向索引为3处（该处为null），所以添加成功\n而Person(1001,\u0026ldquo;AA\u0026rdquo;)添加成功是因为此时索引为1出的Person值的name已发生改变。且计算出来的Hash值与索引为1处对应。所以该Person添加到索引为1处的Person后面\n  ","date":"2021-04-16T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%9B/","title":"Java集合类（四）"},{"content":"JavaMethod   什么是方法 方法的定义及调用 方法重载 命令行传参 可变参数 递归   何谓方法   方法是语句的结合，他们在一起执行一个功能。\n 方法是解决一类问题的步骤的有序组合 方法包含于类中 方法在程序中被创建，在其地方被引用    设计方法时，最好保持方法的原子性，就是一个方法只完成一个功能，这样子利于我们后期的拓展。\n  命名规则：首字母小写的驼峰命名法\n  方法创建及使用\npackage com.heng.method; public class Demo01 { //main方法  public static void main(String[] args) { int sum = add(1,3); System.out.println(sum); } //add方法  public static int add(int a , int b){ return a+b; }   方法的定义及调用  方法的定义    方法包含一个方法头和一个方法体。以下是一个方法的所有部分\n  修饰符：定义了该方法的访问类型\n  返回值类型：方法会根据所需返回对应的值得类型，当无需返回值时，方法的类型是void\n  方法名：是方法的实际名称，方法名和参数表共同构成方法签名\n  参数类型：参数像是一个占位符。有实参与形参，也可以不包含参数\n 形参：在方法被调用时用于接收外界输入的数据 实参：调用方法是实际传给方法的数据  public class Demo01 { public static void main(String[] args) { //实际参数：实际调用传递给他的参数  int sum = add(1,3); System.out.println(sum); } //形式参数，用来定义作用的  public static int add(int a , int b){ return a+b; }   方法体：方法体包含具体的语句。定义了方法的功能\npublic static int add(int a,int b){ /* 修饰符:public static * 返回值类型:int * 方法名:add * 参数类型:int 参数名:a */ return a+b;//方法体  }     return除了放回值之外也可以终止方法。\n  方法的调用   调用方法：对象名.方法名（实参列表）  方法的重载   重载是在一个类中，有相同的函数名称，但形参不同的函数。\n  方法重载的规则\n 方法名必须相同。 参数类别必须不同（个数不同、类型不同、参数排列顺序不同等） 方法的返回类型可以相同也可以不同 仅仅返回类型不同不足以成为方法的重载    下面代码两个方法名都为max 但方法类型不同，所以两个方法重载\npackage com.heng.method; public class Demo02 { public static void main(String[] args) { //调用double类型的返回方法  double max = max(20,30); //根据需要的类型调用方法  System.out.println(max); } public static int max(int num1,int num2){ int result = 0; if(num1==num2){ System.out.println(\u0026#34;num1=num2\u0026#34;); return 0;//终止方法  } if(num1\u0026gt;num2){ result = num1; }else { result = num2; } return result; } public static double max(double num1,double num2){ double result = 0; if(num1==num2){ System.out.println(\u0026#34;num1=num2\u0026#34;); return 0;//终止方法  } if(num1\u0026gt;num2){ result = num1; }else { result = num2; } return result; } }   命令行传参   有时候你希望运行一个程序再传递给它消息，这要靠传递命令行参数给main()函数实现\npackage com.heng.method; public class Demo03 { public static void main(String[] args) { for (int i = 0; i \u0026lt; args.length; i++) { System.out.println(\u0026#34;args[\u0026#34;+i+\u0026#34;]:\u0026#34;+args[i]); } } } 上述代码需要先进入到命令行模式编译成.class文件\n编译完成后，生成了一个class文件\n最后在命令行模式下执行Demo03.class；同时向main()函数传参\n需要注意的是执行class文件需要返回到src目录下才能执行\n  可变参数   可变参数又可以叫做不定项参数（本质就是数组）\n  在方法声明中，在指定参数类型后加一个省略号(\u0026hellip;)即表示可变参数\n  一个方法中只能指定一个可变参数，他必须是方法的最后一个参数。任何普通的参数必须在它之前声明\n  代码演示：\npackage com.heng.method; public class Demo04 { public static void main(String[] args) { //新建一个对象  Demo04 demo04 = new Demo04(); //调用对象方法  demo04.printMax(34,3,2,4,1,5.5); demo04.printMax(new double[]{1,2,3}); } public void printMax(double... number){ if(number.length==0){ System.out.println(\u0026#34;没有参数\u0026#34;); return; } double result = number[0]; //排序  for (int i = 1; i \u0026lt; number.length; i++) { if(number[i]\u0026gt;result){ result = number[i]; } } System.out.println(\u0026#34;max=\u0026#34;+result); } }   递归   递归结构包括两部分：\n 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环 递归体：什么时候调用自身方法。    需要注意的是递归是把函数堆压在栈里面的，如果递归的次数太多，栈内存会不过，即系统会报错\n  递归代码演示：\npackage com.heng.method; public class Demo05 { public static void main(String[] args) { Demo05 demo05 = new Demo05(); int result = demo05.f(5); System.out.println(result); } public int f(int i){ if(i==1){ return 1; }else { return i*f(i-1); } } } 上述代码的执行过程\n  ","date":"2021-04-08T16:22:25+08:00","image":"https://minster77.github.io/cover03.jpg","permalink":"https://minster77.github.io/p/javamethod/","title":"JavaMethod"},{"content":"Java集合类(三)   Map接口实现类的特点和常用方法 Map接口的六大遍历方式 Map小结及HashMap底层源码分析 Hashtable基本介绍   Map接口实现类的特点和常用方法 Map接口的特点 注意：这里讲的是Jdk8的Map接口特点\n  Map与Collection并列存在。用于保存具有映射关系的数据：key-value\n  Map中的key和value可以是任何引用类型的数据，会封装到HashMao$Node对象中\n  Map中的key不允许重复，原因和HashSet一样\n  Map中的value可以重复\n  Map的key可以为null，value也可以为null，但是key为null的结点只能有一个，value为null的结点可以有多个\n  常用String类作为Map的key\n  key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n代码演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class Map_ { public static void main(String[] args) { Map map = new HashMap(); //key不可以重复，重复的会被等价替换  //value可以重复  map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  map.put(\u0026#34;no1\u0026#34;,\u0026#34;张三丰\u0026#34;);//当有相同的key，就等于等价替换  map.put(\u0026#34;no3\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  //key只能有一个null  map.put(null,null); map.put(null,\u0026#34;abc\u0026#34;);//等价替换  //value可以多个为null  map.put(\u0026#34;no4\u0026#34;,null); map.put(\u0026#34;no5\u0026#34;,null);//value可以多个为null  map.put(1,\u0026#34;赵敏\u0026#34;); //通过get方法，传入key，会返回对应的value  System.out.println(map.get(\u0026#34;no3\u0026#34;)); System.out.println(\u0026#34;map = \u0026#34; + map); } }   Map接口k-v详解\n  Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的。因为Node实现了Entry接口，所以有些书上也说一对k-v就是一个Entry。\n  k-v 数据最后是存放在HashMap$Node node = newNode(hash,key,value,null) 这个对象里面的。\n  k-v 为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry。而一个Entry对象本身就具有key，value值。所以有EntrySet\u0026lt;Entry\u0026lt;K,V\u0026raquo;，即\ntransient Set\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; entrySet;   EntrySet中，定义的类型是Map.Entry，但是实际上存放的还是HashMap$Node。原因如下\nstatic class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt;   由于Map.Entry提供了两个重要的方法：K getKey(); V getValue() ，所以当我们把HashMap$Node对象存放到EntrySet就可以方便我们的遍历。\n程序演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; import java.util.Set; public class MapSource { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  Set set = map.entrySet(); for (Object obj:set) { //向下转型  Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey() + \u0026#34;-\u0026#34; + entry.getValue()); } System.out.println(\u0026#34;Map = \u0026#34; + map); } } 输出结果：\nkeySet()：与Node封装到EntrySet集合一样，不过他是封装到Set集合，利用该方法可以单独遍历Key值\nvalues：与Node封装到EntrySet集合一样，不过他是封装到Collection集合，利用该方法可以单独遍历Value值\nSet set1 = map.keySet(); System.out.println(set1); Collection values = map.values(); System.out.println(values); 运行结果\n  Map接口的常用方法   put()：添加元素\n  remove()：根据键删除映射关系\n  get()：根据键获取值\n  size()：获取元素的个数\n  isEmpty()：判断元素个数是否为0\n  clear()：清除集合键值对\n  containsKey()：查找键是否存在\n代码演示\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class MapMethod { public static void main(String[] args) { Map map = new HashMap(); // 1. put()：添加元素  map.put(\u0026#34;no1\u0026#34;,new Book(\u0026#34;小王子\u0026#34;,100)); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;); map.put(\u0026#34;no2\u0026#34;,\u0026#34;史森明\u0026#34;); map.put(\u0026#34;no3\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(\u0026#34;no4\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(null,\u0026#34;小虎\u0026#34;); map.put(\u0026#34;no5\u0026#34;,null); System.out.println(\u0026#34;map = \u0026#34; + map); // 2. remove()：根据键删除映射关系  map.remove(\u0026#34;no3\u0026#34;); System.out.println(\u0026#34;map = \u0026#34; + map); // 3. get()：根据键获取值  System.out.println(map.get(\u0026#34;no1\u0026#34;)); // 4. size()：获取元素的个数  System.out.println(map.size()); // 5. isEmpty()：判断元素个数是否为0  System.out.println(map.isEmpty()); // 6. clear()：清除集合键值对  map.clear(); System.out.println(map.isEmpty()); System.out.println(map.size()); // 7. containsKey()：查找键是否存在  map.put(\u0026#34;no1\u0026#34;,new Book(\u0026#34;小王子\u0026#34;,100)); System.out.println(map.containsKey(\u0026#34;no1\u0026#34;)); System.out.println(map.containsKey(\u0026#34;no5\u0026#34;)); } } class Book{ private String name; private double price; public Book(String name, double price) { this.name = name; this.price = price; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } }   Map接口的六大遍历方式   遍历以下Map接口的元素\nimport java.util.Set; public class MapFor { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;); map.put(\u0026#34;no2\u0026#34;,\u0026#34;史森明\u0026#34;); map.put(\u0026#34;no3\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(\u0026#34;no4\u0026#34;,\u0026#34;李元浩\u0026#34;); map.put(null,\u0026#34;小虎\u0026#34;); map.put(\u0026#34;no5\u0026#34;,null); } }     使用keySet()+增强for遍历k-v\nSystem.out.println(\u0026#34;=====第一种遍历方式=====\u0026#34;); Set keySet = map.keySet(); for (Object key : keySet) { System.out.println(key+\u0026#34;=\u0026#34;+map.get(key)); } 运行结果\n  使用keySet()+迭代器遍历k-v\nSystem.out.println(\u0026#34;=====第二种遍历方式=====\u0026#34;); Iterator iterator = keySet.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(next+\u0026#34;=\u0026#34;+map.get(next)); } 运行结果\n  使用values()+增强for遍历value（因为value不能映射key，所以只能遍历value）\nSystem.out.println(\u0026#34;=====第三种遍历方式=====\u0026#34;); Collection values = map.values(); for (Object value : values) { System.out.println(value); } 运行结果\n  使用values()+迭代器遍历\nSystem.out.println(\u0026#34;=====第四种遍历方式=====\u0026#34;); Iterator iterator1 = values.iterator(); while (iterator1.hasNext()) { Object next = iterator1.next(); System.out.println(next); } 运行结果\n  使用EntrySet()+增强for遍历\nSystem.out.println(\u0026#34;=====第五种遍历方式=====\u0026#34;); Set entrySet = map.entrySet(); for (Object obj : entrySet) { //将obj转成Map.Entry  Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey()+\u0026#34;-\u0026#34;+entry.getValue()); } 运行结果\n  使用EntrySet()+迭代器遍历\nSystem.out.println(\u0026#34;=====第六种遍历方式=====\u0026#34;); Iterator iterator2 = entrySet.iterator(); while (iterator2.hasNext()) { Object next = iterator2.next(); Map.Entry entry = (Map.Entry)next; System.out.println(entry.getKey()+\u0026#34;-\u0026#34;+entry.getValue()); } 运行结果\n  HashMap练习题   使用HashMap添加三个元素对象，要求：\n 键：员工ID，值：员工对象 遍历显示工资\u0026gt;18000的员工（遍历方法两种） 员工类：姓名、工资、员工id  员工类Staff代码如下\nclass Staff{ private String name; private double wages; private int id; public Staff(String name, double wages, int id) { this.name = name; this.wages = wages; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getWages() { return wages; } public void setWages(double wages) { this.wages = wages; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \u0026#34;Staff{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, wages=\u0026#34; + wages + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } } 测试类MapExercise代码如下\npackage com.conllection_.maps; import java.util.*; public class MapExercise { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;01\u0026#34;,new Staff(\u0026#34;成志恒\u0026#34;,19000,01)); map.put(\u0026#34;02\u0026#34;,new Staff(\u0026#34;史森明\u0026#34;,20000,02)); map.put(\u0026#34;03\u0026#34;,new Staff(\u0026#34;小虎\u0026#34;,17000,03)); map.put(\u0026#34;04\u0026#34;,new Staff(\u0026#34;李元浩\u0026#34;,18000,04)); System.out.println(\u0026#34;===第一种方式===\u0026#34;); //使用entrySet方法返回映射中包含的映射的 Set 视图  Set entrySet = map.entrySet(); //利用增强for循环遍历  for (Object o : entrySet) { //向下转型，为了能调用父类的方法  Map.Entry entry = (Map.Entry)o; //把value对象指向从entry集中取出来的value  Object value = entry.getValue(); //向下转型，这样可以使用Staff对象的getWages方法。  Staff staff = (Staff) value; if(staff.getWages()\u0026gt;18000){ System.out.println(staff.toString()); } } System.out.println(\u0026#34;===第二种方式===\u0026#34;); //使用keySet()方法返回封装到Map封装到Set里面的结点的Key值  Set set = map.keySet(); //创建迭代器  Iterator iterator = set.iterator(); while (iterator.hasNext()) { //获取迭代器中的数据  Object next = iterator.next(); //向下转型，吧staff对象指向从map里面取到的value对象。  Staff staff1 = (Staff) map.get(next); if (staff1.getWages()\u0026gt;18000){ System.out.println(staff1); } } } } 运行结果：\n上述题目中，数据的封装情况如下图\n所以当我们需要取出value值时，我们需要先通过EntrySet取出Entry，然后通过Entry的指向取到HashSet$Node的值。\n  Map小结及HashMap底层源码分析 Map小结   Map接口的常用实现类：HashMap、Hashtable和Properties\n  HashMap是Map接口使用频率最高的实现类\n  HashMap是以key-value对的方式来存储数据的\n  key不能重复，但是value可以重复，允许使用null键（只能有一个）和null值（可以多个）\n  如果添加相同的可以，则会覆盖原来的key-value，等同于修改。（key不会替换，value会替换）\nif (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //此处e指向替换前的Node，所以 e.value = value;即可完成替换  e.value = value; afterNodeAccess(e); return oldValue; }   与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。\n  HashMap没有实现同步，因此线程是不安全的。方法没有做同步互斥的操作，没有synchronize\n  HashMap底层机制及源码剖析   HashMap底层机制示意图\n（key，value）是一个Node实现了Map$Entry\u0026lt;K,V\u0026gt;\n  HashMap的扩容机制[和HashSet扩容机制相同]\n HashMap底层维护了Node类型的数组table，默认为null 当创建对象时，将加载因子(loadfactor)初始化为0.75 当添加key-value是，通过key的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换value；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。 第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12 如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），否则任然采用数组扩容机制  源码分析\n创建MapSource类\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class MapSource { public static void main(String[] args) { Map map = new HashMap(); map.put(\u0026#34;no1\u0026#34;,\u0026#34;成志恒\u0026#34;);//k-v  map.put(\u0026#34;no2\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  map.put(\u0026#34;no1\u0026#34;,\u0026#34;张无忌\u0026#34;);//k-v  } } 调试程序，执行HashMap的无参构造器，=。\npublic HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 将负载因子(loadFactor)初始化并且创建一个空的table。\n向HashMap集合添加元素，执行put方法\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 通过hash方法计算key的Hash值，然后返回给putVal方法。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 执行putVal方法，程序首先判断table是否为null，如果为null就table的容量扩容到16\nif ((tab = table) == null || (n = tab.length) == 0){ n = (tab = resize()).length; } 实现扩容的方法为risize()方法。\n继续调试，程序会判断当前hash值对应的table索引位置上是否已经存在值，如果不存在值，就把当前Hash值的结点赋值进去。\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 然后modCount++（记录修改的次数），size++（记录已添加元素的个数）；\n倘若当前hash值对应的table索引位置上已存在值，首先会判断当前索引位置上的hash值是否与需要添加的key值对应的hash值相同且满足以下两个条件之一：\n 准备添加的key值与p指向的Node结点的key是同一个对象 p指向的Node结点的key的equals()和准备假如的key比较后相同。  如果上述条件皆成立，直接让e指向p（p为当前索引位置上的结点）,e为辅助变量\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ e = p; } 然后继续执行，把需要添加的key值对应的value值替换掉原先存在的key值的value值\nif (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 返回修改后的value值。\n倘若上述条件不成立，程序会继续进行判断，判断需要添加的结点是否为树结点\nelse if (p instanceof TreeNode){ e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); } 如果是树结点，会执行putTreeVal()方法，把需要添加的树节点添加到红黑树上。\n如果不是树节点，程序会继续调试，进入到下一个else。\nelse { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } 在此处程序会进入一个死循环，直至找到对应索引位置上的尾结点或者找到key相同的结点才会退出。详细见HashSet底层添加元素源码分析的最后一步。\n  模拟HashMap触发扩容、树化情况，并debug验证   创建测试类MapSource01\npackage com.conllection_.maps; import java.util.HashMap; import java.util.Map; import java.util.Objects; public class MapSource01 { public static void main(String[] args) { Map map = new HashMap(); for (int i=0; i\u0026lt;12;i++){ map.put(new A(i),\u0026#34;hello\u0026#34;); } System.out.println(map); } } 创建A类，重写HashCode方法，让他们有统一的Hash值\nclass A{ private int no; public A(int no) { this.no = no; } public int getNo() { return no; } @Override public int hashCode() { return 100; } public void setNo(int no) { this.no = no; } @Override public String toString() { return \u0026#34;\\nA{\u0026#34; + \u0026#34;no=\u0026#34; + no + \u0026#39;}\u0026#39;; } } 运行调试，直至添加到第9个元素，因为达到树化的条件（一条链表的元素个数到达8个），但table的大小\u0026lt;MIN_TREEIFY_CAPACITY(默认是64)，所以table会扩容。\n继续调试，table再次扩容，直至table扩容到容量为64时，该链表会发生树化\n  Hashtable Hashtable的基本介绍   Hashtable存放的元素时键值对：即K-V\n  Hashtable的键和值都不能为null，否则会抛出NullPointerException\nif (value == null) { throw new NullPointerException(); }   Hashtable使用方法基本上和HashMap一样\n  Hashtable是线程安全的（synchronize），HashMap是线程不安全的\n  Hashtable底层的简单剖析\n  底层有数组 Hashtable$Entry[]，初始化大小为11\n  临界值 threshold = 8 （11*0.75）\n创建HashtableSource类调试\npackage com.conllection_.maps;\rimport java.util.Hashtable;\rpublic class HashtableSource {\rpublic static void main(String[] args) {\rHashtable hashtable = new Hashtable();\rhashtable.put(\u0026quot;john\u0026quot;,100);\rhashtable.put(\u0026quot;jack\u0026quot;,100);\rhashtable.put(\u0026quot;mary\u0026quot;,200);\rhashtable.put(\u0026quot;tom\u0026quot;,300);\rhashtable.put(\u0026quot;smith\u0026quot;,500);\rhashtable.put(\u0026quot;minster\u0026quot;,600);\rhashtable.put(\u0026quot;chris\u0026quot;,200);\rhashtable.put(\u0026quot;ssm\u0026quot;,500);\rSystem.out.println(\u0026quot;hashtable = \u0026quot; + hashtable);\r}\r}\r调试程序，我们可以发现\n  Hashtable按照自己的扩容机制进行扩容\n继续调试HashtableSource，执行put方法，可以发现该接口添加元素时执行了addEntry方法把添加的K-V封装到Entry\nprivate void addEntry(int hash, K key, V value, int index) { modCount++; Entry\u0026lt;?,?\u0026gt; tab[] = table; //当增加的元素数量大于或等于临界值时，执行rehash方法进行扩容  if (count \u0026gt;= threshold) { // Rehash the table if the threshold is exceeded  rehash(); tab = table; hash = key.hashCode(); index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry.  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; e = (Entry\u0026lt;K,V\u0026gt;) tab[index]; tab[index] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); count++; } 执行rehash方法进行扩容。下面截取部分rehash源码。\nprotected void rehash() { int oldCapacity = table.length; Entry\u0026lt;?,?\u0026gt;[] oldMap = table; // overflow-conscious code  //进行扩容  int newCapacity = (oldCapacity \u0026lt;\u0026lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets  return; newCapacity = MAX_ARRAY_SIZE; } //指向扩容后的Entry  Entry\u0026lt;?,?\u0026gt;[] newMap = new Entry\u0026lt;?,?\u0026gt;[newCapacity]; } 我们可以发现，当容量达到临界值时，rehash方法会通过 **int newCapacity = (oldCapacity \u0026laquo; 1) + 1;**这条语句进行扩容。所以hashtable第一次扩容后的容量为23（11*2+1）；\n  HashMap与Hashtable对比 Properties   Properties类继承于Hashtable类并实现了Map接口，也是使用一种键值对的形式来保存数据\n  他的使用特点和Hashtable类似\n  Properties还可以用了从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改\n  xxx.properties文件通常作为配置文件，详解见Java读取properties配置文件\nProperties的简单使用\nProperties_类\npackage com.conllection_.maps; import java.util.Properties; public class Properties_ { public static void main(String[] args) { //Properties 继承了Hashtable  //Properties 也是通过k-v存储数据，当然key与value都不能为null  Properties properties = new Properties(); //添加元素  properties.put(\u0026#34;jack\u0026#34;,1); properties.put(\u0026#34;john\u0026#34;,2); properties.put(\u0026#34;tom\u0026#34;,\u0026#34;2\u0026#34;); System.out.println(\u0026#34;properties = \u0026#34;+properties); //删除元素  properties.remove(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;properties = \u0026#34;+properties); //修改元素  properties.put(\u0026#34;jack\u0026#34;,3);//替换  System.out.println(\u0026#34;properties = \u0026#34;+properties); //查找元素  System.out.println(properties.get(\u0026#34;jack\u0026#34;)); System.out.println(properties.getProperty(\u0026#34;tom\u0026#34;)); } } 运行结果\n需要注意的是，使用getPeoperties时，当put进去的值不是String类型的时候，会返回null\n例如在Properties类中添加以下代码\nproperties.put(\u0026#34;jack\u0026#34;,1); System.out.println(properties.getProperty(\u0026#34;jack\u0026#34;)); 阅读getProperty源码，我们可以发现其中原理\npublic String getProperty(String key) { //把oval指向key对应的value  Object oval = super.get(key); //使用三目运算符，当oval是String类型时，返回强转为String类型的oval，否则为null  String sval = (oval instanceof String) ? (String)oval : null; //当sval为null，且设定了defaults的值时，返回defaultsValue，否则返回sval  return ((sval == null) \u0026amp;\u0026amp; (defaults != null)) ? defaults.getProperty(key) : sval; }   ","date":"2021-04-08T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%89/","title":"Java集合类（三）"},{"content":"Java流程控制   用户交互Scanner 顺序结构 选择结构 循环结构 break\u0026amp;continue 练习   用户交互Scanner   通过Scanner类来获取用户的输入\n  基础语法：\nScanner s = new Scanner(System.in);   通过Scanner类的next()方法获取输入的字符串，需要使用hasNext()判断是否还有输入的数据\npackage com.heng.scanner; import java.util.Scanner; public class demo01 { public static void main(String[] args) { //创建一个扫描器对象，用于接收用户输入的数据  Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;用next方式接收：\u0026#34;); //判断用户有没有输入字符串  if(scanner.hasNext()){ //使用next的方式来接收  String str = scanner.next(); System.out.println(\u0026#34;输出的内容为：\u0026#34;+str); } //凡是属于IO流的类如果不关闭就会一直浪费资源。所以要用完就关闭  scanner.close(); } } 因为使用next方法接收，所以空格后面的字符不能被str接收，因此可以使用nextLine()方法操作\n  通过nextLine()方法获取输入的字符串，需要使用hasNextLine()判断是否还有输入的数据\npackage com.heng.scanner; import java.util.Scanner; public class demo02 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;用nextLine方式接收：\u0026#34;); //判断是否还有输入  if(scanner.hasNextLine()){ //通过nextLine()方法来接收  String str = scanner.nextLine(); System.out.println(\u0026#34;输出的内容为：\u0026#34;+str); } scanner.close(); } }   next()方法与nextLine()方法都能用来接收输入的内容，大多数情况使用后者\n  scanner的进阶用法\n  scanner类中有许多个方法来接收不同的数据\n例：利用scanner类中方法来接收数字并求出其和以及平均值\npackage com.heng.scanner; import java.util.Scanner; public class demo03 { public static void main(String[] args) { //输入多个数字，求出其总和以及平均数，每输入一个数字用回车确认，通过输入非数字来结算循环  Scanner scanner = new Scanner(System.in); //用于计算总和  double sum = 0; //用于统计输入的数据个数.  int m = 0; System.out.println(\u0026#34;请输入数据:\u0026#34;); //用while循环来判断是否还有输入，并且在里面累加求和  while (scanner.hasNextDouble()){ double x = scanner.nextDouble(); m=m+1; sum = sum + x; System.out.println(\u0026#34;你输入了第\u0026#34;+m+\u0026#34;个数，当前总和sum=\u0026#34;+sum); } System.out.println(m+\u0026#34;个数的和为:\u0026#34;+sum); System.out.println(m+\u0026#34;个数的平均值为:\u0026#34;+(sum/m)); scanner.close(); } }     顺序结构  Java的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行 顺序结构是最基本的算法结构 顺序结构是任何一个算法都离不开的一个结构  选择结构 3.1 if单选择结构     语法结构\npackage com.heng.struct; import java.util.Scanner; public class Demo01 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入内容：\u0026#34;); String s = scanner.nextLine(); //equals:判断字符串是否相等  if(s.equals(\u0026#34;Hello\u0026#34;)){ System.out.println(s); } System.out.println(\u0026#34;END\u0026#34;); } }   3.2 if双选择结构   !if(布尔表达式){ //如果布尔表达式为true }else{ //如果布尔表达式为false }   3.3 if多选择结构   语法结构\nif(布尔表达式1){ //如果布尔表达式1的值为true 执行 }else if(布尔表达式2){ //如果布尔表达式2的值为true 执行 }else if(布尔表达式3){ //如果布尔表达式3的值为true 执行 }else { //如果以上布尔表达式都不为true 执行 }   else语句必须在所有的else if语句后面\n  if嵌套结构\nif(布尔表达式1){ if(布尔表达式2){ //执行  } }   3.4 switch选择结构   语法结构\nswitch(expression){ case value: //语句  break; case value: //语句  break; //可以有任意数量个case语句  default ://可选 一般在最后  //语句  }   switch语句中变量可以使 byte、short、int、char在jdk7之后还支持String类型\n  但字符的本质还是数字\npackage com.heng.struct; public class SwitchDemo01 { public static void main(String[] args) { String name = \u0026#34;志恒\u0026#34;; switch (name){ case \u0026#34;小胖\u0026#34; : System.out.println(\u0026#34;小胖\u0026#34;); break; case \u0026#34;志恒\u0026#34; : System.out.println(\u0026#34;志恒\u0026#34;); break; case \u0026#34;松涛\u0026#34; : System.out.println(\u0026#34;松涛\u0026#34;); break; default: System.out.println(\u0026#34;查无此人\u0026#34;); } } }   反编译 Java\u0026mdash;\u0026mdash;\u0026gt;class文件\u0026mdash;\u0026mdash;\u0026gt;反编译（IDEA实现）\n  需要注意的是case具有穿透性 如果不加break或继续执行后面的case\npackage com.heng.struct; public class SwitchDemo02 { public static void main(String[] args) { char grade = \u0026#39;B\u0026#39;; switch (grade){ case \u0026#39;A\u0026#39;: System.out.println(\u0026#34;优秀\u0026#34;); break; case \u0026#39;B\u0026#39;: System.out.println(\u0026#34;良好\u0026#34;); case \u0026#39;C\u0026#39;: System.out.println(\u0026#34;及格\u0026#34;); case \u0026#39;D\u0026#39;: System.out.println(\u0026#34;不及格\u0026#34;); break; default: System.out.println(\u0026#34;未知等级\u0026#34;); } } }   循环结构 4.1 while循环   只要布尔表达式结果为true就会一直执行\n  用一个表达式失效的方式来结束循环\nwhile(布尔表达式){ //语句 }   4.2 do\u0026hellip;while循环   布尔表达式的值为false do\u0026hellip;while循环也会执行一次\n  do\u0026hellip;while循环至少会执行一次\ndo{ //语句 }while(布尔表达式);     while与do\u0026hellip;while的区别\n while先判断后执行；do\u0026hellip;while先执行后判断 do\u0026hellip;while总是保证循环体至少执行一次。  package com.heng.struct; public class WhileDemo01 { public static void main(String[] args) { int a= 0; while(a\u0026lt;0){ System.out.println(a); a++; } System.out.println(\u0026#34;====================\u0026#34;); do { System.out.println(a); a++; }while (a\u0026lt;0); } }   4.3 For循环   语法结构\nfor(初始化;布尔表达式;更新){ //代码语句 }   for循环数支持迭代的一种通用结构，是最有效的、最灵活的循环结构\n  用for循环打印九九乘法表\npackage com.heng.struct; public class ForDemo04 { public static void main(String[] args) { int sum = 0; for (int i = 1; i \u0026lt;= 9; i++) { for (int j = 1; j \u0026lt;= i; j++) { sum = i*j; System.out.print(j+\u0026#34;*\u0026#34;+i+\u0026#34;=\u0026#34;+sum+\u0026#34;\\t\u0026#34;); } System.out.println(); } } }   增强For循环\npackage com.heng.struct; public class ForDemo05 { public static void main(String[] args) { int [] number= {10,20,30,40,50}; //首先看基本的for循环遍历数组  for(int i=0;i\u0026lt;number.length;i++){ System.out.println(number[i]); } System.out.println(\u0026#34;===================\u0026#34;); //下面是增强型for循环遍历  for(int x:number){ System.out.println(x); } } }   break与continue 5.1 break   在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环不执行循环体的剩余语句\n  switch中的break可以避免case的穿透性\n  5.2 continue   continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定\n  java中可以使用标签（goto）\npackage com.heng.struct; public class LabelDemo { public static void main(String[] args) { //求101-150之间的质数  int count = 0; //outer为标签  outer:for (int i = 0; i \u0026lt; 101; i++) { for(int j = 2;j\u0026lt;(i/2);j++){ if(i %j==0){ continue outer;//continue直接跳出到最外面的循环  } } System.out.print(i+\u0026#34; \u0026#34;); } } }   练习   打印一个五行的三角形\npackage com.heng.struct; public class TestDemo01 { public static void main(String[] args) { //打印三角形  /* * 所打印的三角形就是用空格+“*”组成 * 所以一开始进入循环1 打印倒三角的空格 * 然后进入循环二，打印三角形的一半 * 最后进入循环三，将三角形补全 * */ for (int i = 1; i \u0026lt;= 5; i++) { for(int j=5;j\u0026gt;=i;j--){ System.out.print(\u0026#34; \u0026#34;);//循环1 打印倒三角的空格  } for (int j = 1; j \u0026lt;=i ; j++) { System.out.print(\u0026#34;*\u0026#34;);//循环2 打印了三角形的左半部分  } for (int j = 1; j \u0026lt;i ; j++) { System.out.print(\u0026#34;*\u0026#34;);//循环3 将三角形补全  } System.out.println(); } } }   ","date":"2021-04-06T16:22:25+08:00","image":"https://minster77.github.io/cover02.jpg","permalink":"https://minster77.github.io/p/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"Java流程控制"},{"content":"Java集合类(二)   Set接口和常用方法 HashSet全面说明  思考 HashSet底层解析 HashSet底层添加元素源码分析 HashSet扩容机制和转换红黑树机制源码解析 threshold补充说明   LinkedHashSet说明及源码分析  LinkedHashSet全面说明 LinkedHashSet底层机制示意图 LinkedHashSet底层源码分析     Set接口和常用方法   Set接口基本介绍\n 无序（添加和取出的顺序不一致），没有索引 不允许重复元素，所以最多包含一个null JDK API中Set接口常用的实现类有：HashSet、TreeSet等    Set接口的常用方法\n 和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。（详情见Java集合类(一)）    以Set接口的实现类HashSet来讲解Set接口的方法\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class SetMethod { public static void main(String[] args) { Set set = new HashSet(); set.add(\u0026#34;john\u0026#34;); set.add(\u0026#34;jack\u0026#34;); set.add(\u0026#34;tom\u0026#34;); set.add(\u0026#34;john\u0026#34;); set.add(null); set.add(null); System.out.println(\u0026#34;set = \u0026#34; + set); } } 运行结果：\n结论：\n set接口的实现类的对象（set接口对象），不能存放重复的元素，可以添加null set接口对象存放数据是无序（即添加的顺序和取出的顺序不一致） 取出的顺序虽然不是添加的属性，但是顺序是固定的！    Set接口的遍历方式\n同Collection的便利方式一样，因为Set接口是Collection接口的子接口。\n  使用迭代器\nSystem.out.println(\u0026#34;===迭代器遍历===\u0026#34;); Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(\u0026#34;set = \u0026#34;+next); }   增强for\nSystem.out.println(\u0026#34;增强for遍历\u0026#34;); for (Object o: set) { System.out.println(\u0026#34;set = \u0026#34;+o); }   不能使用索引的方式来获取\n    HashSet全面说明   HashSet实现了Set接口\n  HashSet实际上是HashMap\npublic HashSet() { map = new HashMap\u0026lt;\u0026gt;(); }   可以存放null值，但是只能有一个\n  HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序与取出顺序一致）\n  不能有重复元素或对象\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class HashSet01 { public static void main(String[] args) { Set hashSet = new HashSet(); /*说明 * 1. 在执行add方法后，会返回一个Boolean值 * 2. 如果添加成功，返回true，否则返回false * 3. 可以通过remove指定删除哪个对象 * */ System.out.println(hashSet.add(\u0026#34;mary\u0026#34;));//T  System.out.println(hashSet.add(\u0026#34;mary\u0026#34;));//F  hashSet.add(\u0026#34;jack\u0026#34;);//可以添加  hashSet.add(\u0026#34;jack\u0026#34;);//添加失败  //由于下面每一次add都新建了一个Dog对象  //所以下面两个Dog对象都会添加成功  hashSet.add(new Dog(\u0026#34;tom\u0026#34;)); hashSet.add(new Dog(\u0026#34;tom\u0026#34;)); System.out.println(\u0026#34;HashSet = \u0026#34;+ hashSet); hashSet.remove(\u0026#34;mary\u0026#34;);//删除mary  System.out.println(\u0026#34;HashSet = \u0026#34;+ hashSet); } }   思考   下面两个String对象都会被添加到HashSet集合里面去吗？\nhashSet.add(new String(\u0026#34;czh\u0026#34;)); hashSet.add(new String(\u0026#34;czh\u0026#34;)); 运行的结果是仅有一个数据被添加，为什么呢？\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) 因为此时String类型重写的equals()方法是比较其字符串内容是否相同，所以此时添加的两个“czh”数据只有一个能被添加进去。\n而上述Dog对象的添加原理也是类似。\n下面我们通过解读HashSet的底层结构解决这个问题！\n  HashSet底层解析   因为HashSet的底层是HashMap，所以分析HashMap底层是（数组+链表+红黑树）即可\n为了更好理解HashMap的底层，下面模拟一个简单的数组+链表结构\n创建Node结点\n//结点Node，item存储数据，next指向下一个结点，可以形成链表 class Node{ Object item; Node next; public Node(Object item, Node next) { this.item = item; this.next = next; } } 创建HashSetStructure类\npackage com.conllection_.sets; public class HashSetStructure { public static void main(String[] args) { //1. 创建一个类型为Node的数组  Node[] nodes = new Node[16]; //2. 创建结点  Node john = new Node(\u0026#34;john\u0026#34;, null); nodes[2] = john; Node jack = new Node(\u0026#34;jack\u0026#34;, null); john.next = jack; Node mary = new Node(\u0026#34;mary\u0026#34;, null); jack.next = mary; Node lucy = new Node(\u0026#34;lucy\u0026#34;, null); nodes[3] = lucy; System.out.println(\u0026#34;node = \u0026#34;+nodes); } } 运行结果：\n  HashSet底层添加元素源码分析   分析HashSet添加元素的底层是如何实现的（hash()+equals()）\n HashSet底层就是HashMap 添加一个元素时，先通过hash()得到hash值，然后转换成索引值 找到存储数据表table，看这个索引位置是否已经存放了元素  如果没有，直接添加 如果有元素，调用equals比较，如果元素内容相同，就放弃添加，如果不相同，则添加到最后   在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。 当元素个数到达TREEIFY_THRESHOLD但table的大小小于MIN_TREEIFY_CAPACITY(默认64)时，系统会把table表填扩容到64，然后进行树化。    HashSet添加元素的源码解读\n创建HashSetSource类，用于debug\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class HashSetSource { public static void main(String[] args) { HashSet hashSet = new HashSet(); hashSet.add(\u0026#34;jack\u0026#34;); hashSet.add(\u0026#34;tom\u0026#34;); hashSet.add(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;set = \u0026#34; + hashSet); } }   执行构造器\npublic HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } 可以清晰地知道HashSet的底层就是HashMap\n  执行add()方法\npublic boolean add(E e) {//e=\u0026#34;jack\u0026#34;  return map.put(e, PRESENT)==null; } PRESENT是hashSet为了能使用hashMap而定义的一个常量（定值），无论添加了多少的元素它都不会变化\nprivate static final Object PRESENT = new Object();   执行put()方法\npublic V put(K key, V value) {//key = \u0026#34;jack\u0026#34;  return putVal(hash(key), key, value, false, true); } value为PRESENT,是共享的。\n  执行hash方法，计算key的hash值\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 如果key != null，程序会执行Object类中的hashCode()方法来获取key的值，并将它进行无符号右移16位（为了防止key的hashCode值发生冲突），最后得到的h为key对应的hash值。\nhash值并不是hashCode，因为(h = key.hashCode()) ^ (h \u0026raquo;\u0026gt; 16)\n  获取到hash值后，执行putVal方法（重要！）\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;//定义了辅助变量  if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 在此方法中，因为辅助变量tab的初始值为null，所以进入到resize()方法，给tab表赋予初始大小。\nif ((tab = table) == null || (n = tab.length) == 0){ n = (tab = resize()).length; } 上述代码中的table为hashMap的一个属性，类型为Node[]\n因为初始的table为null，所以执行resize()方法\n//下面代码为resize()方法的一些初始赋值 Node\u0026lt;K,V\u0026gt;[] oldTab = table;//结点oleTab表示原先的表 //oldCap表示初始表的容量大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldThr为当前表的一个临界值，当达到临界值时会扩容 int oldThr = threshold; int newCap, newThr = 0; 因为初始的table为null，所以oldCap为0，所以进入到下述语句\nelse { // zero initial threshold signifies using defaults  newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } DEFAULT_INITIAL_CAPACITY为hashMap定义的常量，大小为16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 所以newCap= 16，即第一次扩容大小为16\nnewThr为表的一个临界值，是使用负载因子DEFAULT_LOAD_FACTOR乘以初始大小等到的一个值。\n 默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\n 使用newThr是为了减少冲突，增加一个缓冲区，避免在多线程向表中增加数据时，表的内存不够而导致死锁。\n初始化tap的大小之后，会判断**(p = tab[i = (n - 1) \u0026amp; hash])**是否为null，(n - 1) \u0026amp; hash是位运算，详解见HashMap数学原理。计算出来的i为该key值在table表中的索引位置。\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 如果p=null，表示还没有存放元素，执行**tab[i] = newNode(hash, key, value, null);**创建一个Node（key=“jack\u0026quot;,value=PRESENT）把hash也放进Node是为了下次添加元素时比较。\n执行完毕，此时我们可以发现此时table表中已经在刚刚计算出来的索引值上添加了“jack”。\n到此为止，HashMap的第一次添加元素分析完毕。\n当我们向HashMap集合表再次添加数据时，系统会计算其hash值，然后通过\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 方法判断该hash值对应的索引位置上是否已经存在值，如果不存在，即把新增的key添加到表中的该索引位置上。\n此时可以发现，table表上多了一个数据\n如果该hash值对应的索引位置上已经存在值，程序会跳到下面语句\n//p为当前索引位置上对应的链表的第一个元素，即已经添加的值 //所以p.hash为已存在值得hash值，p.key为已存在值得key值 if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))){ e = p; } 如果当前索引位置上对应的链表的第一个元素的hash值与需要添加的key的hash值一样\n且满足以下两个条件之一：\n 准备添加的key值与p指向的Node结点的key是同一个对象 p指向的Node结点的key的equals()和准备假如的key比较后相同。  需要注意的是，此时equals()方法不能理解为只比较字符串内容是否相同，因为每一个类都会有其对应的equals()方法，所以equals()方法的比较内容可以由程序员所重写的方法来决定！\n此时说明新增加的key值已存在，所以该key值不会被添加到table中。\n若不满足上述条件，程序会继续往下走，执行下面语句。\nelse if (p instanceof TreeNode){ e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); } 上述语句会判断p是否为红黑树，如果是红黑树，就调用putTreeVal进行添加。\n如果p不是红黑树，执行以下代码\nelse { for (int binCount = 0; ; ++binCount) { //这是条件1  if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } //这是条件2  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } 因为在可以执行上述代码时，说明此时table表中是使用链表的方式来存储数据 。\n此时进入一个死循环，退出的条件：\n  条件1：在要加入的位置i = (n - 1) \u0026amp; hash处所形成的链表没有一个结点与要加入的结点相同时，退出循环，此时就加在最末尾。添加成功\n  条件2 :在要加入的位置i = (n - 1) \u0026amp; hash处所形成的链表有结点与要加入的结点相同，此时退出循环，添加失败\n  两个条件结合起来使用\n需要注意的是当我们把元素添加到聊表后，会进行以下判断\nif (binCount \u0026gt;= TREEIFY_THRESHOLD - 1){ // -1 for 1st \ttreeifyBin(tab, hash); } 判断链表是否已经达到8个结点（TREEIFY_THRESHOLD=8）。如果到达，则调用treeifyBin(tab, hash)方法对当前链表进行树化（转换成红黑树）。\n注意，在转换成红黑树时，treeifyBin(tab, hash)方法会进行判断\nif (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY){ resize(); } 判断table表大小是否\u0026lt;64，如果小于64，会先将table表进行扩容，再进行树化。\n    HashSet扩容机制和转换红黑树机制源码解析   HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）=16*负载因子（loadFactor）0.75 = 12\n  如果数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是 32 * 0.75 = 24，依次类推\n  在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小\u0026gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），否则任然采用数组扩容机制\n创建测试类HashSetIncrement.java\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Objects; public class HashSetIncrement { public static void main(String[] args) { HashSet hashSet = new HashSet(); for (int i = 1; i \u0026lt;=12; i++) { hashSet.add(new A(i)); } System.out.println(\u0026#34;hashSet = \u0026#34;+ hashSet); } } Class A\nclass A { private int n ; public A(int n) { this.n = n; } @Override public int hashCode() { return 100; } } 在HashSetIncrement类中的for循环处加一个断点，debug。可以发现，当i=9时，即满足一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，此时触发转换红黑树机制。\n但是此时不满足table表大小\u0026gt;=64\nif (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY){ resize(); } 所以此时table表会进行扩容。\n继续执行，可以发现table再次扩容。\n再继续执行，可以发现此时链表已经发生树化（转换成红黑树）\n树化过程的源码\nelse if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } 详细解释见Jdk1.8集合框架之HashMap源码解析\n  threshold补充说明   在putVal方法中，有这么一行代码\n++modCount; if (++size \u0026gt; threshold){ resize(); } afterNodeInsertion(evict); modCount代表我们对table表修改的次数。\n其中size是每当我们加入一个结点Node(key,value,hash,next)，size++。\n所以当我们想table表中加入指定数量的Node结点是，也会触发扩容机制。\n代码演示HashSetIncrement类\npackage com.conllection_.sets; import java.util.HashSet; import java.util.Objects; public class HashSetIncrement { public static void main(String[] args) { HashSet hashSet = new HashSet(); for (int i = 1; i \u0026lt;=7; i++) { hashSet.add(new A(i)); } for (int i = 1; i \u0026lt;=7; i++) { hashSet.add(new B(i)); } System.out.println(\u0026#34;hashSet = \u0026#34;+ hashSet); } } Class A 与 Class B\nclass B { private int n ; public B(int n) { this.n = n; } @Override public int hashCode() { return 200; } } class A { private int n ; public A(int n) { this.n = n; } @Override public int hashCode() { return 100; } } 运行调试，可以发现，虽然我们在一条链表上增加了7个元素，然后第二条链表增加到第五个元素时size=12，也触发了扩容机制\n所以触发扩容机制的前提是累积添加元素到达threshold。\n  ​\nLinkedHashSet说明及源码分析 LinkedHashSet全面说明  LinkedHashSet是HashSet的子类。 LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表。 LinkedHashSet根据元素的HashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是一插入顺序保存的。 LinkedHashSet不允许添加重复元素。  LinkedHashSet底层机制示意图   示意图\n  双向链表具体机制与LinkedList底层结构类似。\n  LinkedHashSet底层源码分析 说明\n  在LInkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n  每个节点有before和after属性，这样可以形成双向链表\n  在添加一个元素时，先求hash值，再求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加；原则跟hashset一样）\n  所以，我们遍历LinkedHash可以确定插入顺序和取出顺序一致\n创建LinkedHashSetSource类，用于分析源码\npackage com.conllection_.sets; import java.util.LinkedHashSet; import java.util.Set; public class LinkedHashSetSource { public static void main(String[] args) { Set set = new LinkedHashSet(); set.add(new String(\u0026#34;AA\u0026#34;)); set.add(456); set.add(456); set.add(123); set.add(\u0026#34;czh\u0026#34;); System.out.println(\u0026#34;LinkedHashSet = \u0026#34; + set); } } 可以知道，添加第一次时，系统会将数组table扩容到16，存放的结点类型是LinkedHashMap$Entry\n为什么数组时HashMap$Node[]类型，而存放的元素/数据却是LinkedHashMap$​​​​Entry呢？\n下面我们查看LinkedHashMap底层源码来解决这个问题。\nstatic class Entry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { Entry\u0026lt;K,V\u0026gt; before, after; Entry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } } 我们可以发现上面这个在LinkedHashMap源码中的静态内部类Entry继承了HashMap.Node。即数组的多态。双向链表实现的关键也是在这里。\n继续往下调试\n此时的map与hashSet的不一样，多了几个属性。其中head表示双向链表中的头结点，tail表示尾结点。\n而每一个结点又有before与after属性，指向上一个结点与下一个结点。\n所以LinkedHashSet可以实现按顺序插入及取出。\n进入add()方法\npublic boolean add(E e) { return map.put(e, PRESENT)==null; } 可以知道LinkedHashSet添加元素底层就是HashSet添加元素的底层（因为LinkedHashSet是HashSet的实现子类）\n  ","date":"2021-04-06T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/","title":"Java集合类（二）"},{"content":"Java集合类（一）    集合的概念\n  Collection接口和常用方法\n  List接口和常用方法\n  ArrayList底层源码即注意事项\n  Vector底层结构和源码解析\n  LinkedList底层结构和源码解析\n   集合的概念   由于前面保存多个数据使用的是数组，而数组保存数据会有一些不足的地方。\n 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型的元素 使用数组进行增加元素/删除会比较麻烦    若使用集合来处理数据的话，这类问题将会减少。集合的好处如下：\n 可以动态保存任意多个对象，使用比较方便！ 提供了一系列方便操作对象的方法：add、remove、set、get等 使用集合添加、删除新元素的代码更加简洁了    集合的框架体系\nCollection接口实现子类：\nMap接口实现子类：\n  集合主要有两种（单列集合，双列集合）\n  Collection接口有两个重要的子接口List、Set，他们的实现子类都是单列集合\nArrayList arrayList = new ArrayList(); arrayList.add(\u0026#34;jack\u0026#34;); arrayList.add(\u0026#34;tom\u0026#34;);   Map接口的实现子类是双列集合，即以K-V形式存放数据的\nHashMap hashMap = new HashMap(); hashMap.put(\u0026#34;No1\u0026#34;,\u0026#34;jack\u0026#34;); hashMap.put(\u0026#34;No2\u0026#34;,\u0026#34;tom\u0026#34;);     Collection接口和常用方法   Collection接口的特征\n  Collection实现子类可以存放多个元素，每个元素可以是Object\n  有些Collection的实现类，可以存放重复的元素，有些不可以\n  Collection实现类有些是有序的（List），有些不是有序的（Set）\n  Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的\n    Collection接口的常用方法\n add：添加单个元素 remove：删除指定元素 contains：查找元素是否存在 size：获取元素个数 isEmpty：判断是否为空 clear：清空 addAll：增加多个元素 containsAll：查找多个元素是否都存在 removeAll：删除多个元素  以Collection的实现子类演示上述方法\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class Collecyion_ { @SuppressWarnings({\u0026#34;all\u0026#34;}) public static void main(String[] args) { List List = new ArrayList(); //add：添加单个元素  List.add(10); List.add(\u0026#34;java\u0026#34;); List.add(true); System.out.println(\u0026#34;List=\u0026#34;+List); //remove：删除指定元素  List.remove(true); System.out.println(\u0026#34;List=\u0026#34;+List); //contains：查找元素是否存在  System.out.println(List.contains(10)); //size：获取元素个数  System.out.println(List.size()); //isEmpty：判断是否为空  System.out.println(List.isEmpty()); //clear：清空  List.clear(); System.out.println(\u0026#34;List=\u0026#34;+List); //addAll:增加多个元素  List List2 = new ArrayList(); List2.add(\u0026#34;红楼梦\u0026#34;); List2.add(\u0026#34;三国演义\u0026#34;); List2.add(\u0026#34;水浒传\u0026#34;); List.addAll(List2); System.out.println(\u0026#34;List=\u0026#34;+List); //containsAll：查找多个元素是否都存在  System.out.println(List.containsAll(List2)); //removeAll：删除多个元素  List.removeAll(List2); System.out.println(\u0026#34;List=\u0026#34;+List); } }   Collection接口使用Iterator(迭代器)遍历元素\n Iterator对象称为迭代器，主要用于遍历Collection集合中的元素 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器 Iterator仅用于遍历集合，Iterator本身并不存放对象 hasNext()：判断是否还有下一个元素 next()：将下移以后集合位置上的元素返回  代码演示：\nCollection_Book类\npackage com.conllection_; public class Collection_Book { private String name; private String author; private double price; public Collection_Book(String name, String author, double price) { this.name = name; this.author = author; this.price = price; } @Override public String toString() { return \u0026#34;Collection_Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, author=\u0026#39;\u0026#34; + author + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } Collection_Iterator类\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import com.conllection_.Collection_Book; public class Collection_Iterator { public static void main(String[] args) { Collection col =new ArrayList(); col.add(new Collection_Book(\u0026#34;三国演义\u0026#34;,\u0026#34;罗贯中\u0026#34;,10.1)); col.add(new Collection_Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,15.1)); col.add(new Collection_Book(\u0026#34;小李飞刀\u0026#34;,\u0026#34;古龙\u0026#34;,8.1)); //创建col对应的迭代器  Iterator iterator = col.iterator(); //使用while遍历循环  while (iterator.hasNext()){ //因为迭代器取到的数据可以是任意类型的，所以用Object  Object obj= iterator.next(); System.out.println(obj); } } } 运行结果\n hasNext()的返回值为Boolean，\nnext()的返回值可以为任意类型\n 注意：当退出while循环后，这是iterator迭代器指向最后一个元素，此时再使用iterator.next()系统会报错。\n如果要再次遍历，我们需要重置迭代器：\niterator = col.iterator();//重置迭代器   在IDEA中可以使用itit快捷生成\nwhile (iterator.hasNext()){ Object obj= iterator.next(); System.out.println(obj); }   ctrl+j可以看到所有快捷键\n  Collection接口使用增强for循环来遍历元素\n 增强for就是简化版的iterator，本质一样，只能用于遍历集合或素组  基本语法\nfor(Object object : col){ System.out.println(object); } 代码演示\nCollection_For类\npackage com.conllection_; import java.util.ArrayList; import java.util.Collection; public class Collection_For { public static void main(String[] args) { Collection col =new ArrayList(); col.add(new Collection_Book(\u0026#34;三国演义\u0026#34;,\u0026#34;罗贯中\u0026#34;,10.1)); col.add(new Collection_Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,15.1)); col.add(new Collection_Book(\u0026#34;小李飞刀\u0026#34;,\u0026#34;古龙\u0026#34;,8.1)); for(Object object : col){ System.out.println(object); } } } 运行结果与使用迭代器的一致。\n我们在**for(Object object : col)**这行代码加一个断点，通过Debug，可以发现增强for会依次调用迭代器的底层方法！\npublic Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } public boolean hasNext() { return cursor != size; } public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 所以，我们可以得知，增强for的底层仍然是迭代器！\n  List接口和常用方法 List接口是Collection接口的子接口\n  List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复\n  List集合中的每个元素都有其对应的顺序索引，即支持索引\n  List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n  List接口常用的实现类有:ArrayList、LinkedList、Vector\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class List_ { public static void main(String[] args) { List list = new ArrayList(); //1. List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复  list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;mary\u0026#34;); list.add(\u0026#34;heng\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;list=\u0026#34;+list); //2. List集合中的每个元素都有其对应的顺序索引，即支持索引  // 索引从0开始  System.out.println(list.get(3)); } }   List接口的常用方法\n  void add(int index,Object ele)：在index位置插入ele元素。\n  bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。\n  Object get(int index)：获取指定index位置的元素。\n  int indexOf(Object obj)：返回obj在集合中首次出现的位置。\n  int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。\n  Object remove(int index)：移除指定index位置的元素，并返回此元素。\n  Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。\n  List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。\n代码演示：\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class ListMethod { public static void main(String[] args) { List list1 = new ArrayList\u0026lt;\u0026gt;(); list1.add(\u0026#34;tom\u0026#34;); list1.add(\u0026#34;cat\u0026#34;); list1.add(\u0026#34;jack\u0026#34;); list1.add(\u0026#34;mary\u0026#34;); list1.add(\u0026#34;tom\u0026#34;); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 1. void add(int index,Object ele)：在index位置插入ele元素。  list1.add(2,\u0026#34;nancy\u0026#34;); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 2. bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。  List list2 = new ArrayList(); list2.add(\u0026#34;heng\u0026#34;); list2.add(\u0026#34;minster\u0026#34;); System.out.println(\u0026#34;list2 = \u0026#34;+list2); list1.addAll(3,list2); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 3. Object get(int index)：获取指定index位置的元素。  System.out.println(list1.get(3)); // 4. int indexOf(Object obj)：返回obj在集合中首次出现的位置。  System.out.println(list1.indexOf(\u0026#34;tom\u0026#34;)); // 5. int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。  System.out.println(list1.lastIndexOf(\u0026#34;tom\u0026#34;)); // 6. Object remove(int index)：移除指定index位置的元素，并返回此元素。  System.out.println(list1.remove(0)); System.out.println(\u0026#34;list1 = \u0026#34;+list1); // 7. Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。  //index必须是存在的下标，越界会报错！  //返回被替换的值  System.out.println(list1.set(3,\u0026#34;rui\u0026#34;)); System.out.println(\u0026#34;list1 = \u0026#34;+ list1); // 8. List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。  //返回的子集合为前闭后开区间！ forIndex \u0026lt;= subList \u0026lt; toIndexE  System.out.println(list1.subList(2,4)); } }     List的三种遍历方式\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ListFor { public static void main(String[] args) { List list = new ArrayList(); list.add(\u0026#34;jack\u0026#34;); list.add(\u0026#34;tom\u0026#34;); list.add(\u0026#34;成志恒\u0026#34;); list.add(1); System.out.println(\u0026#34;====迭代器遍历====\u0026#34;); // 1.迭代器遍历  Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(\u0026#34;obj = \u0026#34;+obj); } System.out.println(\u0026#34;====增强for遍历====\u0026#34;); // 2.增强For  for (Object o : list){ System.out.println(\u0026#34;obj = \u0026#34;+o); } System.out.println(\u0026#34;====普通For遍历====\u0026#34;); // 3.普通For  for (int i =0; i\u0026lt; list.size();i++){ System.out.println(\u0026#34;obj = \u0026#34;+list.get(i)); } } } List的其他实现子类（LinkedList、Vector）也可以使用上述三种方式进行遍历\n  练习：Book类：\npackage com.conllection_.lists; public class Book { private String name; private double price; private String author; public Book(String name, String author,double price) { this.name = name; this.author = author; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } @Override public String toString() { return \u0026#34;名称：\u0026#34;+name+\u0026#34;\\t\\t价格：\u0026#34;+price+\u0026#34;\\t\\t作者：\u0026#34;+author; } } ListExercise02类：\npackage com.conllection_.lists; import java.util.*; public class ListExercise02 { public static void main(String[] args) { List list = new Vector(); list.add(new Book(\u0026#34;红楼梦\u0026#34;,\u0026#34;曹雪芹\u0026#34;,100)); list.add(new Book(\u0026#34;三国\u0026#34;,\u0026#34;罗贯中\u0026#34;,80)); list.add(new Book(\u0026#34;西游记\u0026#34;,\u0026#34;吴承恩\u0026#34;,90)); list.add(new Book(\u0026#34;水浒传\u0026#34;,\u0026#34;施耐庵\u0026#34;,9)); //list.add(new Book(\u0026#34;西游记\u0026#34;,\u0026#34;吴承恩\u0026#34;,90));  for (Object o : list){ System.out.println(o.toString()); } sort(list); System.out.println(\u0026#34;==排序后==\u0026#34;); for (Object o : list){ System.out.println(o.toString()); } } public static void sort(List list){ int listSize = list.size(); for (int i = 0; i \u0026lt;listSize-1 ; i++) { for (int j = 0; j \u0026lt; listSize-1-i; j++) { //取出对象Book  Book book1 = (Book) list.get(j); Book book2 = (Book) list.get(j+1); if(book1.getPrice() \u0026gt; book2.getPrice()){ list.set(j,book2); list.set(j+1,book1); } } } } } 运行结果：\n  ArrayList底层源码及注意事项   注意事项\n  ArrayList可以加入任意元素，包括null（或者是多个null）。\npackage com.conllection_.lists; import java.util.ArrayList; import java.util.List; public class ArrayListDetail { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(null); arrayList.add(\u0026#34;jack\u0026#34;); arrayList.add(null); System.out.println(\u0026#34;list = \u0026#34; + arrayList); } }   ArrayList是由数组来实现数据存储的\n  ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList。\nArrayList.add() 源码：\n//ArrayList.add()的源码没有修饰词synchronized public boolean add(E e) { //Increments modCount!!  ensureCapacityInternal(size + 1); elementData[size++] = e; return true; } 由于该集合的方法没有用synchronized修饰，我们可以知道ArrayList是线程不安全的！下面可以跟Vector的源码进行比较\nVector.add() 源码：\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; }     ArrayList的底层源码分析（先说结论，再分析源码）\n  ArrayList中维护了一个Object类型的数组elementData。\n//transient 表示瞬间，短暂的，表示该属性不会被序列化 transient Object[] elementData;   当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍（即初始化数组elementData的大小为0，初次添加数据时扩容成10，等到添加的数据达到容量极限时，继续扩容为elementData的1.5倍）。\n  如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容则直接扩容elementData为1.5倍\n    扩容机制源码分析\n  创建ArrayListSource类。\npackage com.conllection_.lists; import java.util.ArrayList; public class ArrayListSource { public static void main(String[] args) { //利用无参构造创建了ArrayList  ArrayList arrayList = new ArrayList(); //利用有参构造创建了ArrayList  //ArrayList list = new ArrayList(8);  for (int i = 0; i \u0026lt; 10; i++) { arrayList.add(i); } for (int i = 11; i \u0026lt; 15 ; i++) { arrayList.add(i); } arrayList.add(100); arrayList.add(200); arrayList.add(null); } }   在ArrayList arrayList = new ArrayList();出添加断点，debug。\npublic ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组，其定义：\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 可以知道此时创建了一个空的elementData数组={}！\n  下一步 执行arrayList.add()。add源码如下\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!!  elementData[size++] = e; return true; }   先确定是否需要扩容（ensureCapacityInternal） 然后再执行，赋值     进入ensureCapacityInternal方法。\nprivate void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity( calculateCapacity(elementData, minCapacity)); } 该方法调用了ensureExplicitCapacity与calculateCapacity方法。\ncalculateCapacity方法源码：\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { //DEFAULT_CAPACITY为常量，定义为10  //minCapacity为集合所需的最小容量  return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } ensureExplicitCapacity方法源码：\nprivate void ensureExplicitCapacity(int minCapacity) { // modCount为当前集合被修改的次数  //用来防止多个线程操作产生的异常。  modCount++; // overflow-conscious code  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } ensureCapacityInternal方法在这一步中首先调用了calculateCapacity方法来确定minCapacity(最小容量)然后把最小容量返回到ensureExplicitCapacity方法中，判断elementData的大小是够足够，如果不够会使用grow()方法去扩容。\n  然后通过调用grow方法 完成扩容。grow源码：\nprivate void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; //按原来大小的1.5倍扩容  int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //初始值扩容  if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; //判断容量是否超过数组最大容量  if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win:  // Arrays.copyOf可以把原先数组copy到新的elementData！  elementData = Arrays.copyOf(elementData, newCapacity); } 在这一步完成了：\n 实现扩容 使用扩容机制来确定要扩容到多大 第一次newCapacity = 10 第二次及其以后，按照1.5倍扩容 扩容使用的是Arrays.copyOf()实现，可以把原来elementData的数据copy到扩容后的elementData中 完成后把扩容后的数组逐层返回到add方法里面  扩容后的elementData：\n    当使用有参构造器创建与使用ArrayList时，扩容机制与上述基本一致。\npublic ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } this.elementData = new Object[initialCapacity]创建了指定大小的elementData数组。\ninitialCapacity为构造器传入的初始参数，即为elementData数组的初始大小。\n需要注意的是，有参构造器扩容时第一次扩容为elementData的1.5倍，并不是初始为10！\n 因为calculateCapacity方法中只有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时才会把常量DEFAULT_CAPACITY的值返回到ensureExplicitCapacity。而DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组。由于有参构造创建的elementData必不为空，所以初次扩容时的newCapaCity为elementData大小的1.5倍。\n if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } 扩容后的elementData：\n剩下的扩容步骤与无参的一样！\n    Vector底层结构和源码解析   Vector的定义：\npublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable   ector底层也是一个数组，protected Object[] elementData；\n  Vector是线程同步的，即线程安全，Vector类的操作方法都带有synchronize\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; }   Vector与ArrayList比较\n  Vector扩容的底层源码\n创建Vector_类，使用无参构造器来创建Vector。\npackage com.conllection_.lists; import java.util.Vector; public class Vector_ { public static void main(String[] args) { Vector vector = new Vector(); for (int i = 0; i \u0026lt; 10; i++) { vector.add(i); } vector.add(100); } } Vecto的无参创建初始化elementData大小为10\npublic Vector() { this(10); } 进入到add方法，通过ensureCapacityHelper判断是否需要扩容。\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } ensureCapacityHelper方法：\nprivate void ensureCapacityHelper(int minCapacity) { // overflow-conscious code  //如果最小容量大于数组的实际长度，则扩容  if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } 如果minCapacity - elementData.length \u0026gt; 0满足，则通过grow方法扩容\nprivate void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 又因为capacityIncrement=0，所以newCapacity=oldCapacity+oldCapacity，即为原来的两倍！\n扩容后的Vector：\n  ​\nLinkedList底层结构和源码解析  LinkedList底层实现了双向链表和双端队列特点 可以添加任意元素（元素可以重复），包括null LinkedList也是线程不安全的，没有实现同步    LinkedList的底层操作机制\n  LinkedList底层维护了一个双向链表。\n  LinkedList中维护了两个属性first和last分别指向首节点和尾结点。\n  每个节点（Node对象），里面又包含prev、next、item三个属性，其中通过prev指向前一个节点，通过next指向后一个节点。最终实现双向链表。\n  所以LinkedList的元素添加和删除，不是通过数组完成的，相对来说效率较高。\n  LinkedList链表示意图：\n    双向链表的创建使用演示\n创建Note类\npackage com.conllection_.lists; //定义一个Note类，Note对象表示双向链表的一个节点。 public class Note { public Object item;//存放数据  public Note pre;//指向上一个节点  public Note next;//指向下一个节点  public Note(Object name){ this.item=name; } @Override public String toString() { return \u0026#34;Note{\u0026#34; + \u0026#34;name=\u0026#34; + item + \u0026#39;}\u0026#39;; } } 在LinkedList类中模拟建立一个双向链表\npackage com.conllection_.lists; public class LinkedList01 { public static void main(String[] args) { //模拟一个简单的双向链表  //首先创建三个结点 jack、mary、tom  Note jack = new Note(\u0026#34;jack\u0026#34;); Note mary = new Note(\u0026#34;mary\u0026#34;); Note tom = new Note(\u0026#34;tom\u0026#34;); //连接三个结点形成双向链表  //jack-\u0026gt;mary-\u0026gt;tom  jack.next = mary; mary.next = tom; //tom-\u0026gt;mary-\u0026gt;jack  tom.pre = mary; mary.pre = jack; //创建头结点与尾结点  //让first引用指向jack，就是双向链表的头结点  Note first = jack; //让last引用指向tom，就是双向链表的尾结点  Note last = tom; } } 利用头结点遍历，遍历链表\n//头结点遍历 System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 利用尾结点遍历，遍历链表\nSystem.out.println(\u0026#34;==尾结点遍历==\u0026#34;); while(true){ if(last == null){ break; } System.out.println(last); last = last.pre; } 在mary结点与tom结点之间增加一个smith结点\n//在mary与tom之间增加一个smith结点  Note smith = new Note(\u0026#34;smith\u0026#34;); smith.pre = mary; smith.next = tom; mary.next = smith; tom.pre = smith; first = jack; //头结点遍历  System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 删除smith结点\n//删除smith结点  System.out.println(); System.out.println(\u0026#34;删除smith结点\u0026#34;); mary.next = tom; tom.pre = mary; first = jack; //头结点遍历  System.out.println(\u0026#34;==头结点遍历==\u0026#34;); while(true){ if(first == null){ break; } System.out.println(first); first = first.next; } 运行结果：\n  利用LinkedList的CRUD来查看其底层源码\nLinkedListCRUD.java\npackage com.conllection_.lists; import java.util.LinkedList; public class LinkedListCRUD { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); linkedList.add(100); linkedList.add(200); } } 在LinkedList linkedList = new LinkedList();处添加断点，debug。\n可以知道此时LinkedList只初始化了一个空的linkedList\npublic LinkedList() {} 此时linkedList的属性 first = null，last = null\n然后查看add方法的源码，我们可以发现add方法调用了方法linkLast\npublic boolean add(E e) { linkLast(e); return true; } 查看linkLast方法的源码，我们可以发现此时创建了一个newNode结点，并将其加入到双向链表的最后。\nvoid linkLast(E e) { //初始last为null，所以l=null  final Node\u0026lt;E\u0026gt; l = last; final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } 因为是第一个结点，所以newNode的next与last均为空。此时LinkedList的first与last均指向了newNode。此时链表的状态为：\n当我们再次往LinkedList集合中添加元素时，会再次进入到底层的linkLast方法。\nvoid linkLast(E e) { //l = last 即指向了第一个newNode  final Node\u0026lt;E\u0026gt; l = last; //此时新的newNode有prev = l 即新的newNode指向了第一个结点！  final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; //因为l = last 所以l不为null  if (l == null) first = newNode; else l.next = newNode; size++; //modCount记录集合修改的次数  modCount++; } 因为此时的last不再为空，所以结点l指向了last结点，即第一个newNode。此时链表的状态为：\n  上述代码为LinkedList集合添加元素时的源码展示，下面我们看一下LinkedList集合删除指定索引的元素时的源码：\nLinkedListCURD类\npackage com.conllection_.lists; import java.util.LinkedList; public class LinkedListCRUD { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); linkedList.add(100); linkedList.add(200); linkedList.add(300); System.out.println(\u0026#34;linkedList = \u0026#34; + linkedList); linkedList.remove(1); System.out.println(\u0026#34;linkedList = \u0026#34; + linkedList); } } 查看linkedList.remove(int index)方法。\npublic E remove(int index) { checkElementIndex(index); return unlink(node(index)); } 我们可以知道该方法首先通过checkElementIndex(index);检查索引是否合法，不合法会抛出异常。\ncheckElementIndex(index);方法源码：\nprivate void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 上述isElementIndex方法的作用用来判断元素的索引范围\nprivate boolean isElementIndex(int index) { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; } 当索引在元素的合法范围时，进入到了node(int index)方法。该方法可以返回指定元素索引处的（非空）结点。\nNode\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); \t//如果index小于size的一半，从头到尾遍历  if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { //如果index大于size的一半，从尾到头遍历  Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } 然后再通过unlink(Node x)方法删除指定索引集合元素。\nE unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null;  //把要删除的元素数据赋值给element，以便删除后返回  final E element = x.item; //新建一个结点next指向x.next  final Node\u0026lt;E\u0026gt; next = x.next; //新建一个结点prev指向x.prev  final Node\u0026lt;E\u0026gt; prev = x.prev; //如果prev == null 说明x结点为头结点。  //此时把first指向next，即说明x的下一个结点为新的头结点  if (prev == null) { first = next; } else {//否则x的上一个节点的next值指向x的下一个结点  prev.next = next; //因为x已经删除，所以把prev置为null  x.prev = null; } //如果next == null 说明该节点为尾结点  //此时吧last指向prev，即说明x的上一个结点为新的尾结点  if (next == null) { last = prev; } else {//否则把x的下一个结点的prev指向x的上一个结点  next.prev = prev; //因为x已经删除，next  x.next = null; } x.item = null; //集合的大小减一  size--; //修改次数+1次  modCount++; //最后返回被删除的元素  return element; } 下面为删除two结点的图解\n删除后的链表状态为\n  ArrayList和LinkedList比较\n  如何选择ArrayList和LinkedList\n 如果我们改查的操作多，就选ArrayList 如果我们增删操作多，就选择LinkedList 一般来说，在程序中，80%—90%都是查询，因此大部分情况下会选择ArrayList 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另一个模块使用的是LinkedList    ","date":"2021-04-05T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/","title":"Java集合类（一）"},{"content":"List list = new ArrayList();与ArrayList list = new ArrayList()\n​\tList是一个接口，而ArrayList是一个类ArrayList继承并实现了List。\n​\tList list = new ArrayList();这句话创建了一个ArrayList的对象后上溯到了List。此时它是一个List对象了，有一些ArrayList有但是List没有的属性和方法，它就不能再用了。而ArrayList alist = new ArrayList();创建了一对象则保留了ArrayList的所有属性。\n为什么一般都使用List list= new ArrayList()，而不是后者呢\n​\t问题在于List有多个实现类，如常用的LinkedList或者Vector等等，现在你用的是ArrayList，也许哪一天你需要换成其他的实现类的时候，你只需要改变：List list = new ArrayList()；这一行就可以了，其他使用了List接口的代码根本不需要改动。\n​\t假如你开始使用了ArrayList alist = new ArrayList()；你要换成其他实现类的时候，你需要把全部实现了ArrayList的代码模块都进行修改，尤其是使用了ArrayList特有的方法和属性时！\n​\t所以如果没有特别需求的话，最好使用List list = newArrayList()；这样可以便于程序代码的重构，这就是面向接口编程的好处。\n","date":"2020-05-29T16:22:25+08:00","permalink":"https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%B8%80/","title":"Java编程思想集合篇（一）"},{"content":"Java基础语法   注释、标识符、关键字 数据类型 类型转换 变量常量 运算符 包机制、JavaDoc   注释、标识符、关键字 1.注释（注释不会被执行）\n 单行注释：用\u0026quot;//\u0026ldquo;表示 多行注释：”/* */“表示 JavaDoc文档注释：用/** */表示  2.标识符\n 标识符以字母、美元符($)、下划线(_)开头 首字符之后可以是字母、美元符($)、下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或方法名 标识符是大小写敏感的 String不是关键字，是一个类  Java数据类型   整数类型\n Byte占1个字节范围-128-127 short占2个字节范围 int占四个字节范围 long占8个字节范围（Long类型要在数字后面加个L）    浮点类型\n float占4个字节范围（float类型要在数字后面加个F） double占8个字节    字符类型：char占2个字节\n  Boolean类型：占一位 其真值只有true和Flase两个\n  浮点数拓展\nfloat a1 = 0.1f;//0.1  double a2 = 1.0/10;//0.1  System.out.println(a1==a2);//此处输出为false  System.out.println(a1); System.out.println(a2); float a3 = 2121213121212f; float a4 = a3+1; System.out.println(a3==a4);//此处输出为true 因为float的有限性、离散性、舍入误差，所以以上代码比较结果如下\n    避免使用浮点数进行比较\n  字符拓展\n//字符拓展  char a1 = \u0026#39;a\u0026#39;; char a2 = \u0026#39;中\u0026#39;; System.out.println(a1); System.out.println((int)a1);//强制转换  System.out.println(a2); System.out.println((int)a2);//强制转换   输出结果为\n  所有字符的本质都是数字，所有所有字符都有对应的Unicode编码\n  Unicode的编码方式：\nchar a3 = \u0026#39;\\u0061\u0026#39;; System.out.println(a3);   类型转换   Java是强类型转换语言，所以在进行运算时，需要把不同类型的数据转换成同一类型再进行运算\n  类型优先级\n  int i = 128; double d = i;//自动转换  byte b = (byte)i;//强制转换，注意数据溢出  System.out.println(i); System.out.println(d); System.out.println(b); /** * 注意点： * 不能对布尔型进行转换 * 不能把对象类型转换为不相干的类型 * 在把高容量转换成低容量的时候，强制转换 * 转换的时候可能存在内存1溢出，或者是精度问题*/ 输出结果：\n! 因为Byte类型取值范围为-128-127所以数据溢出了。 \u0026ldquo;强制转换\u0026quot;时需要注意数据溢出； 转换方式: (类型)变量名 优先级高\u0026ndash;低时使用 自动转换：优先级低\u0026ndash;高时自动使用  数据溢出问题：\n//操作比较大的数据时 注意溢出问题  //JDK7新特性 数字之间可以用下划线_分割  int money = 10_0000_0000;//新特性  int years = 20; int total1 = money*years;//-1474836480,计算的时候已经溢出  System.out.println(money); System.out.println(years); System.out.println(total1); long total2 = money*years;//先计算再赋值，所以数据转换前已经溢出了  System.out.println(total2); long total3 = money*((long)years);//先把一个数转换成long 计算后的结果的类型即为long类型  System.out.println(total3); 输出结果：\n变量、常量、作用域   类变量\n  静态代码块（static）\n 静态代码块只会被执行一次 静态类可以被局部对象调用 静态变量可以被执行多次  public class demo5 { static int i=1; static { System.out.println(\u0026#34;a\u0026#34;); i++; } public demo5(){ System.out.println(\u0026#34;b\u0026#34;); i++; } //在此之前i已被调用两次，i的值为2  public static void main(String[] args) { demo5 d1 = new demo5();//i在次被调用，i+1，此时i=3  System.out.println(d1.i); demo5 d2 = new demo5();//i在次被调用，i+1，此时i=4  System.out.println(d2.i); } } 输出结果：\n  实例变量：从属于对象，如果不自动化初始化，这个类型的默认值为0/0.0\n  布尔值：默认是false\n  除了基本类型，其余的默认值都是null；\n    常量\n 常量定义通过final实现 一般使用大写字母表示 修饰符不存在先后顺序    变量命名规则\n  基本运算符  Java语言支持如下运算符    当java进行除法运算时，需要进行类型强转换\npackage JavaSEbase; public class demo6 { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b);//结果为0.5  System.out.println(a/(double)b); } } 显然加了强转double的表达式输出了正确的结果\n  在整数的运算过程中，有long类型则结果为long类型，其余都为int类型\npackage JavaSEbase; public class demo7 { public static void main(String[] args) { long a = 123132132132132L; int b = 123; short c = 10; byte d =8; System.out.println(a+b+c+d);//long  System.out.println(b+c+d);//int  System.out.println(c+d);//int  } }   一元运算符：自增与自减\npackage JavaSEbase; public class demo8 { public static void main(String[] args) { int a = 3; int b = a++;//先把a赋值给b再自增  //a=a+1  System.out.println(a);//此时a=4  //a=a+1  int c = ++a;//先自增再把a赋值给c  System.out.println(a);//此时a=5  System.out.println(b); System.out.println(c); } }   逻辑运算符\n  逻辑与\u0026amp;\u0026amp;：有假就假，全真才真\n  逻辑或||：有真就真，全假才假\n  逻辑与的短路运算\npackage JavaSEbase; public class demo9 { public static void main(String[] args) { //短路运算：即使用逻辑与运算时，假设前面的值为假，则运算符后面的运算不会执行  int c = 5; boolean d = (c\u0026lt;4)\u0026amp;\u0026amp;(c++\u0026lt;4);//因为c\u0026lt;4为假，所以后面c++不会被执行  System.out.println(d); System.out.println(c); } }     位运算：针对二进制数据进行的运算\n \u0026amp;：同位比较，全1才1，有0则0 |：同位比较，全0才0，有1则1 ^：同位比较，相同为0，不同位1 ~：取反符号。  package JavaSEbase; public class demo10 { public static void main(String[] args) { /* * A = 0011 1100 * B = 0000 1101 * ----------------------- * A\u0026amp;B = 0000 1100 * A|B = 0011 1101 * A^B = 0011 0001 * ~B = 1111 0010 * ----------------------- * */ } }   三元运算符\npackage JavaSEbase; public class demo11 { public static void main(String[] args) { //x ? y : z  //如果x为真，则结果为y，否则结果为z  int score = 50; String type = score \u0026lt; 60 ? \u0026#34;不及格\u0026#34;:\u0026#34;及格\u0026#34;; } }   +号运算符的特殊之处（运算符）\npackage JavaSEbase; public class demo10 { public static void main(String[] args) { int a = 10; int b = 20; a+=b;//相当于a = a+b  a-=b;//相当于a = a-b  System.out.println(a); //当+号前面有String 则自动把后面的运算也转换成String、  System.out.println(\u0026#34;\u0026#34;+a+b); System.out.println(a+b+\u0026#34;\u0026#34;); } }   包机制  命名规范  JavaDoc  https://blog.csdn.net/vbirdbest/article/details/80296136  ","date":"2020-03-28T16:22:25+08:00","image":"https://minster77.github.io/cover.jpg","permalink":"https://minster77.github.io/p/javase01/","title":"JavaSE01"}]