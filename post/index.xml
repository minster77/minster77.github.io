<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MinsterBlog</title>
    <link>https://minster77.github.io/post/</link>
    <description>Recent content in Posts on MinsterBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Sep 2021 16:22:25 +0800</lastBuildDate><atom:link href="https://minster77.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reflection</title>
      <link>https://minster77.github.io/p/reflection/</link>
      <pubDate>Sun, 05 Sep 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/reflection/</guid>
      <description>反射   反射机制 class类 类加载 反射获取类的结构信息 通过反射创建对象 练习   反射机制   引出反射
  根据配置文件re.properties指定信息，创建Cat对象并调用方法hi
properties配置文件如下
classPath=com.reflection_.Catmethod=hiCat类
package com.reflection_; public class Cat { private String name = &amp;#34;jack&amp;#34;; public void hi(){ System.out.println(&amp;#34;hi &amp;#34;+name); } } 实现类ReflectionQuestion
package com.reflection_.question; import com.reflection_.Cat; public class ReflectionQuestion { public static void main(String[] args) { //1.使用传统方法实现，通过new一个对象，调用方法来实现  Cat cat = new Cat(); cat.hi(); } } 我们使用传统的方式，能实现上述需求，但如果我们Cat类需要增加功能或者换一种实现时，我们就需要去修改源码了！
所以我们可以尝试使用反射来实现上述需求
package com.reflection_.question; import com.</description>
    </item>
    
    <item>
      <title>Java静态代理模式</title>
      <link>https://minster77.github.io/p/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 02 Sep 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>静态代理模式  间接的“美” 中国人是一个含蓄的民族，讲究微妙和间接的交流方式。对象间的间接通信也同样是面向对象设计中一条重要的审美观。间接性的通信可以给出较低的耦合关系，较强的合作关系，以及微妙的结构和易于复用的设计架构。 &amp;mdash;-&amp;laquo;Java与模式&amp;raquo;
   代理模式的定义
​	代理模式的英文叫Proxy或Surrogate。所谓代理就是指一个人或者一个机构代表另一个人或者另一个机构行动。有一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。
  意图
​	为其他对象提供一种代理以控制对这个对象的访问。
  代理模式的结构
 抽象主题角色（接口）：声明了正是主题和代理主题的共同接口。这样一来任何使用真是主题的地方都可以使用代理主题。 代理主题（Peoxy）角色（代理类）：代理主题角色内部含有一个对真实主题角色的引用。从而可以在任何时候操作真实主体对象；代理主题角色提供一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题；控制对真实主题的引用，负责在需要的时候创建真实主题对象（或删除真实主题对象）；代理主题通常在客户端调用真实主题之前或之后都要执行某个操作，而不是单纯将调用传给真实主题。 真实主题角色（被代理类）：定义了代理角色所代表的真实对象。    静态代理
​	由程序员创建或特定工具自动生成源码，也就是说在编译时就已经将接口，被代理类，代理类等确定了下来。在程序运行之前，代理类的.class文件就已经生成。
  静态代理简单实现
​	假设现在jack要结婚，jack把他的婚礼包办给了婚礼公司，在这个案例中，我们可以知道抽象主题角色便是婚礼（结婚），然后代理主题角色是婚礼公司，真实主题角色是jack。
​	首先，我们创建一个Marry接口。这个接口就是jack（被代理类）和婚礼公司（代理类）的公共接口，他们都有举办婚礼的行为。这样，jack的婚礼就可以让婚礼公司来代理执行。
创建接口Marry
interface Marry{ void HoldWedding(); } 创建被代理类Customer
class Customer implements Marry{ @Override public void HoldWedding() { System.out.println(&amp;#34;我是jack，我结婚了！&amp;#34;); } } 创建代理类WeddingCompany
class WeddingCompany implements Marry{ private Customer customer; public WeddingCompany(Customer customer){ this.customer = customer; } @Override public void HoldWedding() { before(); this.</description>
    </item>
    
    <item>
      <title>MySQL基本介绍与使用</title>
      <link>https://minster77.github.io/p/mysql%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 02 Sep 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/mysql%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>MySQL（一）   MySQL的基本介绍 MySQL的基本使用 增删改查 约束   MySQL的基本介绍   sql、DB、DBMS分别是什么，他们之间的关系？
DB：DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）
DBMS：DataBase Management System（数据库管理系统，常见的有：MySQL、Oracle、DB2、Sybase、SqlServer&amp;hellip;）
SQL：结构化查询语言，是一门标准通用的语言。标准的SQL适合于所有的数据库产品。SQL属于高级语言。SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DNMS完成）
 DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据
   什么是表？
  表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。
  一个表包括行和列：
 行：被称为数据/记录（data） 列：被称为字段（column）每一个字段包括字段名、数据类型、相关的约束      学习MySQL主要还是学习通用的SQL语句，那么SQL语句包括增删改查，SQL语句怎么分类？
 DQL（数据查询语言）：查询语句，凡是select语句都是DQL。 DML（数据操作语言）：insert(增加)、delete(删除)、update(修改)，对表当中数据进行增删改。 DDL（数据定义语言）：create(增加)、drop(删除)、alter(修改) ，对表结构的增删改。 TCL（事务控制语言）：commit提交事务、rollback回滚事务 DCL（数据控制语言）：grant授权、revoke撤销权限等。    当因为sql脚本中的数据量太大的而无法打开的时候，可以使用source。
  MySQL的基本使用 MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格：
 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。  登录数据库 mysql-h127.</description>
    </item>
    
    <item>
      <title>MySQL的进阶使用</title>
      <link>https://minster77.github.io/p/mysql%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 02 Sep 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/mysql%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</guid>
      <description>MySQL（二）   存储引擎 事务 索引 备份与还原 视图   存储引擎 ​	存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）；实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。
  创建存储引擎
CREATETABLE`t_student`(`student_id`intNOTNULL,`student_name`varchar(20)DEFAULTNULL,`sex`char(2)DEFAULTNULL,`birthday`dateDEFAULTNULL,`email`varchar(30)DEFAULTNULL,`classes_id`intDEFAULTNULL,PRIMARYKEY(`student_id`),KEY`fk_classes_id`(`classes_id`),CONSTRAINT`fk_classes_id`FOREIGNKEY(`classes_id`)REFERENCES`t_classes`(`classes_id`))ENGINE=InnoDBDEFAULTCHARSET=gbk-- ENGINE=InnoDB就是指定存储引擎 CHARSET是字符集  mysql默认的存储引擎是InnoDB。CHARSET默认的字符集是utf8
   MySQL有哪些常用的存储引擎
CMD下使用show engines\G可以查看MySQL支持的存储引擎
  MyISAM存储引擎 它管理的表具有以下特征： 使用三个文件表示每个表：
 格式文件 — 存储表结构的定义（mytable.frm） 数据文件 — 存储表行的内容（mytable.MYD） 索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。 可被转换为压缩、只读表来节省空间   提示一下：对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引。
MyISAM存储引擎特点：可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！
MyISAM不支持事务机制，安全性低。
   InnoDB存储引擎
 这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。 InnoDB存储引擎最主要的特点是：非常安全。 它管理的表具有下列主要特征：  每个 InnoDB 表在数据库目录中以.frm 格式文件表示 InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名，表空间存储数据+索引。） 提供一组用来记录事务性活动的日志文件 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理 提供全 ACID 兼容 在 MySQL 服务器崩溃后提供自动恢复 多版本（MVCC）和行级锁定 支持外键及引用的完整性，包括级联删除和更新   InnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，不能很好的节省存储空间。    MEMORY存储引擎</description>
    </item>
    
    <item>
      <title>索引的底层数据结构</title>
      <link>https://minster77.github.io/p/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 01 Sep 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>索引的底层数据结构 Hash表 哈希表是键值对的集合，通过键（key）即可快速取出对应的值（value），因此哈希表可以快速检索数据（时间复杂度接近O(1)）。
为何能通过key快速取出value呢？原因在于哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到value对应的index值，找到了index也就找到了对应的value。
hash = hashfunc(key); index = hash %array_size; 但是！哈希算法会有个Hash冲突问题，也就是说多个不同的key最后得到的index相同。通常情况下，我们会使用链地址法来解决这个问题。链地址法就是将哈希冲突数据存放在链表中。就比如JDK1.8之前HashMap就是通过链地址法来解决哈希冲突的。不过JDK1.8以后HashMap为了减少链表过长的时候搜索时间过长的问题，就引入了红黑树
为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。
既然哈希表这么快，为什么MySQL 没有使用其作为索引的数据结构呢？
1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。
2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。
试想一种情况:
SELECT*FROMtb1WHEREid&amp;lt;500;在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。
B树&amp;amp;B+树 B树也成B-Tree，全称多路平衡查找树，B+树是B树的一种变体。B树和B+树中的B是Balanced（平衡）的意思
目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。
B-Tree B-Tree是为磁盘设备设计的一种平衡查找树。
系统从磁盘读取数据到内存，是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性取出来，而不是需要什么取什么。
InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：
showvariableslike&amp;#39;innodb_page_size&amp;#39;;而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
满足以下条件的，就是B-Tree
根结点至少有两个子女 每一个结点最多包含K个孩子，K的大小取决于磁盘页的大小。
模拟查找关键字29的过程：
根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 在磁盘块8中的关键字列表中找到关键字29。
​	分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。
​	总结：说到底，B-Tree就是将原先一个结点只能存储一个值的情况，改为一个结点可以存储多个值，因为查找的时候，需要将数据从磁盘中读取到内存里面，一旦磁盘IO次数过多，就会造成查询缓慢，所以这里存储多个值，可以一次性读取相近的值，从而避免查询多次IO，将查询操作放到内存里面。内存执行效率可以忽略不计。
​	再简单说，举个例子，数据库有10条数据，id为1,2,3…10，以前要查询第10条，我查询数据库10次，然后for循环到第10条（对应二叉树）；现在不用了，现在我把1,2,3…10直接查出来，放到内存里面，直接从内存里面比较然后拿出来（对应B-Tree）
​	缺点： 结点中的数据，不仅存储了key，还存储了value值，而这些数据是存储在页中的，每一页为16KB，页存储的空间是有限的，所以有可能存在，每一个结点，只存储了一个key和value就存不下去了，也就是变成了二叉树的数据结构。深度一样，磁盘IO树也是一样了。所以又衍生出了B+Tree。</description>
    </item>
    
    <item>
      <title>Java编程思想集合篇（二）</title>
      <link>https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%BA%8C/</link>
      <pubDate>Sun, 01 Aug 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%BA%8C/</guid>
      <description>Java编程思想集合篇（二） Java HashMap为什么通过(n - 1) &amp;amp; hash 获取哈希桶数组下标？
看过HashMap源码人应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，就是通过(n - 1) &amp;amp; hash来计算的，那么为什么用的是位运算而不是取模运算(hash % n)呢？
获取hash桶数组下标源码
if ((p = tab[i = (n - 1) &amp;amp; hash]) == null){ tab[i] = newNode(hash, key, value, null); } 一. 位运算与取模运算时间比较
package com.polymorphic; public class Test { int a = 1; int number = 100000; // 数据集数量，初始定义为十万  // 位运算  public long bitwise() { long start = System.currentTimeMillis(); //从十万开始，一直到Integer的最大值，计算所需时间  for (int i = number; i &amp;gt; 0; i++) { a &amp;amp;= i; } long end = System.</description>
    </item>
    
    <item>
      <title>Lambda表达式</title>
      <link>https://minster77.github.io/p/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 01 Aug 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>Lamda表达式   Lambda表达式，可以称为闭包，它是推动Java8发动的最重要新特性
  Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）
  为什么要使用Lambda表达式
 可以避免匿名内部类定义过多 可以让你的代码看起来更加简洁 去掉了一堆没有意义的代码，只留下核心的逻辑    基本语法
(parameters)-&amp;gt;expression[表达式]; (parameters)-&amp;gt;statement[语句]; (parameters)-&amp;gt;{statement};   函数式接口（Functional Interface）是学习Lambda表达式的关键所在。其定义为：
  任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。
public interface Runnable{ public abstract void run(); }   对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。
    Lambda表达式的推导演示
现在，我们有一个函数式接口LambdaInterface，它只有一个抽象方法我们该怎样实现他的方法并执行呢？
  接口LambdaInterface
//创建函数式接口 interface LambdaInterface { void lambda(); }     创建实现类去实现接口，再创建实现类的对象，调用该方法
//1.创建实现类实现接口 class LambdaImp implements LambdaInterface { @Override public void lambda() { System.</description>
    </item>
    
    <item>
      <title>polymorphic</title>
      <link>https://minster77.github.io/p/polymorphic/</link>
      <pubDate>Mon, 28 Jun 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/polymorphic/</guid>
      <description>编译类型、运行类型及多态的区别 Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态。
 因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋值给一个父类引用变量，无须任何转型，或者被称为向上转型，由系统自动完成。  测试代码
  Father类
package com.polymorphic; public class Father { public Father(){ System.out.println(&amp;#34;Father的构造方法&amp;#34;); } public void doWork(){ System.out.println(&amp;#34;Father Do Work!&amp;#34;); } }   Son类
package com.polymorphic; public class Son extends Father{ public Son(){ System.out.println(&amp;#34;Son的构造方法&amp;#34;); } public void doWork(){ System.out.println(&amp;#34;Son Do Work!&amp;#34;); } }   Test类
package com.polymorphic; public class Test { public static void main(String[] args) { Father child = new Son(); son.doWork(); } }   运行结果</description>
    </item>
    
    <item>
      <title>Java_IO流_2</title>
      <link>https://minster77.github.io/p/java_io%E6%B5%81_2/</link>
      <pubDate>Sat, 19 Jun 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java_io%E6%B5%81_2/</guid>
      <description>JavaIO流2   BufferedReader与BufferedWriter 使用字节流实现对二进制文件复制 对象流 标准输入输出流 转换流 打印流 Properties类   BufferedReader与BufferedWriter   BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的。
  关闭处理流的时候，只需要关闭外层流即可
演示bufferedReader的使用
package com.java_io; import java.io.BufferedReader; import java.io.FileReader; public class BufferedReaderTest { public static void main(String[] args) throws Exception{ String path = &amp;#34;E://note.txt&amp;#34;; //创建BufferedReader对象  BufferedReader bufferedReader = new BufferedReader(new FileReader(path)); //按行读取，提高效率  String line; /* * bufferedReader.readLine()是按行读取文件的 * 当返回null时，表示已读取完毕 */ while ((line =bufferedReader.readLine())!=null){ System.out.println(line); } bufferedReader.close(); } }   需要注意的是，关闭流时只需要关闭BufferedReader。因为底层会自动关闭节点流</description>
    </item>
    
    <item>
      <title>Java泛型</title>
      <link>https://minster77.github.io/p/java%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Tue, 01 Jun 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型   引出泛型 泛型的介绍及使用 泛型的使用细节 泛型课堂练习题 自定义泛型 Junit   引出泛型   现在有这样的一个需求
 编写一个程序，在ArrayList中，添加三个Dog对象 Dog对象含有name和age，并输出name和age（要求使用getXxx方法）  用传统的方法编码，代码演示如下
创建Dog类
class Dog{ private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.</description>
    </item>
    
    <item>
      <title>Java_IO流</title>
      <link>https://minster77.github.io/p/java_io%E6%B5%81/</link>
      <pubDate>Sat, 29 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java_io%E6%B5%81/</guid>
      <description>Java IO流1（概念及节点流）   文件 IO流原理及流的分类 InputStream的子类及使用 OutputStream的子类及使用 利用FileInputStream及FileOutputStream进行文件copy Reader与Writer的子类及使用 节点流和处理流   文件   文件是保存数据的地方，例如word文档，txt文档等都是文件。
  文件流
文件在程序中是以流的形式来操作的
 流：数据在数据源(文件）和程序（内存）之间经历的路径 输入流：数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径    常用的文件操作
    使用new File（String pathname）创建
package com.java_io; import org.junit.Test; import java.io.File; import java.io.IOException; public class FileCreate1 { public static void main(String[] args) { } //方法1：使用new File(filePath)创建文件  @Test public void createFile01() throws IOException { //创建的文件路径名称  String filePath = &amp;#34;e:\\news1.</description>
    </item>
    
    <item>
      <title>Java单例模式</title>
      <link>https://minster77.github.io/p/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 28 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例设计模式 什么是设计模式  静态方法和属性的经典实用 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索  什么是单例模式   单例：就是单个的实例
  所谓的类的单例设计模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
  单例模式有两种方式：
  饿汉式（只有类被加载了，该对象就会被创建）
 将构造器私有化 在类的内部之间创建（该对象是static） 提供一个公共的static方法，返回对象  例如，我们规定一个人必须专一，只能有一个女朋友！
package com.singleton; public class SingleTon { public static void main(String[] args) { GirlFriend instance = GirlFriend.getInstance(); System.out.println(instance); //无论你怎么创建，该对象都是同一个  GirlFriend instance1 = GirlFriend.getInstance(); System.out.println(instance1); //返回结果为True  System.out.println(instance==instance1); } } class GirlFriend{ private String name ; //在类内部创建了对象，加static是为了可以在静态方法中返回girlFriend对象  private static GirlFriend girlFriend = new GirlFriend(&amp;#34;小红&amp;#34;); //构造器私有化  private GirlFriend(String name){ this.</description>
    </item>
    
    <item>
      <title>JavaInterface</title>
      <link>https://minster77.github.io/p/javainterface/</link>
      <pubDate>Tue, 04 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javainterface/</guid>
      <description>JavaInterface   接口的基本介绍 接口的注意事项及使用细节 接口实现与类的继承 接口的多态性   接口基本介绍   接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。
接口的定义：
interface 接口名{ //属性  //方法 } 类实现接口:
class ClassName implements Interface { //自己的属性  //自己的方法  //必须实现的接口的抽象方法 }   在jdk7前，接口里的所以方法都没有方法体，即都是抽象方法。
  jdk8后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。但默认方法需要使用default关键字修饰
  在接口中，定义抽象方法时可以省略abstract关键字。如果一个类实现了接口，则需要把接口的所有抽象方法都实现。
代码演示
创建接口Interface01
package com.interface_; public interface Interface01 { //定义属性  public int n =1; //定义抽象方法  public void A(); //定义默认方法  default public void B(){ System.out.println(&amp;#34;我是默认方法&amp;#34;); } //定义静态方法  public static void C(){ System.</description>
    </item>
    
    <item>
      <title>JavaException</title>
      <link>https://minster77.github.io/p/javaexception/</link>
      <pubDate>Mon, 03 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javaexception/</guid>
      <description>JavaException   什么是异常 异常体系结构 Java异常处理机制 自定义异常 总结   1、什么是异常   软件程序在运行过程中，非常可能遇到一些异常问题，在Java中称为异常。
  异常指程序运行中出现的不期而至的各种状况，如文件找不到、网络连接错误等。
  需要掌握的三种类型的异常
 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常：运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。 错误ERROR：错误不是异常，而是脱离程序员控制的问题。    2、异常体系结构   在Exception分支中有一个重要的子类RuntimeException(运行时异常)
 ArrayIndexOutOfBoundsException(数组下标越界异常) NullPointerException(空指针异常) ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFountException（找不到类）  等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。
  这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
  Exception与Error的区别
 Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程 Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能去处理这些异常    3、异常处理机制   当编写的代码出现异常时，程序会自动报出现异常错误
package com.exception; public class Test { public static void main(String[] args) { int a = 1; int b = 0; System.</description>
    </item>
    
    <item>
      <title>Java内部类</title>
      <link>https://minster77.github.io/p/java%E5%86%85%E9%83%A8%E7%B1%BB/</link>
      <pubDate>Mon, 03 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E5%86%85%E9%83%A8%E7%B1%BB/</guid>
      <description>Java内部类   内部类的基本介绍 局部内部类 匿名内部类 成员内部类 静态内部类   内部类基本介绍   一个类的内部又完整的嵌套了另一个类结构。被嵌套的类又称为内部类，嵌套其他类的类称为外部类。是类的五大成员之一（属性、方法、构造器、代码块、内部类）。
  内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系
  基本语法
class Outer{//外部类  class Inner{//内部类  } } class Other{//外部其他类  }   内部类的分类
 定义在外部类的局部位置上（比如方法内）：  局部内部类（有类名） 匿名内部类（没有类名，重点！）   定义在外部类的成员位置上：  成员内部类（没用static修饰） 静态内部类（使用static修饰）      局部内部类 说明：局部内部类是定义在外部类的局部位置上的，通常在方法中，并且有类名。
  可以直接访问外部类的所有成员，包含私有的
  不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final。（使用了final说明该内部类不能被继承！）
  作用域：仅仅在定义它的方法或代码块中。
  局部内部类访问外部类的成员（访问方式：直接访问）
  外部类访问局部内部类的成员（访问方式：创建对象，再访问[注意，必须在作用域内！]）
代码演示
package com.</description>
    </item>
    
    <item>
      <title>JavaOOP_02</title>
      <link>https://minster77.github.io/p/javaoop_02/</link>
      <pubDate>Sun, 02 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javaoop_02/</guid>
      <description>深入面向对象   面向对象三大特性 static关键字详解 抽象类和接口 内部类及OOP实战   面向对象三大特性 封装   我们在程序设计中要追求“高内聚，低耦合”。
 高内聚：就是类的内部数据操作细节由自己完成，不允许外部干涉 仅暴露少量的方法给外部使用    所以在设计时需要把一些数据与方法封装起来（数据的隐藏）
  属性私有，get/set调用
  作用
 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 增加了系统可维护性    代码演示
Student类
package com.oop.demo02; //学生类 public class Student { private String name; private int age; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.</description>
    </item>
    
    <item>
      <title>JavaOOP_01</title>
      <link>https://minster77.github.io/p/javaoop_01/</link>
      <pubDate>Sat, 01 May 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javaoop_01/</guid>
      <description>初识面向对象   初识面向对象 方法回顾和加深 对象的创建分析   初识面向对象   面向过程思想
 步骤清晰简单，第一步做什么，第二部做什么&amp;hellip;. 面向过程适合处理一些较为简单的问题    面向对象思想
 物以类聚，分类的思想模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！    对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。
  面向对象编程的本质就是：以类的方式组织代码，以对象的形式组织(封装)数据
  面向对象的三大特性
 封装：封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。 继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 多态：多态是同一个行为具有多个不同表现形式或形态的能力。    回顾方法和加深   静态方法与非静态方法的调用
 静态方法定义： 在类中使用static修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。  Student类
package com.oop.demo01; public class Student { //静态方法  public static void eat(){ System.out.println(&amp;#34;kazikazi&amp;#34;); } //非静态方法  public void say(){ System.out.println(&amp;#34;hello&amp;#34;); } } Demo01类</description>
    </item>
    
    <item>
      <title>JavaArray</title>
      <link>https://minster77.github.io/p/javaarray/</link>
      <pubDate>Tue, 20 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javaarray/</guid>
      <description>Java数组   数组概述 数组声明创建 java内存分析 数组使用 多维数组 Arrays类 冒泡排序 稀疏数组   数组概述  数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 每一个数据称作一个数组元素，数组元素可以通过一个下标来访问  数组声明与创建   首先必须声明数组变量，才能在程序中使用数组(声明时数组并不存在)。声明方法：
dataType[] arrayRefvar;	//首选方法 dataType addayRefvar[];	//效果相同，但不是首选方法   java语言使用new操作符来创建方法(创建后数组就存在了)，语法如下：
dataType[] arrayRefvar = new dataType[arraySize];   数组的元素是通过索引访问的，数组索引从0开始
  获取数组长度：arrays.length
  联系：给数组赋值并累加求值
package com.heng.array; public class Demo01 { public static void main(String[] args) { int[] arrays = new int[10]; int sum = 0; for (int i = 0; i &amp;lt;arrays.</description>
    </item>
    
    <item>
      <title>Java集合类（四）</title>
      <link>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%9B/</link>
      <pubDate>Fri, 16 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%9B/</guid>
      <description>Java集合类(四)   开发中如何选择集合实现类 TreeSet底层源码剖析 TreeMap底层源码剖析 Collections工具类 集合章节练习题   开发中如何选择集合实现类  在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：   先判断存储的类型（一组对象[单列]或一组键值对[双列]） 一组对象[单列]：Collection接口  允许重复：List  增删多：LinkedLike（底层维护了一个双向链表） 改查多：ArrayList（底层维护了Object类型的可变数组）   不允许重复：Set  无序：HashSet（底层是HashMap，维护了一个哈希表【数组+链表+红黑树】） 排序：TreeSet 插入和取出顺序一致：LinkeHashSet（底层是LinkedHashMap），维护了数组+双向链表     一对键值对：Map  键无序：HashMap（底层是哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树） 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap（底层是HashMap） 读取文件：Properties    TreeSet底层源码剖析   TreeSet的底层就是TreeMap
 key不允许重复。    TreeSet可以实现有序排序，但是当我们使用其无参构造器时，仍然是无序的。要使用TreeSet提供的一个构造器，传入一个比较器（匿名内部类）才能实现排序
下面使用TreeSet对数据进行排序（按字符串长度比较）
创建测试类TreeSet_
package com.conllection_.sets; import java.util.Comparator; import java.util.TreeSet; public class TreeSet_ { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { //按字符串长度进行比较  return ((String)o1).</description>
    </item>
    
    <item>
      <title>JavaMethod</title>
      <link>https://minster77.github.io/p/javamethod/</link>
      <pubDate>Thu, 08 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javamethod/</guid>
      <description>JavaMethod   什么是方法 方法的定义及调用 方法重载 命令行传参 可变参数 递归   何谓方法   方法是语句的结合，他们在一起执行一个功能。
 方法是解决一类问题的步骤的有序组合 方法包含于类中 方法在程序中被创建，在其地方被引用    设计方法时，最好保持方法的原子性，就是一个方法只完成一个功能，这样子利于我们后期的拓展。
  命名规则：首字母小写的驼峰命名法
  方法创建及使用
package com.heng.method; public class Demo01 { //main方法  public static void main(String[] args) { int sum = add(1,3); System.out.println(sum); } //add方法  public static int add(int a , int b){ return a+b; }   方法的定义及调用  方法的定义    方法包含一个方法头和一个方法体。以下是一个方法的所有部分</description>
    </item>
    
    <item>
      <title>Java集合类（三）</title>
      <link>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%89/</link>
      <pubDate>Thu, 08 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%89/</guid>
      <description>Java集合类(三)   Map接口实现类的特点和常用方法 Map接口的六大遍历方式 Map小结及HashMap底层源码分析 Hashtable基本介绍   Map接口实现类的特点和常用方法 Map接口的特点 注意：这里讲的是Jdk8的Map接口特点
  Map与Collection并列存在。用于保存具有映射关系的数据：key-value
  Map中的key和value可以是任何引用类型的数据，会封装到HashMao$Node对象中
  Map中的key不允许重复，原因和HashSet一样
  Map中的value可以重复
  Map的key可以为null，value也可以为null，但是key为null的结点只能有一个，value为null的结点可以有多个
  常用String类作为Map的key
  key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value
代码演示
package com.conllection_.maps; import java.util.HashMap; import java.util.Map; public class Map_ { public static void main(String[] args) { Map map = new HashMap(); //key不可以重复，重复的会被等价替换  //value可以重复  map.put(&amp;#34;no1&amp;#34;,&amp;#34;成志恒&amp;#34;);//k-v  map.put(&amp;#34;no2&amp;#34;,&amp;#34;张无忌&amp;#34;);//k-v  map.put(&amp;#34;no1&amp;#34;,&amp;#34;张三丰&amp;#34;);//当有相同的key，就等于等价替换  map.put(&amp;#34;no3&amp;#34;,&amp;#34;成志恒&amp;#34;);//k-v  //key只能有一个null  map.put(null,null); map.</description>
    </item>
    
    <item>
      <title>Java流程控制</title>
      <link>https://minster77.github.io/p/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 06 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>Java流程控制   用户交互Scanner 顺序结构 选择结构 循环结构 break&amp;amp;continue 练习   用户交互Scanner   通过Scanner类来获取用户的输入
  基础语法：
Scanner s = new Scanner(System.in);   通过Scanner类的next()方法获取输入的字符串，需要使用hasNext()判断是否还有输入的数据
package com.heng.scanner; import java.util.Scanner; public class demo01 { public static void main(String[] args) { //创建一个扫描器对象，用于接收用户输入的数据  Scanner scanner = new Scanner(System.in); System.out.println(&amp;#34;用next方式接收：&amp;#34;); //判断用户有没有输入字符串  if(scanner.hasNext()){ //使用next的方式来接收  String str = scanner.next(); System.out.println(&amp;#34;输出的内容为：&amp;#34;+str); } //凡是属于IO流的类如果不关闭就会一直浪费资源。所以要用完就关闭  scanner.close(); } } 因为使用next方法接收，所以空格后面的字符不能被str接收，因此可以使用nextLine()方法操作
  通过nextLine()方法获取输入的字符串，需要使用hasNextLine()判断是否还有输入的数据
package com.heng.scanner; import java.</description>
    </item>
    
    <item>
      <title>Java集合类（二）</title>
      <link>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/</link>
      <pubDate>Tue, 06 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/</guid>
      <description>Java集合类(二)   Set接口和常用方法 HashSet全面说明  思考 HashSet底层解析 HashSet底层添加元素源码分析 HashSet扩容机制和转换红黑树机制源码解析 threshold补充说明   LinkedHashSet说明及源码分析  LinkedHashSet全面说明 LinkedHashSet底层机制示意图 LinkedHashSet底层源码分析     Set接口和常用方法   Set接口基本介绍
 无序（添加和取出的顺序不一致），没有索引 不允许重复元素，所以最多包含一个null JDK API中Set接口常用的实现类有：HashSet、TreeSet等    Set接口的常用方法
 和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。（详情见Java集合类(一)）    以Set接口的实现类HashSet来讲解Set接口的方法
package com.conllection_.sets; import java.util.HashSet; import java.util.Set; public class SetMethod { public static void main(String[] args) { Set set = new HashSet(); set.add(&amp;#34;john&amp;#34;); set.add(&amp;#34;jack&amp;#34;); set.add(&amp;#34;tom&amp;#34;); set.add(&amp;#34;john&amp;#34;); set.add(null); set.add(null); System.out.println(&amp;#34;set = &amp;#34; + set); } } 运行结果：</description>
    </item>
    
    <item>
      <title>Java集合类（一）</title>
      <link>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/</link>
      <pubDate>Mon, 05 Apr 2021 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/</guid>
      <description>Java集合类（一）    集合的概念
  Collection接口和常用方法
  List接口和常用方法
  ArrayList底层源码即注意事项
  Vector底层结构和源码解析
  LinkedList底层结构和源码解析
   集合的概念   由于前面保存多个数据使用的是数组，而数组保存数据会有一些不足的地方。
 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型的元素 使用数组进行增加元素/删除会比较麻烦    若使用集合来处理数据的话，这类问题将会减少。集合的好处如下：
 可以动态保存任意多个对象，使用比较方便！ 提供了一系列方便操作对象的方法：add、remove、set、get等 使用集合添加、删除新元素的代码更加简洁了    集合的框架体系
Collection接口实现子类：
Map接口实现子类：
  集合主要有两种（单列集合，双列集合）
  Collection接口有两个重要的子接口List、Set，他们的实现子类都是单列集合
ArrayList arrayList = new ArrayList(); arrayList.add(&amp;#34;jack&amp;#34;); arrayList.add(&amp;#34;tom&amp;#34;);   Map接口的实现子类是双列集合，即以K-V形式存放数据的
HashMap hashMap = new HashMap(); hashMap.put(&amp;#34;No1&amp;#34;,&amp;#34;jack&amp;#34;); hashMap.put(&amp;#34;No2&amp;#34;,&amp;#34;tom&amp;#34;);     Collection接口和常用方法   Collection接口的特征</description>
    </item>
    
    <item>
      <title>JavaThread</title>
      <link>https://minster77.github.io/p/javathread/</link>
      <pubDate>Wed, 02 Sep 2020 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javathread/</guid>
      <description>多线程详解   进程与线程简介 创建线程 线程状态 线程同步 线程协作 线程池   进程与线程简介   进程（Process）：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——系统资源分配的最小单位。
  线程（Thread）：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。
  两者之间的区别见下图
可以发现，进程是由（线程+内存+文件/网络句柄）等元素构成的
  注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。
  普通方法调用和多线程
  核心概念
 线程就是独立的执行路径 在程序执行时，即使没有自己创建1线程，后台也会有多个线程，如主线程，gc线程(垃圾回收线程)。 main()称之为主线程，为系统的入口，用于执行整个程序 在一个程序中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。 线程会带来额外的开销，如CPU调度时间；并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。    创建线程 三种创建方式
  继承Thread创建线程
 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程  创建TestThread01类，实现继承Thread类创建线程
package com.thread_; //创建线程类方式一：继承Thread类，重写run方法，在主线程调用start开启线程。 public class TestThread01 extends Thread{ //run方法线程体  @Override public void run() { for (int i = 0; i &amp;lt; 50; i++) { System.</description>
    </item>
    
    <item>
      <title>Java编程思想集合篇（一）</title>
      <link>https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%B8%80/</link>
      <pubDate>Fri, 29 May 2020 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%B8%80/</guid>
      <description>List list = new ArrayList();与ArrayList list = new ArrayList()
​	List是一个接口，而ArrayList是一个类ArrayList继承并实现了List。
​	List list = new ArrayList();这句话创建了一个ArrayList的对象后上溯到了List。此时它是一个List对象了，有一些ArrayList有但是List没有的属性和方法，它就不能再用了。而ArrayList alist = new ArrayList();创建了一对象则保留了ArrayList的所有属性。
为什么一般都使用List list= new ArrayList()，而不是后者呢
​	问题在于List有多个实现类，如常用的LinkedList或者Vector等等，现在你用的是ArrayList，也许哪一天你需要换成其他的实现类的时候，你只需要改变：List list = new ArrayList()；这一行就可以了，其他使用了List接口的代码根本不需要改动。
​	假如你开始使用了ArrayList alist = new ArrayList()；你要换成其他实现类的时候，你需要把全部实现了ArrayList的代码模块都进行修改，尤其是使用了ArrayList特有的方法和属性时！
​	所以如果没有特别需求的话，最好使用List list = newArrayList()；这样可以便于程序代码的重构，这就是面向接口编程的好处。</description>
    </item>
    
    <item>
      <title>JavaSE01</title>
      <link>https://minster77.github.io/p/javase01/</link>
      <pubDate>Sat, 28 Mar 2020 16:22:25 +0800</pubDate>
      
      <guid>https://minster77.github.io/p/javase01/</guid>
      <description>Java基础语法   注释、标识符、关键字 数据类型 类型转换 变量常量 运算符 包机制、JavaDoc   注释、标识符、关键字 1.注释（注释不会被执行）
 单行注释：用&amp;quot;//&amp;ldquo;表示 多行注释：”/* */“表示 JavaDoc文档注释：用/** */表示  2.标识符
 标识符以字母、美元符($)、下划线(_)开头 首字符之后可以是字母、美元符($)、下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或方法名 标识符是大小写敏感的 String不是关键字，是一个类  Java数据类型   整数类型
 Byte占1个字节范围-128-127 short占2个字节范围 int占四个字节范围 long占8个字节范围（Long类型要在数字后面加个L）    浮点类型
 float占4个字节范围（float类型要在数字后面加个F） double占8个字节    字符类型：char占2个字节
  Boolean类型：占一位 其真值只有true和Flase两个
  浮点数拓展
float a1 = 0.1f;//0.1  double a2 = 1.0/10;//0.1  System.out.println(a1==a2);//此处输出为false  System.out.println(a1); System.out.println(a2); float a3 = 2121213121212f; float a4 = a3+1; System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://minster77.github.io/p/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minster77.github.io/p/</guid>
      <description>JVM   概述 ​	对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要想C/C++程序开发程序员那样为每一个new操作去写对于的delete/free操作，不容易出现内存泄漏和内存溢出问题。正是因为Java程序员把内存控制权力交给Java虚拟机，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那么排查错误将是一个非常艰巨的任务。
运行时数据区域 Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK1.8和之前的版本若有不同。
JDK1.8之前：
JDK1.8：
 JDK1.8把线程共享的内存中的方法区移到了本地内存，变成了元空间
 线程是共享的：
 **方法区：**存储虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态常量，即时编译后的代码等数据，也可能会抛出OutOfMemoryError异常。 **堆：**java虚拟机最大的内存区域，存放对象实例，也是垃圾收集器管理的主要区域，分为新生代（由Eden 与Survivor Space 组成）和老生代，可能会抛出OutOfMemoryError异常 直接内存（非运行时数据区的一部分）：jdk1.4中增加了NIO，可以分配堆外内存（系统内存替代用户内存），提高了性能。  线程是私有的：
 程序计数器：程序计数器(处于线程独)占区是一个非常小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器 **虚拟机栈：**虚拟机栈描述的是Java方法执行的动态内存模型 **本地方法栈：**本地方法栈为虚拟机执行native方法服务  程序计数器 ​	程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时可以通过改变这个程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成
​	另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有“的内存
通过上面的介绍，我们可以知道程序计数器的两个作用：
 字节码编译器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现了对程序流程的控制。如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了。  注意：程序计数器是唯一一个不会出现OutOfMemoryError（内存溢出异常）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
Java虚拟机栈 ​	与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描写的是Java方法执行的内存模型，每次方法调用数据都是通过栈传递的。
​	Java内存可以粗糙的分为堆内存和栈内存，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）
**栈帧：**每个方法执行时都要创建一个栈帧，方法执行完毕，栈帧销毁。栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等。
局部变量表：局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），局部变量表的大小在编译期便已经可以确定，在运行时期不会发生改变。
Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。
 StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常  Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://minster77.github.io/p/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minster77.github.io/p/</guid>
      <description>网络编程   概述   计算机网络：计算机网络是指将地理位置不同的具有独立功能的多态计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
​	计算机网络是指两台或更多的计算机组成的网络，在一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。
​	那什么是互联网呢？互联网互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。
​	对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。
​	TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。
  网络通信中的要素   IP地址
​	在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。
​	IP地址分为IPv4（4个字节组成）和IPv6（8个无符号整数）两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。
  域名
​	因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。
 有一个特殊的本机域名localhost，它对应的IP地址总是本机地址127.0.0.1
   网络模型
​	由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：
 应用层，提供应用程序之间的通信； 表示层：处理数据格式，加解密等等； 会话层：负责建立和维护会话； 传输层：负责提供端到端的可靠传输； 网络层：负责根据目标地址选择路由来传输数据； 链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等    TCP协议和UDP协议
 TCP是专门设计用于在因特网上提供可靠的端到端的字节流通信的协议。它是一种面向连接的协议。TCP连接是字节流而非报文流（如银行转账系统）。 UDP是向应用程序提供了一种发送封装的原始IP数据报的方法，并且发送时无需建立连接，是一种不可靠的连接（如语音、视频、游戏）。    </description>
    </item>
    
  </channel>
</rss>
