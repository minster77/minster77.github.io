<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Set接口及其子类的剖析'><title>Java集合类（二）</title>

<link rel='canonical' href='https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Java集合类（二）'>
<meta property='og:description' content='Set接口及其子类的剖析'>
<meta property='og:url' content='https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/'>
<meta property='og:site_name' content='MinsterBlog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Java' /><meta property='article:published_time' content='2021-04-06T16:22:25&#43;08:00'/><meta property='article:modified_time' content='2021-04-06T16:22:25&#43;08:00'/>
<meta name="twitter:title" content="Java集合类（二）">
<meta name="twitter:description" content="Set接口及其子类的剖析">
    <link rel="shortcut icon" href="image/icons/M.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://minster77.github.io/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/javacollection/" >
                JavaCollection
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/">Java集合类（二）</a>
    </h2>

    
    <h3 class="article-subtitle">
        Set接口及其子类的剖析
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Apr 06, 2021</time>
    </footer></div>
</header>

    <section class="article-content">
    <h2 id="java集合类二">Java集合类(二)</h2>
<hr>
<ol>
<li>Set接口和常用方法</li>
<li>HashSet全面说明
<ol>
<li>思考</li>
<li>HashSet底层解析</li>
<li>HashSet底层添加元素源码分析</li>
<li>HashSet扩容机制和转换红黑树机制源码解析</li>
<li>threshold补充说明</li>
</ol>
</li>
<li>LinkedHashSet说明及源码分析
<ol>
<li>LinkedHashSet全面说明</li>
<li>LinkedHashSet底层机制示意图</li>
<li>LinkedHashSet底层源码分析</li>
</ol>
</li>
</ol>
<hr>
<h3 id="set接口和常用方法">Set接口和常用方法</h3>
<ul>
<li>
<p>Set接口基本介绍</p>
<ol>
<li>无序（添加和取出的顺序不一致），没有索引</li>
<li>不允许重复元素，所以最多包含一个null</li>
<li>JDK API中Set接口常用的实现类有：HashSet、TreeSet等</li>
</ol>
</li>
<li>
<p>Set接口的常用方法</p>
<ul>
<li>和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。（详情见Java集合类(一)）</li>
</ul>
</li>
<li>
<p>以Set接口的实现类HashSet来讲解Set接口的方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SetMethod</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;john&#34;</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;jack&#34;</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;tom&#34;</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;john&#34;</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;set = &#34;</span> <span class="o">+</span> <span class="n">set</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div><p>运行结果：</p>
<p><img src="/image/JavaCollections02/image01.png" alt="image01"  /></p>
<p>结论：</p>
<ol>
<li>set接口的实现类的对象（set接口对象），不能存放重复的元素，可以添加null</li>
<li>set接口对象存放数据是无序（即添加的顺序和取出的顺序不一致）</li>
<li>取出的顺序虽然不是添加的属性，但是顺序是固定的！</li>
</ol>
</li>
<li>
<p>Set接口的遍历方式</p>
<p>同Collection的便利方式一样，因为Set接口是Collection接口的子接口。</p>
<ul>
<li>
<p>使用迭代器</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;===迭代器遍历===&#34;</span><span class="o">);</span>
<span class="n">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">next</span> <span class="o">=</span>  <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;set = &#34;</span><span class="o">+</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p>增强for</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;增强for遍历&#34;</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">:</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;set = &#34;</span><span class="o">+</span><span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p><strong>不能使用</strong>索引的方式来获取</p>
</li>
</ul>
</li>
</ul>
<h3 id="hashset全面说明">HashSet全面说明</h3>
<ol>
<li>
<p>HashSet实现了Set接口</p>
</li>
<li>
<p>HashSet实际上是HashMap</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">HashSet</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p>可以存放null值，但是只能有一个</p>
</li>
<li>
<p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序与取出顺序一致）</p>
</li>
<li>
<p>不能有重复元素或对象</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSet01</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Set</span> <span class="n">hashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>
        <span class="cm">/*说明
</span><span class="cm">        * 1. 在执行add方法后，会返回一个Boolean值
</span><span class="cm">        * 2. 如果添加成功，返回true，否则返回false
</span><span class="cm">        * 3. 可以通过remove指定删除哪个对象
</span><span class="cm">        * */</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;mary&#34;</span><span class="o">));</span><span class="c1">//T
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;mary&#34;</span><span class="o">));</span><span class="c1">//F
</span><span class="c1"></span>
        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;jack&#34;</span><span class="o">);</span><span class="c1">//可以添加
</span><span class="c1"></span>        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;jack&#34;</span><span class="o">);</span><span class="c1">//添加失败
</span><span class="c1"></span>        <span class="c1">//由于下面每一次add都新建了一个Dog对象
</span><span class="c1"></span>        <span class="c1">//所以下面两个Dog对象都会添加成功
</span><span class="c1"></span>        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&#34;tom&#34;</span><span class="o">));</span>
        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&#34;tom&#34;</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;HashSet = &#34;</span><span class="o">+</span> <span class="n">hashSet</span><span class="o">);</span>
        <span class="n">hashSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">&#34;mary&#34;</span><span class="o">);</span><span class="c1">//删除mary
</span><span class="c1"></span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;HashSet = &#34;</span><span class="o">+</span> <span class="n">hashSet</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><img src="/image/JavaCollections02/image02.jpg" alt="image02"  /></p>
</li>
</ol>
<h4 id="思考">思考</h4>
<ul>
<li>
<p><strong>下面两个String对象都会被添加到HashSet集合里面去吗？</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;czh&#34;</span><span class="o">));</span>
<span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;czh&#34;</span><span class="o">));</span>
</code></pre></div><p>运行的结果是仅有一个数据被添加，为什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</code></pre></div><p>因为此时String类型重写的equals()方法是比较其字符串内容是否相同，所以此时添加的两个“czh”数据只有一个能被添加进去。</p>
<p>而上述Dog对象的添加原理也是类似。</p>
<p>下面我们通过解读HashSet的底层结构解决这个问题！</p>
</li>
</ul>
<h4 id="hashset底层解析">HashSet底层解析</h4>
<ul>
<li>
<p>因为HashSet的底层是HashMap，所以分析HashMap底层是（数组+链表+红黑树）即可</p>
<p>为了更好理解HashMap的底层，下面模拟一个简单的数组+链表结构</p>
<p><img src="/image/JavaCollections02/image03.jpg" alt="image03"  /></p>
<p>创建Node结点</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//结点Node，item存储数据，next指向下一个结点，可以形成链表
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Node</span><span class="o">{</span>
    <span class="n">Object</span> <span class="n">item</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Object</span> <span class="n">item</span><span class="o">,</span> <span class="n">Node</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>创建HashSetStructure类</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSetStructure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//1. 创建一个类型为Node的数组
</span><span class="c1"></span>        <span class="n">Node</span><span class="o">[]</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">16</span><span class="o">];</span>
        <span class="c1">//2. 创建结点
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">john</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="s">&#34;john&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">nodes</span><span class="o">[</span><span class="n">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">john</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">jack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="s">&#34;jack&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">john</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">jack</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">mary</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="s">&#34;mary&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">jack</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mary</span><span class="o">;</span>

        <span class="n">Node</span> <span class="n">lucy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="s">&#34;lucy&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">nodes</span><span class="o">[</span><span class="n">3</span><span class="o">]</span> <span class="o">=</span> <span class="n">lucy</span><span class="o">;</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;node = &#34;</span><span class="o">+</span><span class="n">nodes</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>运行结果：</p>
<p><img src="/image/JavaCollections02/image04.jpg" alt=""  /></p>
</li>
</ul>
<h4 id="hashset底层添加元素源码分析">HashSet底层添加元素源码分析</h4>
<ul>
<li>
<p>分析HashSet添加元素的底层是如何实现的（hash()+equals()）</p>
<ol>
<li>HashSet底层就是HashMap</li>
<li>添加一个元素时，先通过hash()得到hash值，然后转换成索引值</li>
<li>找到存储数据表table，看这个索引位置是否已经存放了元素
<ol>
<li>如果没有，直接添加</li>
<li>如果有元素，调用equals比较，如果元素内容相同，就放弃添加，如果不相同，则添加到最后</li>
</ol>
</li>
<li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。</li>
<li>当元素个数到达TREEIFY_THRESHOLD但table的大小小于MIN_TREEIFY_CAPACITY(默认64)时，系统会把table表填扩容到64，然后进行树化。</li>
</ol>
</li>
<li>
<p>HashSet添加元素的源码解读</p>
<p>创建HashSetSource类，用于debug</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSetSource</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashSet</span> <span class="n">hashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>
        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;jack&#34;</span><span class="o">);</span>
        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;tom&#34;</span><span class="o">);</span>
        <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;jack&#34;</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;set = &#34;</span> <span class="o">+</span> <span class="n">hashSet</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ol>
<li>
<p>执行构造器</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">HashSet</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div><p>可以清晰地知道HashSet的底层就是HashMap</p>
</li>
<li>
<p>执行add()方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="c1">//e=&#34;jack&#34;
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">PRESENT</span><span class="o">)==</span><span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>PRESENT是hashSet为了能使用hashMap而定义的一个常量（定值），无论添加了多少的元素它都不会变化</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">PRESENT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
</code></pre></div></li>
<li>
<p>执行put()方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="c1">//key = &#34;jack&#34;
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>value为PRESENT,是共享的。</p>
</li>
<li>
<p>执行hash方法，计算key的hash值</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>如果key != null，程序会执行Object类中的hashCode()方法来获取key的值，并将它进行无符号右移16位（为了防止key的hashCode值发生冲突），最后得到的h为key对应的hash值。</p>
<p><strong>hash值并不是hashCode，因为(h = key.hashCode()) ^ (h &raquo;&gt; 16)</strong></p>
</li>
<li>
<p>获取到hash值后，执行putVal方法（<strong>重要！</strong>）</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
               <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span><span class="c1">//定义了辅助变量
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span><span class="c1"></span>            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>在此方法中，因为辅助变量tab的初始值为null，所以进入到resize()方法，给tab表赋予初始大小。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">){</span>
    <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>上述代码中的table为hashMap的一个属性，类型为Node[]</p>
<p><img src="/image/JavaCollections02/image05.jpg" alt="image05"  /></p>
<p>因为初始的table为null，所以执行resize()方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//下面代码为resize()方法的一些初始赋值
</span><span class="c1"></span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span><span class="c1">//结点oleTab表示原先的表
</span><span class="c1">//oldCap表示初始表的容量大小
</span><span class="c1"></span><span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="c1">//oldThr为当前表的一个临界值，当达到临界值时会扩容
</span><span class="c1"></span><span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</code></pre></div><p>因为初始的table为null，所以oldCap为0，所以进入到下述语句</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">else</span> <span class="o">{</span>        <span class="c1">// zero initial threshold signifies using defaults
</span><span class="c1"></span>    <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
    <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>DEFAULT_INITIAL_CAPACITY为hashMap定义的常量，大小为16</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">4</span><span class="o">;</span> <span class="c1">// aka 16
</span></code></pre></div><p>所以newCap= 16，即第一次扩容大小为16</p>
<p>newThr为表的一个临界值，是使用负载因子DEFAULT_LOAD_FACTOR乘以初始大小等到的一个值。</p>
<blockquote>
<p>默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p>
</blockquote>
<p>使用newThr是为了减少冲突，增加一个缓冲区，避免在多线程向表中增加数据时，表的内存不够而导致死锁。</p>
<p>初始化tap的大小之后，会判断**(p = tab[i = (n - 1) &amp; hash])**是否为null，(n - 1) &amp; hash是位运算，详解见HashMap数学原理。计算出来的i为该key值在table表中的索引位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>如果p=null，表示还没有存放元素，执行**tab[i] = newNode(hash, key, value, null);**创建一个Node（key=“jack&quot;,value=PRESENT）把hash也放进Node是为了下次添加元素时比较。</p>
<p>执行完毕，此时我们可以发现此时table表中已经在刚刚计算出来的索引值上添加了“jack”。</p>
<p><img src="/image/JavaCollections02/image06.jpg" alt="image06"  /></p>
<p>到此为止，HashMap的<strong>第一次</strong>添加元素分析完毕。</p>
<p>当我们向HashMap集合表再次添加数据时，系统会计算其hash值，然后通过</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>方法判断该hash值对应的索引位置上是否已经存在值，<strong>如果不存在</strong>，即把新增的key添加到表中的该索引位置上。</p>
<p>此时可以发现，table表上多了一个数据</p>
<p><img src="/image/JavaCollections02/image07.jpg" alt="image07"  /></p>
<p>如果该hash值对应的索引位置上已经存在值，程序会跳到下面语句</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//p为当前索引位置上对应的链表的第一个元素，即已经添加的值
</span><span class="c1">//所以p.hash为已存在值得hash值，p.key为已存在值得key值
</span><span class="c1"></span><span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))){</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>如果<strong>当前索引位置上对应的链表的第一个元素的hash值</strong>与需要添加的key的hash值一样</p>
<p>且满足以下两个条件之一：</p>
<ul>
<li>准备添加的key值与p指向的Node结点的key是同一个对象</li>
<li>p指向的Node结点的key的equals()和准备假如的key比较后相同。</li>
</ul>
<p><strong>需要注意的是，此时equals()方法不能理解为只比较字符串内容是否相同，因为每一个类都会有其对应的equals()方法，所以equals()方法的比较内容可以由程序员所重写的方法来决定！</strong></p>
<p>此时说明新增加的key值已存在，所以该key值不会被添加到table中。</p>
<p><img src="/image/JavaCollections02/image08.jpg" alt="image08"  /></p>
<p>若不满足上述条件，程序会继续往下走，执行下面语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">){</span>
    <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>上述语句会判断p是否为红黑树，如果是红黑树，就调用putTreeVal进行添加。</p>
<p>如果p不是红黑树，执行以下代码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">else</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//这是条件1
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>                <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//这是条件2
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>因为在可以执行上述代码时，说明此时<strong>table表中是使用链表的方式来存储数据</strong> 。</p>
<p>此时进入一个死循环，退出的条件：</p>
<ol>
<li>
<p>条件1：在要加入的位置i = (n - 1) &amp; hash处所形成的链表没有一个结点与要加入的结点相同时，退出循环，此时就加在最末尾。添加成功</p>
<p><img src="/image/JavaCollections02/image09.jpg" alt="image09"  /></p>
</li>
<li>
<p>条件2 :在要加入的位置i = (n - 1) &amp; hash处所形成的链表有结点与要加入的结点相同，此时退出循环，添加失败</p>
<p><img src="/image/JavaCollections02/image10.jpg" alt="image10"  /></p>
</li>
</ol>
<p>两个条件结合起来使用</p>
<p><img src="/image/JavaCollections02/image11.jpg" alt="image11"  /></p>
<p>需要注意的是当我们把元素添加到聊表后，会进行以下判断</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">){</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>	<span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>判断链表是否<strong>已经达到</strong>8个结点（TREEIFY_THRESHOLD=8）。如果到达，则调用treeifyBin(tab, hash)方法对当前链表进行树化（转换成红黑树）。</p>
<p>注意，在转换成红黑树时，treeifyBin(tab, hash)方法会进行判断</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MIN_TREEIFY_CAPACITY</span><span class="o">){</span>
    <span class="n">resize</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>判断table表大小是否&lt;64，如果小于64，会先将table表进行扩容，再进行树化。</p>
</li>
</ol>
</li>
</ul>
<h4 id="hashset扩容机制和转换红黑树机制源码解析">HashSet扩容机制和转换红黑树机制源码解析</h4>
<ol>
<li>
<p>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）=16*负载因子（loadFactor）0.75 = 12</p>
</li>
<li>
<p>如果数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是 32 * 0.75 = 24，依次类推</p>
</li>
<li>
<p>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></p>
<p>创建测试类HashSetIncrement.java</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Objects</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSetIncrement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashSet</span> <span class="n">hashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">12</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hashSet = &#34;</span><span class="o">+</span> <span class="n">hashSet</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Class A</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">100</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在HashSetIncrement类中的for循环处加一个断点，debug。可以发现，当i=9时，即满足一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，此时触发转换红黑树机制。</p>
<p>但是此时不满足table表大小&gt;=64</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MIN_TREEIFY_CAPACITY</span><span class="o">){</span>
    <span class="n">resize</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>所以此时table表会进行扩容。</p>
<p><img src="/image/JavaCollections02/image12.jpg" alt="image12"  /></p>
<p>继续执行，可以发现table再次扩容。</p>
<p><img src="/image/JavaCollections02/image13.jpg" alt="image13"  /></p>
<p>再继续执行，可以发现此时链表已经发生树化（转换成红黑树）</p>
<p><img src="/image/JavaCollections02/image14.jpg" alt="image14"  /></p>
<p>树化过程的源码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">replacementTreeNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tl</span><span class="o">;</span>
            <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">hd</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">hd</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>详细解释见<a class="link" href="https://blog.csdn.net/weixin_40255793/article/details/80748946"  target="_blank" rel="noopener"
    >Jdk1.8集合框架之HashMap源码解析</a></p>
</li>
</ol>
<h4 id="threshold补充说明">threshold补充说明</h4>
<ul>
<li>
<p>在putVal方法中，有这么一行代码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">){</span>
    <span class="n">resize</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
</code></pre></div><p>modCount代表我们对table表修改的次数。</p>
<p>其中size是每当我们加入一个结点Node(key,value,hash,next)，size++。</p>
<p>所以当我们想table表中加入指定数量的Node结点是，也会触发扩容机制。</p>
<p>代码演示HashSetIncrement类</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Objects</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSetIncrement</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashSet</span> <span class="n">hashSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">7</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="n">7</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">hashSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hashSet = &#34;</span><span class="o">+</span> <span class="n">hashSet</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Class A 与 Class B</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">;</span>

    <span class="kd">public</span> <span class="nf">B</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">200</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">100</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>运行调试，可以发现，虽然我们在一条链表上增加了7个元素，然后第二条链表增加到第五个元素时size=12，也触发了扩容机制</p>
<p><img src="/image/JavaCollections02/image15.jpg" alt="image15"  /></p>
<p>所以触发扩容机制的前提是累积添加元素到达threshold。</p>
</li>
</ul>
<p>​</p>
<h3 id="linkedhashset说明及源码分析">LinkedHashSet说明及源码分析</h3>
<h4 id="linkedhashset全面说明">LinkedHashSet全面说明</h4>
<ol>
<li>LinkedHashSet是HashSet的子类。</li>
<li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表。</li>
<li>LinkedHashSet根据元素的HashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是一插入顺序保存的。</li>
<li>LinkedHashSet不允许添加重复元素。</li>
</ol>
<h4 id="linkedhashset底层机制示意图">LinkedHashSet底层机制示意图</h4>
<ul>
<li>
<p>示意图</p>
<p><img src="/image/JavaCollections02/image16.jpg" alt="image16"  /></p>
</li>
<li>
<p>双向链表具体机制与<a class="link" href="https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/#linkedlist%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"  target="_blank" rel="noopener"
    >LinkedList底层结构</a>类似。</p>
</li>
</ul>
<h4 id="linkedhashset底层源码分析">LinkedHashSet底层源码分析</h4>
<p><strong>说明</strong></p>
<ul>
<li>
<p>在LInkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）</p>
</li>
<li>
<p>每个节点有before和after属性，这样可以形成双向链表</p>
</li>
<li>
<p>在添加一个元素时，先求hash值，再求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加；原则跟hashset一样）</p>
</li>
<li>
<p>所以，我们遍历LinkedHash可以确定插入顺序和取出顺序一致</p>
<p>创建LinkedHashSetSource类，用于分析源码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.conllection_.sets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.LinkedHashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedHashSetSource</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">();</span>

        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;AA&#34;</span><span class="o">));</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">456</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">456</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">123</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;czh&#34;</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;LinkedHashSet = &#34;</span> <span class="o">+</span> <span class="n">set</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>可以知道，添加第一次时，系统会将数组table扩容到16，存放的结点类型是LinkedHashMap$Entry</p>
<p><img src="/image/JavaCollections02/image17.jpg" alt="image17"  /></p>
<p>为什么数组时HashMap$Node[]类型，而存放的元素/数据却是LinkedHashMap$​​​​Entry呢？</p>
<p>下面我们查看LinkedHashMap底层源码来解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">;</span>
    <span class="n">Entry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>我们可以发现上面这个在LinkedHashMap源码中的静态内部类Entry继承了HashMap.Node。即数组的多态。双向链表实现的关键也是在这里。</p>
<p>继续往下调试</p>
<p><img src="/image/JavaCollections02/image18.jpg" alt="image18"  /></p>
<p>此时的map与hashSet的不一样，多了几个属性。其中head表示双向链表中的头结点，tail表示尾结点。</p>
<p>而每一个结点又有before与after属性，指向上一个结点与下一个结点。</p>
<p><img src="/image/JavaCollections02/image19.jpg" alt="image19"  /></p>
<p>所以LinkedHashSet可以实现按顺序插入及取出。</p>
<p>进入add()方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">PRESENT</span><span class="o">)==</span><span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>可以知道LinkedHashSet添加元素底层就是<a class="link" href="#HashSet%e5%ba%95%e5%b1%82%e6%b7%bb%e5%8a%a0%e5%85%83%e7%b4%a0%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90" >HashSet添加元素</a>的底层（<strong>因为LinkedHashSet是HashSet的实现子类</strong>）</p>
</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/java/">Java</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/">
        
        

        <div class="article-details">
            <h2 class="article-title">Java集合类（一）</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
     
        
    <script src="https://utteranc.es/client.js" 
        repo="minster77/hugoblogtalks"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 MinsterBlog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.4.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#java集合类二">Java集合类(二)</a>
      <ol>
        <li><a href="#set接口和常用方法">Set接口和常用方法</a></li>
        <li><a href="#hashset全面说明">HashSet全面说明</a>
          <ol>
            <li><a href="#思考">思考</a></li>
            <li><a href="#hashset底层解析">HashSet底层解析</a></li>
            <li><a href="#hashset底层添加元素源码分析">HashSet底层添加元素源码分析</a></li>
            <li><a href="#hashset扩容机制和转换红黑树机制源码解析">HashSet扩容机制和转换红黑树机制源码解析</a></li>
            <li><a href="#threshold补充说明">threshold补充说明</a></li>
          </ol>
        </li>
        <li><a href="#linkedhashset说明及源码分析">LinkedHashSet说明及源码分析</a>
          <ol>
            <li><a href="#linkedhashset全面说明">LinkedHashSet全面说明</a></li>
            <li><a href="#linkedhashset底层机制示意图">LinkedHashSet底层机制示意图</a></li>
            <li><a href="#linkedhashset底层源码分析">LinkedHashSet底层源码分析</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
